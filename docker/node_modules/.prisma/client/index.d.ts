
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string | null
  userPhoto: string | null
  phoneNumber: string | null
  countryCode: CountryCode | null
  documentId: string | null
  url: string | null
  email: string | null
  pin: string | null
  deviceToken: string | null
  createdAt: Date
  verified: boolean
  expoPushToken: string | null
  inviterId: string | null
  faceIdImage: string | null
  documentCountry: CountryCode | null
  documentData: Prisma.JsonValue | null
  documentFirstName: string | null
  documentLastName: string | null
  documentImage: string | null
  documentGender: GenderEnum | null
  documentDateOfBirth: Date | null
  documentDateOfIssue: Date | null
  documentSerialNumber: string | null
  documentCreatedAt: Date | null
}

/**
 * Model UsersWallets
 * 
 */
export type UsersWallets = {
  userId: string
  walletId: string
  role: WalletRole
}

/**
 * Model Customer
 * 
 */
export type Customer = {
  customerId: string
  vendorId: string
}

/**
 * Model Supplier
 * 
 */
export type Supplier = {
  supplierId: string
  vendorId: string
}

/**
 * Model Badge
 * 
 */
export type Badge = {
  id: string
  account: string
  active: boolean | null
  createdAt: Date | null
  type: BadgeType | null
  count: number | null
  level: number | null
}

/**
 * Model Blacklist
 * 
 */
export type Blacklist = {
  id: string
  taxId: string | null
  documentId: string | null
  phoneNumber: string | null
  createdAt: Date | null
}

/**
 * Model Wallet
 * 
 */
export type Wallet = {
  id: string
  name: string | null
  category: string | null
  type: WalletTypesEnum
  balance: number
  account: string
  createdAt: Date
  currency: CurrencyEnum | null
  settlementAutomatic: boolean | null
  settlementDefaultId: string | null
  verificationStartedAt: Date | null
  shippingId: string | null
  picture: string | null
}

/**
 * Model Trust
 * 
 */
export type Trust = {
  account: string
  trustRating: number | null
  score: number | null
  createdAt: Date
}

/**
 * Model MetaData
 * 
 */
export type MetaData = {
  walletAccount: string
  CRB: Prisma.JsonValue | null
  taxId: string | null
  taxName: string | null
  seller: boolean | null
  sellerPhase: phaseEnum | null
  buyerPhase: phaseEnum | null
  partnerRole: partnerRoleEnum | null
  documentCOI: string | null
  documentCR12: string | null
  documentSCF: string | null
  documentSCA: string | null
  documentStore: string | null
  documentKRAcert: string | null
  legalStatus: legalStatusEnum | null
  metaBaseURL: Prisma.JsonValue | null
  buyer: boolean | null
  maxBuyerOrderAmount: number | null
}

/**
 * Model Transaction
 * 
 */
export type Transaction = {
  id: string
  amount: number
  fee: number
  totalAmount: number
  description: string | null
  paymentType: PaymentTypesEnum
  paymentTypeId: string | null
  currency: CurrencyEnum
  transactionType: TransactionTypeEnum | null
  method: TransactionMethodEnum | null
  walletId: string | null
  createdAt: Date
  name: string | null
  balanceAfter: number | null
  balanceBefore: number | null
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  vendorId: string | null
  quantity: number | null
  vendorName: string | null
  vendorType: string | null
  name: string | null
  price: number | null
  unitPrice: number | null
  listedPublic: boolean | null
  description: string | null
  gallery: Prisma.JsonValue | null
  categories: Prisma.JsonValue | null
  createdAt: Date
  currency: CurrencyEnum | null
  ecommercePlatform: EcommercePlatformEnum | null
  platformId: string | null
  affiliateId: string | null
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: string
  userId: string | null
  vendorId: string | null
  status: OrderStatusEnum | null
  notes: string | null
  name: string | null
  phoneNumber: string | null
  affiliateId: string | null
  products: Prisma.JsonValue | null
  items: Prisma.JsonValue | null
  deliveryCode: string | null
  createdAt: Date
  paymentStatus: PaymentStatusEnum
  amount: number
  paymentMethod: OrderPaymentMethodsEnum | null
  billingId: string | null
  shippingId: string | null
  ecommercePlatform: EcommercePlatformEnum | null
  currency: CurrencyEnum | null
  platformId: string | null
  customerId: string | null
  referenceNumber: string | null
}

/**
 * Model Billing
 * 
 */
export type Billing = {
  id: string
  firstName: string | null
  lastName: string | null
  company: string | null
  address1: string | null
  address2: string | null
  city: string | null
  state: string | null
  postcode: string | null
  country: string | null
  email: string | null
  phoneNumber: string | null
  walletId: string | null
}

/**
 * Model BuyerContacts
 * 
 */
export type BuyerContacts = {
  id: string
  walletId: string
  name: string
  phoneNumber: string
  createdAt: Date
}

/**
 * Model Shipping
 * 
 */
export type Shipping = {
  id: string
  firstName: string | null
  lastName: string | null
  company: string | null
  address1: string | null
  address2: string | null
  city: string | null
  state: string | null
  postcode: string | null
  country: string | null
  email: string | null
  longitude: string | null
  shippingType: ShippingTypeEnum | null
  shippingFee: number | null
  latitude: string | null
  phoneNumber: string | null
  walletId: string | null
  isDefault: boolean | null
  seviVerified: boolean | null
  createdAt: Date | null
}

/**
 * Model Credit
 * 
 */
export type Credit = {
  id: string
  typeId: string | null
  currency: CurrencyEnum | null
  orderId: string | null
  type: creditRefType | null
  amount: number | null
  debtorId: string | null
  creditorId: string | null
  installmentsCount: number | null
  installmentsCountPaid: number | null
  status: creditStatusEnum | null
  description: string | null
  totalPaid: number | null
  totalToPay: number | null
  agreedDate: Date | null
  userId: string | null
  createdAt: Date
  referenceNumber: string
  creditConfigurationId: string
  endDate: Date | null
  paidAt: Date | null
  duration: number | null
  durationSlices: SlicesEnum
  affiliateId: string | null
  defaultAt: Date | null
  fundUpfrontAmount: number | null
  orderWalletId: string | null
  fundFeesAmount: number | null
  amountWithFees: number | null
  seviFeesAmount: number | null
  orderWalletShareFeesAmount: number | null
  fundPostDeliveryAmount: number | null
}

/**
 * Model Installment
 * 
 */
export type Installment = {
  id: string
  installmentCount: number | null
  startDate: Date | null
  endDate: Date | null
  referenceNumber: string | null
  amount: number
  paidAmount: number
  debtorId: string | null
  creditorId: string | null
  orderId: string | null
  status: installmentStatusTypeEnum | null
  firstTryFailedAt: Date | null
  creditId: string | null
  createdAt: Date
  userId: string | null
  amountWithPenalty: number
  seviFees: number
  penalty: number
  paidAt: Date | null
  creditConfigurationId: string
  affiliateFees: number
  currency: CurrencyEnum | null
}

/**
 * Model Activity
 * 
 */
export type Activity = {
  id: string
  entityId: string | null
  entityType: ActivityEntityType | null
  priority: ActivityPriority | null
  phoneNumber: string | null
  message: Prisma.JsonValue | null
  isRead: boolean | null
  createdAt: Date
  entity: Prisma.JsonValue | null
  userId: string | null
}

/**
 * Model Message
 * 
 */
export type Message = {
  messageId: string
  installmentSlices: SlicesEnum[]
  SMS: string | null
  description: string | null
  pushNotificationTitle: string | null
  pushNotificationBody: string | null
  email: string | null
  language: language
}

/**
 * Model Verify
 * 
 */
export type Verify = {
  id: string
  UID: string | null
  phoneNumber: string | null
  countryCode: CountryCode | null
  createdAt: Date | null
  creditConfigId: string | null
  OTP: string | null
  email: string | null
  userId: string | null
  orderPaymentMethod: OrderPaymentMethodsEnum | null
}

/**
 * Model Login
 * 
 */
export type Login = {
  id: string
  qrKey: string | null
  jwt: string | null
  userId: string | null
  createdAt: Date
}

/**
 * Model Visit
 * 
 */
export type Visit = {
  id: string
  account: string
  createdAt: Date | null
  visitedBy: string | null
  visitedByReference: string | null
  whenVisitTookPlace: Date | null
}

/**
 * Model ReferenceNumber
 * 
 */
export type ReferenceNumber = {
  id: string
  prefix: string
  lastReference: number | null
}

/**
 * Model Job
 * 
 */
export type Job = {
  id: string
  status: JobStatus
  version: number
  createdAt: Date
  name: string
}

/**
 * Model CreditConfiguration
 * 
 */
export type CreditConfiguration = {
  id: string
  name: string
  shouldPayDeposit: boolean | null
  depositPercentage: number
  duration: number
  slices: SlicesEnum
  seviFeesPercentage: number
  daysToStartAfterDelivery: number
  lateInstallmentFeesPercentage: number
  affiliatePercentage: number
  creditLateFeesPercentage: number
  creditLateDays: number
  createdAt: Date | null
  status: CreditConfigurationStatus
  numberOfAllowedCredits: number
  fundFeesPercentage: number | null
  fundId: string
}

/**
 * Model CreditConfigurationsWallets
 * 
 */
export type CreditConfigurationsWallets = {
  configurationId: string
  walletId: string
  upfrontPercentage: number
  fundFeesPercentage: number
  maxOrderAmount: number
  maxOutstandingCredit: number
  shareFeesPercentage: number
  postDeliveryPercentage: number
}

/**
 * Model OtherMemberKYC
 * 
 */
export type OtherMemberKYC = {
  id: string
  name: string
  documentId: string
  documentCountry: CountryCode | null
  documentData: Prisma.JsonValue | null
  documentFirstName: string | null
  documentLastName: string | null
  documentImage: string | null
  documentGender: GenderEnum | null
  documentDateOfBirth: Date | null
  documentDateOfIssue: Date | null
  documentSerialNumber: string | null
  documentCreatedAt: Date | null
  profilePictureURL: string
  idCardURL: string
  createdAt: Date
  createdByUserId: string
  userIdToKYC: string
  OTP: string
}

/**
 * Model Settings
 * 
 */
export type Settings = {
  woocommerceUrl: string | null
  woocommerceConsumerKey: string | null
  woocommerceActive: boolean | null
  woocommerceConsumerSecret: string | null
  walletAccount: string
}

/**
 * Model Settlement
 * 
 */
export type Settlement = {
  id: string
  type: TransactionMethodEnum
  account: string
  bankAccount: string | null
  bankAccountName: string | null
  bankBranch: string | null
  bankName: string | null
  phoneNumber: string | null
  tillNumber: string | null
  paybillNumber: string | null
  verified: boolean | null
  verifiedByUser: string | null
  createdAt: Date
  createdBy: string
  createdByAgent: boolean
}

/**
 * Model Question
 * 
 */
export type Question = {
  id: string
  answersType: answerTypeEnum
  category: QuestionCategoryEnum
  question: string
  isActive: boolean
  description: string | null
}

/**
 * Model Answer
 * 
 */
export type Answer = {
  id: string
  questionId: string
  createdAt: Date
  answer: string
  answeredBy: string | null
  answeredByReference: string | null
  account: string
}

/**
 * Model CreditRequest
 * 
 */
export type CreditRequest = {
  id: string
  status: CreditRequestStatus
  orderId: string
  wallet: string
  creditConfigurationId: string
  userId: string
  createdAt: Date
  proceedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const CountryCode: {
  AF: 'AF',
  AL: 'AL',
  DZ: 'DZ',
  AS: 'AS',
  AD: 'AD',
  AO: 'AO',
  AI: 'AI',
  AQ: 'AQ',
  AG: 'AG',
  AR: 'AR',
  AM: 'AM',
  AW: 'AW',
  AU: 'AU',
  AT: 'AT',
  AZ: 'AZ',
  BS: 'BS',
  BH: 'BH',
  BD: 'BD',
  BB: 'BB',
  BY: 'BY',
  BE: 'BE',
  BZ: 'BZ',
  BJ: 'BJ',
  BM: 'BM',
  BT: 'BT',
  BO: 'BO',
  BQ: 'BQ',
  BA: 'BA',
  BW: 'BW',
  BV: 'BV',
  BR: 'BR',
  IO: 'IO',
  BN: 'BN',
  BG: 'BG',
  BF: 'BF',
  BI: 'BI',
  CV: 'CV',
  KH: 'KH',
  CM: 'CM',
  CA: 'CA',
  KY: 'KY',
  CF: 'CF',
  TD: 'TD',
  CL: 'CL',
  CN: 'CN',
  CX: 'CX',
  CC: 'CC',
  CO: 'CO',
  KM: 'KM',
  CD: 'CD',
  CG: 'CG',
  CK: 'CK',
  CR: 'CR',
  HR: 'HR',
  CU: 'CU',
  CW: 'CW',
  CY: 'CY',
  CZ: 'CZ',
  CI: 'CI',
  DK: 'DK',
  DJ: 'DJ',
  DM: 'DM',
  DO: 'DO',
  EC: 'EC',
  EG: 'EG',
  SV: 'SV',
  GQ: 'GQ',
  ER: 'ER',
  EE: 'EE',
  SZ: 'SZ',
  ET: 'ET',
  FK: 'FK',
  FO: 'FO',
  FJ: 'FJ',
  FI: 'FI',
  FR: 'FR',
  GF: 'GF',
  PF: 'PF',
  TF: 'TF',
  GA: 'GA',
  GM: 'GM',
  GE: 'GE',
  DE: 'DE',
  GH: 'GH',
  GI: 'GI',
  GR: 'GR',
  GL: 'GL',
  GD: 'GD',
  GP: 'GP',
  GU: 'GU',
  GT: 'GT',
  GG: 'GG',
  GN: 'GN',
  GW: 'GW',
  GY: 'GY',
  HT: 'HT',
  HM: 'HM',
  VA: 'VA',
  HN: 'HN',
  HK: 'HK',
  HU: 'HU',
  IS: 'IS',
  IN: 'IN',
  ID: 'ID',
  IR: 'IR',
  IQ: 'IQ',
  IE: 'IE',
  IM: 'IM',
  IL: 'IL',
  IT: 'IT',
  JM: 'JM',
  JP: 'JP',
  JE: 'JE',
  JO: 'JO',
  KZ: 'KZ',
  KE: 'KE',
  KI: 'KI',
  KP: 'KP',
  KR: 'KR',
  KW: 'KW',
  KG: 'KG',
  LA: 'LA',
  LV: 'LV',
  LB: 'LB',
  LS: 'LS',
  LR: 'LR',
  LY: 'LY',
  LI: 'LI',
  LT: 'LT',
  LU: 'LU',
  MO: 'MO',
  MG: 'MG',
  MW: 'MW',
  MY: 'MY',
  MV: 'MV',
  ML: 'ML',
  MT: 'MT',
  MH: 'MH',
  MQ: 'MQ',
  MR: 'MR',
  MU: 'MU',
  YT: 'YT',
  MX: 'MX',
  FM: 'FM',
  MD: 'MD',
  MC: 'MC',
  MN: 'MN',
  ME: 'ME',
  MS: 'MS',
  MA: 'MA',
  MZ: 'MZ',
  MM: 'MM',
  NA: 'NA',
  NR: 'NR',
  NP: 'NP',
  NL: 'NL',
  NC: 'NC',
  NZ: 'NZ',
  NI: 'NI',
  NE: 'NE',
  NG: 'NG',
  NU: 'NU',
  NF: 'NF',
  MP: 'MP',
  NO: 'NO',
  OM: 'OM',
  PK: 'PK',
  PW: 'PW',
  PS: 'PS',
  PA: 'PA',
  PG: 'PG',
  PY: 'PY',
  PE: 'PE',
  PH: 'PH',
  PN: 'PN',
  PL: 'PL',
  PT: 'PT',
  PR: 'PR',
  QA: 'QA',
  MK: 'MK',
  RO: 'RO',
  RU: 'RU',
  RW: 'RW',
  RE: 'RE',
  BL: 'BL',
  SH: 'SH',
  KN: 'KN',
  LC: 'LC',
  MF: 'MF',
  PM: 'PM',
  VC: 'VC',
  WS: 'WS',
  SM: 'SM',
  ST: 'ST',
  SA: 'SA',
  SN: 'SN',
  RS: 'RS',
  SC: 'SC',
  SL: 'SL',
  SG: 'SG',
  SX: 'SX',
  SK: 'SK',
  SI: 'SI',
  SB: 'SB',
  SO: 'SO',
  ZA: 'ZA',
  GS: 'GS',
  SS: 'SS',
  ES: 'ES',
  LK: 'LK',
  SD: 'SD',
  SR: 'SR',
  SJ: 'SJ',
  SE: 'SE',
  CH: 'CH',
  SY: 'SY',
  TW: 'TW',
  TJ: 'TJ',
  TZ: 'TZ',
  TH: 'TH',
  TL: 'TL',
  TG: 'TG',
  TK: 'TK',
  TO: 'TO',
  TT: 'TT',
  TN: 'TN',
  TR: 'TR',
  TM: 'TM',
  TC: 'TC',
  TV: 'TV',
  UG: 'UG',
  UA: 'UA',
  AE: 'AE',
  GB: 'GB',
  UM: 'UM',
  US: 'US',
  UY: 'UY',
  UZ: 'UZ',
  VU: 'VU',
  VE: 'VE',
  VN: 'VN',
  VG: 'VG',
  VI: 'VI',
  WF: 'WF',
  EH: 'EH',
  YE: 'YE',
  ZM: 'ZM',
  ZW: 'ZW',
  AX: 'AX'
};

export type CountryCode = (typeof CountryCode)[keyof typeof CountryCode]


export const GenderEnum: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type GenderEnum = (typeof GenderEnum)[keyof typeof GenderEnum]


export const WalletRole: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  AGENT: 'AGENT'
};

export type WalletRole = (typeof WalletRole)[keyof typeof WalletRole]


export const BadgeType: {
  TRUSTED_BUYER: 'TRUSTED_BUYER',
  TRUSTED_SELLER: 'TRUSTED_SELLER',
  COMPANY_PICTURE: 'COMPANY_PICTURE',
  PERSONAL_REGISTRATION: 'PERSONAL_REGISTRATION',
  PERSONAL_SEVI_VERIFICATION_TEAM: 'PERSONAL_SEVI_VERIFICATION_TEAM',
  PERSONAL_EMAIL_VERIFIED: 'PERSONAL_EMAIL_VERIFIED',
  PERSONAL_TAX_ID: 'PERSONAL_TAX_ID',
  MEMBERSHIP_FIRST_MONTH: 'MEMBERSHIP_FIRST_MONTH',
  MEMBERSHIP_YEAR: 'MEMBERSHIP_YEAR',
  FIRST_ORDER: 'FIRST_ORDER',
  SHIPPING_LOCATION: 'SHIPPING_LOCATION',
  SETTLEMENT_KES_BANK: 'SETTLEMENT_KES_BANK',
  SETTLEMENT_KES_MPESA: 'SETTLEMENT_KES_MPESA',
  SELLERS_DOCUMENTS_UPLOADED: 'SELLERS_DOCUMENTS_UPLOADED',
  PERSONAL_SEVI_TEAM: 'PERSONAL_SEVI_TEAM',
  MPESA_STATEMENT: 'MPESA_STATEMENT',
  BANK_STATEMENT: 'BANK_STATEMENT',
  BUYER_SHARED_CONTACTS: 'BUYER_SHARED_CONTACTS'
};

export type BadgeType = (typeof BadgeType)[keyof typeof BadgeType]


export const WalletTypesEnum: {
  PERSONAL: 'PERSONAL',
  COMPANY: 'COMPANY',
  GROUP: 'GROUP',
  FUND: 'FUND'
};

export type WalletTypesEnum = (typeof WalletTypesEnum)[keyof typeof WalletTypesEnum]


export const CurrencyEnum: {
  KES: 'KES',
  UGX: 'UGX',
  AFN: 'AFN',
  EUR: 'EUR',
  ALL: 'ALL',
  DZD: 'DZD',
  USD: 'USD',
  AOA: 'AOA',
  XCD: 'XCD',
  ARS: 'ARS',
  AMD: 'AMD',
  AWG: 'AWG',
  AUD: 'AUD',
  AZN: 'AZN',
  BSD: 'BSD',
  BHD: 'BHD',
  BDT: 'BDT',
  BBD: 'BBD',
  BYN: 'BYN',
  BZD: 'BZD',
  XOF: 'XOF',
  BMD: 'BMD',
  INR: 'INR',
  BTN: 'BTN',
  BOB: 'BOB',
  BOV: 'BOV',
  BAM: 'BAM',
  BWP: 'BWP',
  NOK: 'NOK',
  BRL: 'BRL',
  BND: 'BND',
  BGN: 'BGN',
  BIF: 'BIF',
  CVE: 'CVE',
  KHR: 'KHR',
  XAF: 'XAF',
  CAD: 'CAD',
  KYD: 'KYD',
  CLP: 'CLP',
  CLF: 'CLF',
  CNY: 'CNY',
  COP: 'COP',
  COU: 'COU',
  KMF: 'KMF',
  CDF: 'CDF',
  NZD: 'NZD',
  CRC: 'CRC',
  HRK: 'HRK',
  CUP: 'CUP',
  CUC: 'CUC',
  ANG: 'ANG',
  CZK: 'CZK',
  DKK: 'DKK',
  DJF: 'DJF',
  DOP: 'DOP',
  EGP: 'EGP',
  SVC: 'SVC',
  ERN: 'ERN',
  SZL: 'SZL',
  ETB: 'ETB',
  FKP: 'FKP',
  FJD: 'FJD',
  XPF: 'XPF',
  GMD: 'GMD',
  GEL: 'GEL',
  GHS: 'GHS',
  GIP: 'GIP',
  GTQ: 'GTQ',
  GBP: 'GBP',
  GNF: 'GNF',
  GYD: 'GYD',
  HTG: 'HTG',
  HNL: 'HNL',
  HKD: 'HKD',
  HUF: 'HUF',
  ISK: 'ISK',
  IDR: 'IDR',
  XDR: 'XDR',
  IRR: 'IRR',
  IQD: 'IQD',
  ILS: 'ILS',
  JMD: 'JMD',
  JPY: 'JPY',
  JOD: 'JOD',
  KZT: 'KZT',
  KPW: 'KPW',
  KRW: 'KRW',
  KWD: 'KWD',
  KGS: 'KGS',
  LAK: 'LAK',
  LBP: 'LBP',
  LSL: 'LSL',
  ZAR: 'ZAR',
  LRD: 'LRD',
  LYD: 'LYD',
  CHF: 'CHF',
  MOP: 'MOP',
  MKD: 'MKD',
  MGA: 'MGA',
  MWK: 'MWK',
  MYR: 'MYR',
  MVR: 'MVR',
  MRU: 'MRU',
  MUR: 'MUR',
  XUA: 'XUA',
  MXN: 'MXN',
  MXV: 'MXV',
  MDL: 'MDL',
  MNT: 'MNT',
  MAD: 'MAD',
  MZN: 'MZN',
  MMK: 'MMK',
  NAD: 'NAD',
  NPR: 'NPR',
  NIO: 'NIO',
  NGN: 'NGN',
  OMR: 'OMR',
  PKR: 'PKR',
  PAB: 'PAB',
  PGK: 'PGK',
  PYG: 'PYG',
  PEN: 'PEN',
  PHP: 'PHP',
  PLN: 'PLN',
  QAR: 'QAR',
  RON: 'RON',
  RUB: 'RUB',
  RWF: 'RWF',
  SHP: 'SHP',
  WST: 'WST',
  STN: 'STN',
  SAR: 'SAR',
  RSD: 'RSD',
  SCR: 'SCR',
  SLL: 'SLL',
  SGD: 'SGD',
  XSU: 'XSU',
  SBD: 'SBD',
  SOS: 'SOS',
  SSP: 'SSP',
  LKR: 'LKR',
  SDG: 'SDG',
  SRD: 'SRD',
  SEK: 'SEK',
  CHE: 'CHE',
  CHW: 'CHW',
  SYP: 'SYP',
  TWD: 'TWD',
  TJS: 'TJS',
  TZS: 'TZS',
  THB: 'THB',
  TOP: 'TOP',
  TTD: 'TTD',
  TND: 'TND',
  TRY: 'TRY',
  TMT: 'TMT',
  UAH: 'UAH',
  AED: 'AED',
  USN: 'USN',
  UYU: 'UYU',
  UYI: 'UYI',
  UYW: 'UYW',
  UZS: 'UZS',
  VUV: 'VUV',
  VES: 'VES',
  VND: 'VND',
  YER: 'YER',
  ZMW: 'ZMW',
  ZWL: 'ZWL',
  XBA: 'XBA',
  XBB: 'XBB',
  XBC: 'XBC',
  XBD: 'XBD',
  XTS: 'XTS',
  XXX: 'XXX',
  XAU: 'XAU',
  XPD: 'XPD',
  XPT: 'XPT',
  XAG: 'XAG',
  AFA: 'AFA',
  FIM: 'FIM',
  ALK: 'ALK',
  ADP: 'ADP',
  ESP: 'ESP',
  FRF: 'FRF',
  AOK: 'AOK',
  AON: 'AON',
  AOR: 'AOR',
  ARA: 'ARA',
  ARP: 'ARP',
  ARY: 'ARY',
  RUR: 'RUR',
  ATS: 'ATS',
  AYM: 'AYM',
  AZM: 'AZM',
  BYB: 'BYB',
  BYR: 'BYR',
  BEC: 'BEC',
  BEF: 'BEF',
  BEL: 'BEL',
  BOP: 'BOP',
  BAD: 'BAD',
  BRB: 'BRB',
  BRC: 'BRC',
  BRE: 'BRE',
  BRN: 'BRN',
  BRR: 'BRR',
  BGJ: 'BGJ',
  BGK: 'BGK',
  BGL: 'BGL',
  BUK: 'BUK',
  HRD: 'HRD',
  CYP: 'CYP',
  CSJ: 'CSJ',
  CSK: 'CSK',
  ECS: 'ECS',
  ECV: 'ECV',
  GQE: 'GQE',
  EEK: 'EEK',
  XEU: 'XEU',
  GEK: 'GEK',
  DDM: 'DDM',
  DEM: 'DEM',
  GHC: 'GHC',
  GHP: 'GHP',
  GRD: 'GRD',
  GNE: 'GNE',
  GNS: 'GNS',
  GWE: 'GWE',
  GWP: 'GWP',
  ITL: 'ITL',
  ISJ: 'ISJ',
  IEP: 'IEP',
  ILP: 'ILP',
  ILR: 'ILR',
  LAJ: 'LAJ',
  LVL: 'LVL',
  LVR: 'LVR',
  LSM: 'LSM',
  ZAL: 'ZAL',
  LTL: 'LTL',
  LTT: 'LTT',
  LUC: 'LUC',
  LUF: 'LUF',
  LUL: 'LUL',
  MGF: 'MGF',
  MVQ: 'MVQ',
  MLF: 'MLF',
  MTL: 'MTL',
  MTP: 'MTP',
  MRO: 'MRO',
  MXP: 'MXP',
  MZE: 'MZE',
  MZM: 'MZM',
  NLG: 'NLG',
  NIC: 'NIC',
  PEH: 'PEH',
  PEI: 'PEI',
  PES: 'PES',
  PLZ: 'PLZ',
  PTE: 'PTE',
  ROK: 'ROK',
  ROL: 'ROL',
  STD: 'STD',
  CSD: 'CSD',
  SKK: 'SKK',
  SIT: 'SIT',
  RHD: 'RHD',
  ESA: 'ESA',
  ESB: 'ESB',
  SDD: 'SDD',
  SDP: 'SDP',
  SRG: 'SRG',
  CHC: 'CHC',
  TJR: 'TJR',
  TPE: 'TPE',
  TRL: 'TRL',
  TMM: 'TMM',
  UGS: 'UGS',
  UGW: 'UGW',
  UAK: 'UAK',
  SUR: 'SUR',
  USS: 'USS',
  UYN: 'UYN',
  UYP: 'UYP',
  VEB: 'VEB',
  VEF: 'VEF',
  VNC: 'VNC',
  YDD: 'YDD',
  YUD: 'YUD',
  YUM: 'YUM',
  YUN: 'YUN',
  ZRN: 'ZRN',
  ZRZ: 'ZRZ',
  ZMK: 'ZMK',
  ZWC: 'ZWC',
  ZWD: 'ZWD',
  ZWN: 'ZWN',
  ZWR: 'ZWR',
  XFO: 'XFO',
  XRE: 'XRE',
  XFU: 'XFU'
};

export type CurrencyEnum = (typeof CurrencyEnum)[keyof typeof CurrencyEnum]


export const phaseEnum: {
  NON: 'NON',
  REJECTED: 'REJECTED',
  WAITING_LIST: 'WAITING_LIST',
  GET_BADGES: 'GET_BADGES',
  DOCUMENT_CHECKS: 'DOCUMENT_CHECKS',
  LOCATION_VISIT: 'LOCATION_VISIT',
  LOCATION_VISIT_SCHEDULED: 'LOCATION_VISIT_SCHEDULED',
  DUE_DILIGENCE: 'DUE_DILIGENCE',
  MOVE_TO: 'MOVE_TO',
  ACCEPTED: 'ACCEPTED'
};

export type phaseEnum = (typeof phaseEnum)[keyof typeof phaseEnum]


export const partnerRoleEnum: {
  VERIFY: 'VERIFY',
  SALES: 'SALES',
  DEPT_COLLECTION: 'DEPT_COLLECTION',
  DEVELOPER: 'DEVELOPER',
  TEST: 'TEST',
  REMOVED: 'REMOVED',
  NON: 'NON'
};

export type partnerRoleEnum = (typeof partnerRoleEnum)[keyof typeof partnerRoleEnum]


export const legalStatusEnum: {
  SOLE: 'SOLE',
  LTD: 'LTD'
};

export type legalStatusEnum = (typeof legalStatusEnum)[keyof typeof legalStatusEnum]


export const PaymentTypesEnum: {
  CREDIT: 'CREDIT',
  ORDER: 'ORDER',
  WALLET: 'WALLET',
  MPESA_EXPRESS_PAYMENT: 'MPESA_EXPRESS_PAYMENT',
  MONEY_REQUEST: 'MONEY_REQUEST'
};

export type PaymentTypesEnum = (typeof PaymentTypesEnum)[keyof typeof PaymentTypesEnum]


export const TransactionTypeEnum: {
  TOP_UP: 'TOP_UP',
  DEDUCT: 'DEDUCT'
};

export type TransactionTypeEnum = (typeof TransactionTypeEnum)[keyof typeof TransactionTypeEnum]


export const TransactionMethodEnum: {
  SEVI: 'SEVI',
  MPESA_HOOK: 'MPESA_HOOK',
  CREDIT: 'CREDIT',
  MPESA: 'MPESA',
  LOAD: 'LOAD',
  BANK_KENYA: 'BANK_KENYA',
  BEYONIC_HOOK: 'BEYONIC_HOOK',
  KES_BANK: 'KES_BANK',
  KES_MPESA_PAYBILL: 'KES_MPESA_PAYBILL',
  KES_MPESA_PHONENUMBER: 'KES_MPESA_PHONENUMBER',
  UGX_BANK: 'UGX_BANK'
};

export type TransactionMethodEnum = (typeof TransactionMethodEnum)[keyof typeof TransactionMethodEnum]


export const EcommercePlatformEnum: {
  SEVI: 'SEVI',
  WOOCOMMERCE: 'WOOCOMMERCE',
  CUSTOM: 'CUSTOM'
};

export type EcommercePlatformEnum = (typeof EcommercePlatformEnum)[keyof typeof EcommercePlatformEnum]


export const OrderStatusEnum: {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  AWAITING_SHIPMENT: 'AWAITING_SHIPMENT',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  REFUNDED: 'REFUNDED',
  DISPUTED: 'DISPUTED',
  RETURNED: 'RETURNED',
  ARCHIVED: 'ARCHIVED'
};

export type OrderStatusEnum = (typeof OrderStatusEnum)[keyof typeof OrderStatusEnum]


export const PaymentStatusEnum: {
  PAID: 'PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  PENDING: 'PENDING',
  CREDIT_PROPOSAL_INITIATED: 'CREDIT_PROPOSAL_INITIATED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatusEnum = (typeof PaymentStatusEnum)[keyof typeof PaymentStatusEnum]


export const OrderPaymentMethodsEnum: {
  SEVI_WALLET: 'SEVI_WALLET',
  INSTALLMENTS: 'INSTALLMENTS',
  CASH_ON_DELIVERY: 'CASH_ON_DELIVERY',
  INSTALLMENTS_MPESA: 'INSTALLMENTS_MPESA'
};

export type OrderPaymentMethodsEnum = (typeof OrderPaymentMethodsEnum)[keyof typeof OrderPaymentMethodsEnum]


export const ShippingTypeEnum: {
  SEND: 'SEND',
  PICKUP: 'PICKUP'
};

export type ShippingTypeEnum = (typeof ShippingTypeEnum)[keyof typeof ShippingTypeEnum]


export const creditRefType: {
  IOU1: 'IOU1',
  SHOP_ORDER: 'SHOP_ORDER',
  P2P_LOAN1: 'P2P_LOAN1'
};

export type creditRefType = (typeof creditRefType)[keyof typeof creditRefType]


export const creditStatusEnum: {
  PENDING: 'PENDING',
  REQUESTED: 'REQUESTED',
  AGREED: 'AGREED',
  DEFAULTED: 'DEFAULTED',
  PAID: 'PAID',
  LATE: 'LATE',
  LATE_PAID: 'LATE_PAID',
  REFUNDED: 'REFUNDED',
  DEFAULTED_PAID: 'DEFAULTED_PAID'
};

export type creditStatusEnum = (typeof creditStatusEnum)[keyof typeof creditStatusEnum]


export const SlicesEnum: {
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  DAILY: 'DAILY'
};

export type SlicesEnum = (typeof SlicesEnum)[keyof typeof SlicesEnum]


export const installmentStatusTypeEnum: {
  PENDING: 'PENDING',
  LATE: 'LATE',
  PAID: 'PAID',
  DEFAULTED: 'DEFAULTED',
  LATE_PAID: 'LATE_PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID'
};

export type installmentStatusTypeEnum = (typeof installmentStatusTypeEnum)[keyof typeof installmentStatusTypeEnum]


export const ActivityEntityType: {
  PRODUCT_PAIRING: 'PRODUCT_PAIRING',
  ORDER: 'ORDER',
  CREDIT: 'CREDIT',
  INSTALLMENT: 'INSTALLMENT',
  UPLOADED_SELLER_DOCUMENTS: 'UPLOADED_SELLER_DOCUMENTS',
  GENERAL: 'GENERAL',
  TRANSACTION: 'TRANSACTION',
  BADGE: 'BADGE'
};

export type ActivityEntityType = (typeof ActivityEntityType)[keyof typeof ActivityEntityType]


export const ActivityPriority: {
  URGENT: 'URGENT',
  HIGH: 'HIGH',
  NORMAL: 'NORMAL',
  LOW: 'LOW'
};

export type ActivityPriority = (typeof ActivityPriority)[keyof typeof ActivityPriority]


export const language: {
  AF: 'AF',
  SQ: 'SQ',
  AR: 'AR',
  HY: 'HY',
  EU: 'EU',
  BN: 'BN',
  BG: 'BG',
  CA: 'CA',
  KM: 'KM',
  ZH: 'ZH',
  HR: 'HR',
  CS: 'CS',
  DA: 'DA',
  NL: 'NL',
  EN: 'EN',
  ET: 'ET',
  FJ: 'FJ',
  FI: 'FI',
  FR: 'FR',
  KA: 'KA',
  DE: 'DE',
  EL: 'EL',
  GU: 'GU',
  HE: 'HE',
  HI: 'HI',
  HU: 'HU',
  IS: 'IS',
  ID: 'ID',
  GA: 'GA',
  IT: 'IT',
  JA: 'JA',
  JW: 'JW',
  KO: 'KO',
  LA: 'LA',
  LV: 'LV',
  LT: 'LT',
  MK: 'MK',
  MS: 'MS',
  ML: 'ML',
  MT: 'MT',
  MI: 'MI',
  MR: 'MR',
  MN: 'MN',
  NE: 'NE',
  NO: 'NO',
  FA: 'FA',
  PL: 'PL',
  PT: 'PT',
  PA: 'PA',
  QU: 'QU',
  RO: 'RO',
  RU: 'RU',
  SM: 'SM',
  SR: 'SR',
  SK: 'SK',
  SL: 'SL',
  ES: 'ES',
  SW: 'SW',
  SV: 'SV',
  TA: 'TA',
  TT: 'TT',
  TE: 'TE',
  TH: 'TH',
  BO: 'BO',
  TO: 'TO',
  TR: 'TR',
  UK: 'UK',
  UR: 'UR',
  UZ: 'UZ',
  VI: 'VI',
  CY: 'CY',
  XH: 'XH'
};

export type language = (typeof language)[keyof typeof language]


export const JobStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const CreditConfigurationStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type CreditConfigurationStatus = (typeof CreditConfigurationStatus)[keyof typeof CreditConfigurationStatus]


export const answerTypeEnum: {
  boolean: 'boolean',
  string: 'string',
  scale7: 'scale7',
  scale5: 'scale5',
  number: 'number',
  range: 'range',
  selector: 'selector'
};

export type answerTypeEnum = (typeof answerTypeEnum)[keyof typeof answerTypeEnum]


export const QuestionCategoryEnum: {
  GENERAL: 'GENERAL',
  SWOT: 'SWOT',
  VERIFY: 'VERIFY',
  FINANCE: 'FINANCE',
  OWNER: 'OWNER',
  DOCUMENT: 'DOCUMENT',
  LOCATION_SELLER_VISIT: 'LOCATION_SELLER_VISIT',
  LOCATION_BUYER_VISIT: 'LOCATION_BUYER_VISIT'
};

export type QuestionCategoryEnum = (typeof QuestionCategoryEnum)[keyof typeof QuestionCategoryEnum]


export const CreditRequestStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  FAILED: 'FAILED'
};

export type CreditRequestStatus = (typeof CreditRequestStatus)[keyof typeof CreditRequestStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.usersWallets`: Exposes CRUD operations for the **UsersWallets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersWallets
    * const usersWallets = await prisma.usersWallets.findMany()
    * ```
    */
  get usersWallets(): Prisma.UsersWalletsDelegate<GlobalReject>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<GlobalReject>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<GlobalReject>;

  /**
   * `prisma.blacklist`: Exposes CRUD operations for the **Blacklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blacklists
    * const blacklists = await prisma.blacklist.findMany()
    * ```
    */
  get blacklist(): Prisma.BlacklistDelegate<GlobalReject>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<GlobalReject>;

  /**
   * `prisma.trust`: Exposes CRUD operations for the **Trust** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trusts
    * const trusts = await prisma.trust.findMany()
    * ```
    */
  get trust(): Prisma.TrustDelegate<GlobalReject>;

  /**
   * `prisma.metaData`: Exposes CRUD operations for the **MetaData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetaData
    * const metaData = await prisma.metaData.findMany()
    * ```
    */
  get metaData(): Prisma.MetaDataDelegate<GlobalReject>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.billing`: Exposes CRUD operations for the **Billing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billings
    * const billings = await prisma.billing.findMany()
    * ```
    */
  get billing(): Prisma.BillingDelegate<GlobalReject>;

  /**
   * `prisma.buyerContacts`: Exposes CRUD operations for the **BuyerContacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuyerContacts
    * const buyerContacts = await prisma.buyerContacts.findMany()
    * ```
    */
  get buyerContacts(): Prisma.BuyerContactsDelegate<GlobalReject>;

  /**
   * `prisma.shipping`: Exposes CRUD operations for the **Shipping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shippings
    * const shippings = await prisma.shipping.findMany()
    * ```
    */
  get shipping(): Prisma.ShippingDelegate<GlobalReject>;

  /**
   * `prisma.credit`: Exposes CRUD operations for the **Credit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credits
    * const credits = await prisma.credit.findMany()
    * ```
    */
  get credit(): Prisma.CreditDelegate<GlobalReject>;

  /**
   * `prisma.installment`: Exposes CRUD operations for the **Installment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Installments
    * const installments = await prisma.installment.findMany()
    * ```
    */
  get installment(): Prisma.InstallmentDelegate<GlobalReject>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<GlobalReject>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;

  /**
   * `prisma.verify`: Exposes CRUD operations for the **Verify** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifies
    * const verifies = await prisma.verify.findMany()
    * ```
    */
  get verify(): Prisma.VerifyDelegate<GlobalReject>;

  /**
   * `prisma.login`: Exposes CRUD operations for the **Login** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logins
    * const logins = await prisma.login.findMany()
    * ```
    */
  get login(): Prisma.LoginDelegate<GlobalReject>;

  /**
   * `prisma.visit`: Exposes CRUD operations for the **Visit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visits
    * const visits = await prisma.visit.findMany()
    * ```
    */
  get visit(): Prisma.VisitDelegate<GlobalReject>;

  /**
   * `prisma.referenceNumber`: Exposes CRUD operations for the **ReferenceNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferenceNumbers
    * const referenceNumbers = await prisma.referenceNumber.findMany()
    * ```
    */
  get referenceNumber(): Prisma.ReferenceNumberDelegate<GlobalReject>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<GlobalReject>;

  /**
   * `prisma.creditConfiguration`: Exposes CRUD operations for the **CreditConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditConfigurations
    * const creditConfigurations = await prisma.creditConfiguration.findMany()
    * ```
    */
  get creditConfiguration(): Prisma.CreditConfigurationDelegate<GlobalReject>;

  /**
   * `prisma.creditConfigurationsWallets`: Exposes CRUD operations for the **CreditConfigurationsWallets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditConfigurationsWallets
    * const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.findMany()
    * ```
    */
  get creditConfigurationsWallets(): Prisma.CreditConfigurationsWalletsDelegate<GlobalReject>;

  /**
   * `prisma.otherMemberKYC`: Exposes CRUD operations for the **OtherMemberKYC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtherMemberKYCS
    * const otherMemberKYCS = await prisma.otherMemberKYC.findMany()
    * ```
    */
  get otherMemberKYC(): Prisma.OtherMemberKYCDelegate<GlobalReject>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<GlobalReject>;

  /**
   * `prisma.settlement`: Exposes CRUD operations for the **Settlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settlements
    * const settlements = await prisma.settlement.findMany()
    * ```
    */
  get settlement(): Prisma.SettlementDelegate<GlobalReject>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<GlobalReject>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.AnswerDelegate<GlobalReject>;

  /**
   * `prisma.creditRequest`: Exposes CRUD operations for the **CreditRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditRequests
    * const creditRequests = await prisma.creditRequest.findMany()
    * ```
    */
  get creditRequest(): Prisma.CreditRequestDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.10.0
   * Query Engine version: 73e60b76d394f8d37d8ebd1f8918c79029f0db86
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    UsersWallets: 'UsersWallets',
    Customer: 'Customer',
    Supplier: 'Supplier',
    Badge: 'Badge',
    Blacklist: 'Blacklist',
    Wallet: 'Wallet',
    Trust: 'Trust',
    MetaData: 'MetaData',
    Transaction: 'Transaction',
    Product: 'Product',
    Order: 'Order',
    Billing: 'Billing',
    BuyerContacts: 'BuyerContacts',
    Shipping: 'Shipping',
    Credit: 'Credit',
    Installment: 'Installment',
    Activity: 'Activity',
    Message: 'Message',
    Verify: 'Verify',
    Login: 'Login',
    Visit: 'Visit',
    ReferenceNumber: 'ReferenceNumber',
    Job: 'Job',
    CreditConfiguration: 'CreditConfiguration',
    CreditConfigurationsWallets: 'CreditConfigurationsWallets',
    OtherMemberKYC: 'OtherMemberKYC',
    Settings: 'Settings',
    Settlement: 'Settlement',
    Question: 'Question',
    Answer: 'Answer',
    CreditRequest: 'CreditRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    activity: number
    answers: number
    creditsAffilate: number
    credits: number
    installment: number
    login: number
    ordersAffiliate: number
    orders: number
    otherMemberKYC: number
    product: number
    settlement: number
    usersWallets: number
    verify: number
    visit: number
    wallets: number
    Settlement: number
  }

  export type UserCountOutputTypeSelect = {
    activity?: boolean
    answers?: boolean
    creditsAffilate?: boolean
    credits?: boolean
    installment?: boolean
    login?: boolean
    ordersAffiliate?: boolean
    orders?: boolean
    otherMemberKYC?: boolean
    product?: boolean
    settlement?: boolean
    usersWallets?: boolean
    verify?: boolean
    visit?: boolean
    wallets?: boolean
    Settlement?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type WalletCountOutputType
   */


  export type WalletCountOutputType = {
    answers: number
    badges: number
    billing: number
    creditorCredit: number
    debtorCredit: number
    creditConfigurations: number
    customer: number
    vendor: number
    creditorInstallments: number
    debtorInstallments: number
    order: number
    orders: number
    product: number
    settlement: number
    shipping: number
    supplier: number
    vendorSupplier: number
    transaction: number
    usersWallets: number
    visit: number
    users: number
  }

  export type WalletCountOutputTypeSelect = {
    answers?: boolean
    badges?: boolean
    billing?: boolean
    creditorCredit?: boolean
    debtorCredit?: boolean
    creditConfigurations?: boolean
    customer?: boolean
    vendor?: boolean
    creditorInstallments?: boolean
    debtorInstallments?: boolean
    order?: boolean
    orders?: boolean
    product?: boolean
    settlement?: boolean
    shipping?: boolean
    supplier?: boolean
    vendorSupplier?: boolean
    transaction?: boolean
    usersWallets?: boolean
    visit?: boolean
    users?: boolean
  }

  export type WalletCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WalletCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WalletCountOutputType
    : S extends undefined
    ? never
    : S extends WalletCountOutputTypeArgs
    ?'include' extends U
    ? WalletCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WalletCountOutputType ? WalletCountOutputType[P] : never
  } 
    : WalletCountOutputType
  : WalletCountOutputType




  // Custom InputTypes

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     * 
    **/
    select?: WalletCountOutputTypeSelect | null
  }



  /**
   * Count Type OrderCountOutputType
   */


  export type OrderCountOutputType = {
    installments: number
  }

  export type OrderCountOutputTypeSelect = {
    installments?: boolean
  }

  export type OrderCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrderCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrderCountOutputType
    : S extends undefined
    ? never
    : S extends OrderCountOutputTypeArgs
    ?'include' extends U
    ? OrderCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrderCountOutputType ? OrderCountOutputType[P] : never
  } 
    : OrderCountOutputType
  : OrderCountOutputType




  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     * 
    **/
    select?: OrderCountOutputTypeSelect | null
  }



  /**
   * Count Type BillingCountOutputType
   */


  export type BillingCountOutputType = {
    order: number
  }

  export type BillingCountOutputTypeSelect = {
    order?: boolean
  }

  export type BillingCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BillingCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BillingCountOutputType
    : S extends undefined
    ? never
    : S extends BillingCountOutputTypeArgs
    ?'include' extends U
    ? BillingCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BillingCountOutputType ? BillingCountOutputType[P] : never
  } 
    : BillingCountOutputType
  : BillingCountOutputType




  // Custom InputTypes

  /**
   * BillingCountOutputType without action
   */
  export type BillingCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BillingCountOutputType
     * 
    **/
    select?: BillingCountOutputTypeSelect | null
  }



  /**
   * Count Type ShippingCountOutputType
   */


  export type ShippingCountOutputType = {
    Order: number
  }

  export type ShippingCountOutputTypeSelect = {
    Order?: boolean
  }

  export type ShippingCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ShippingCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ShippingCountOutputType
    : S extends undefined
    ? never
    : S extends ShippingCountOutputTypeArgs
    ?'include' extends U
    ? ShippingCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ShippingCountOutputType ? ShippingCountOutputType[P] : never
  } 
    : ShippingCountOutputType
  : ShippingCountOutputType




  // Custom InputTypes

  /**
   * ShippingCountOutputType without action
   */
  export type ShippingCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShippingCountOutputType
     * 
    **/
    select?: ShippingCountOutputTypeSelect | null
  }



  /**
   * Count Type CreditCountOutputType
   */


  export type CreditCountOutputType = {
    installments: number
  }

  export type CreditCountOutputTypeSelect = {
    installments?: boolean
  }

  export type CreditCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CreditCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CreditCountOutputType
    : S extends undefined
    ? never
    : S extends CreditCountOutputTypeArgs
    ?'include' extends U
    ? CreditCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CreditCountOutputType ? CreditCountOutputType[P] : never
  } 
    : CreditCountOutputType
  : CreditCountOutputType




  // Custom InputTypes

  /**
   * CreditCountOutputType without action
   */
  export type CreditCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CreditCountOutputType
     * 
    **/
    select?: CreditCountOutputTypeSelect | null
  }



  /**
   * Count Type CreditConfigurationCountOutputType
   */


  export type CreditConfigurationCountOutputType = {
    credit: number
    attachedWallets: number
    Installment: number
  }

  export type CreditConfigurationCountOutputTypeSelect = {
    credit?: boolean
    attachedWallets?: boolean
    Installment?: boolean
  }

  export type CreditConfigurationCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CreditConfigurationCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CreditConfigurationCountOutputType
    : S extends undefined
    ? never
    : S extends CreditConfigurationCountOutputTypeArgs
    ?'include' extends U
    ? CreditConfigurationCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CreditConfigurationCountOutputType ? CreditConfigurationCountOutputType[P] : never
  } 
    : CreditConfigurationCountOutputType
  : CreditConfigurationCountOutputType




  // Custom InputTypes

  /**
   * CreditConfigurationCountOutputType without action
   */
  export type CreditConfigurationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationCountOutputType
     * 
    **/
    select?: CreditConfigurationCountOutputTypeSelect | null
  }



  /**
   * Count Type SettlementCountOutputType
   */


  export type SettlementCountOutputType = {
    Wallet: number
  }

  export type SettlementCountOutputTypeSelect = {
    Wallet?: boolean
  }

  export type SettlementCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SettlementCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SettlementCountOutputType
    : S extends undefined
    ? never
    : S extends SettlementCountOutputTypeArgs
    ?'include' extends U
    ? SettlementCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SettlementCountOutputType ? SettlementCountOutputType[P] : never
  } 
    : SettlementCountOutputType
  : SettlementCountOutputType




  // Custom InputTypes

  /**
   * SettlementCountOutputType without action
   */
  export type SettlementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SettlementCountOutputType
     * 
    **/
    select?: SettlementCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionCountOutputType
   */


  export type QuestionCountOutputType = {
    answers: number
  }

  export type QuestionCountOutputTypeSelect = {
    answers?: boolean
  }

  export type QuestionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionCountOutputTypeArgs
    ?'include' extends U
    ? QuestionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionCountOutputType ? QuestionCountOutputType[P] : never
  } 
    : QuestionCountOutputType
  : QuestionCountOutputType




  // Custom InputTypes

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     * 
    **/
    select?: QuestionCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    userPhoto: string | null
    phoneNumber: string | null
    countryCode: CountryCode | null
    documentId: string | null
    url: string | null
    email: string | null
    pin: string | null
    deviceToken: string | null
    createdAt: Date | null
    verified: boolean | null
    expoPushToken: string | null
    inviterId: string | null
    faceIdImage: string | null
    documentCountry: CountryCode | null
    documentFirstName: string | null
    documentLastName: string | null
    documentImage: string | null
    documentGender: GenderEnum | null
    documentDateOfBirth: Date | null
    documentDateOfIssue: Date | null
    documentSerialNumber: string | null
    documentCreatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    userPhoto: string | null
    phoneNumber: string | null
    countryCode: CountryCode | null
    documentId: string | null
    url: string | null
    email: string | null
    pin: string | null
    deviceToken: string | null
    createdAt: Date | null
    verified: boolean | null
    expoPushToken: string | null
    inviterId: string | null
    faceIdImage: string | null
    documentCountry: CountryCode | null
    documentFirstName: string | null
    documentLastName: string | null
    documentImage: string | null
    documentGender: GenderEnum | null
    documentDateOfBirth: Date | null
    documentDateOfIssue: Date | null
    documentSerialNumber: string | null
    documentCreatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    userPhoto: number
    phoneNumber: number
    countryCode: number
    documentId: number
    url: number
    email: number
    pin: number
    deviceToken: number
    createdAt: number
    verified: number
    expoPushToken: number
    inviterId: number
    faceIdImage: number
    documentCountry: number
    documentData: number
    documentFirstName: number
    documentLastName: number
    documentImage: number
    documentGender: number
    documentDateOfBirth: number
    documentDateOfIssue: number
    documentSerialNumber: number
    documentCreatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    userPhoto?: true
    phoneNumber?: true
    countryCode?: true
    documentId?: true
    url?: true
    email?: true
    pin?: true
    deviceToken?: true
    createdAt?: true
    verified?: true
    expoPushToken?: true
    inviterId?: true
    faceIdImage?: true
    documentCountry?: true
    documentFirstName?: true
    documentLastName?: true
    documentImage?: true
    documentGender?: true
    documentDateOfBirth?: true
    documentDateOfIssue?: true
    documentSerialNumber?: true
    documentCreatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    userPhoto?: true
    phoneNumber?: true
    countryCode?: true
    documentId?: true
    url?: true
    email?: true
    pin?: true
    deviceToken?: true
    createdAt?: true
    verified?: true
    expoPushToken?: true
    inviterId?: true
    faceIdImage?: true
    documentCountry?: true
    documentFirstName?: true
    documentLastName?: true
    documentImage?: true
    documentGender?: true
    documentDateOfBirth?: true
    documentDateOfIssue?: true
    documentSerialNumber?: true
    documentCreatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    userPhoto?: true
    phoneNumber?: true
    countryCode?: true
    documentId?: true
    url?: true
    email?: true
    pin?: true
    deviceToken?: true
    createdAt?: true
    verified?: true
    expoPushToken?: true
    inviterId?: true
    faceIdImage?: true
    documentCountry?: true
    documentData?: true
    documentFirstName?: true
    documentLastName?: true
    documentImage?: true
    documentGender?: true
    documentDateOfBirth?: true
    documentDateOfIssue?: true
    documentSerialNumber?: true
    documentCreatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string | null
    userPhoto: string | null
    phoneNumber: string | null
    countryCode: CountryCode | null
    documentId: string | null
    url: string | null
    email: string | null
    pin: string | null
    deviceToken: string | null
    createdAt: Date
    verified: boolean
    expoPushToken: string | null
    inviterId: string | null
    faceIdImage: string | null
    documentCountry: CountryCode | null
    documentData: JsonValue | null
    documentFirstName: string | null
    documentLastName: string | null
    documentImage: string | null
    documentGender: GenderEnum | null
    documentDateOfBirth: Date | null
    documentDateOfIssue: Date | null
    documentSerialNumber: string | null
    documentCreatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    userPhoto?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    documentId?: boolean
    url?: boolean
    email?: boolean
    pin?: boolean
    deviceToken?: boolean
    createdAt?: boolean
    verified?: boolean
    expoPushToken?: boolean
    inviterId?: boolean
    faceIdImage?: boolean
    documentCountry?: boolean
    documentData?: boolean
    documentFirstName?: boolean
    documentLastName?: boolean
    documentImage?: boolean
    documentGender?: boolean
    documentDateOfBirth?: boolean
    documentDateOfIssue?: boolean
    documentSerialNumber?: boolean
    documentCreatedAt?: boolean
    activity?: boolean | ActivityFindManyArgs
    answers?: boolean | AnswerFindManyArgs
    creditsAffilate?: boolean | CreditFindManyArgs
    credits?: boolean | CreditFindManyArgs
    installment?: boolean | InstallmentFindManyArgs
    login?: boolean | LoginFindManyArgs
    ordersAffiliate?: boolean | OrderFindManyArgs
    orders?: boolean | OrderFindManyArgs
    otherMemberKYC?: boolean | OtherMemberKYCFindManyArgs
    product?: boolean | ProductFindManyArgs
    settlement?: boolean | SettlementFindManyArgs
    usersWallets?: boolean | UsersWalletsFindManyArgs
    verify?: boolean | VerifyFindManyArgs
    visit?: boolean | VisitFindManyArgs
    wallets?: boolean | WalletFindManyArgs
    Settlement?: boolean | SettlementFindManyArgs
    creditRequests?: boolean | CreditRequestArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    activity?: boolean | ActivityFindManyArgs
    answers?: boolean | AnswerFindManyArgs
    creditsAffilate?: boolean | CreditFindManyArgs
    credits?: boolean | CreditFindManyArgs
    installment?: boolean | InstallmentFindManyArgs
    login?: boolean | LoginFindManyArgs
    ordersAffiliate?: boolean | OrderFindManyArgs
    orders?: boolean | OrderFindManyArgs
    otherMemberKYC?: boolean | OtherMemberKYCFindManyArgs
    product?: boolean | ProductFindManyArgs
    settlement?: boolean | SettlementFindManyArgs
    usersWallets?: boolean | UsersWalletsFindManyArgs
    verify?: boolean | VerifyFindManyArgs
    visit?: boolean | VisitFindManyArgs
    wallets?: boolean | WalletFindManyArgs
    Settlement?: boolean | SettlementFindManyArgs
    creditRequests?: boolean | CreditRequestArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'activity' ? Array < ActivityGetPayload<S['include'][P]>>  :
        P extends 'answers' ? Array < AnswerGetPayload<S['include'][P]>>  :
        P extends 'creditsAffilate' ? Array < CreditGetPayload<S['include'][P]>>  :
        P extends 'credits' ? Array < CreditGetPayload<S['include'][P]>>  :
        P extends 'installment' ? Array < InstallmentGetPayload<S['include'][P]>>  :
        P extends 'login' ? Array < LoginGetPayload<S['include'][P]>>  :
        P extends 'ordersAffiliate' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'otherMemberKYC' ? Array < OtherMemberKYCGetPayload<S['include'][P]>>  :
        P extends 'product' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'settlement' ? Array < SettlementGetPayload<S['include'][P]>>  :
        P extends 'usersWallets' ? Array < UsersWalletsGetPayload<S['include'][P]>>  :
        P extends 'verify' ? Array < VerifyGetPayload<S['include'][P]>>  :
        P extends 'visit' ? Array < VisitGetPayload<S['include'][P]>>  :
        P extends 'wallets' ? Array < WalletGetPayload<S['include'][P]>>  :
        P extends 'Settlement' ? Array < SettlementGetPayload<S['include'][P]>>  :
        P extends 'creditRequests' ? CreditRequestGetPayload<S['include'][P]> | null :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'activity' ? Array < ActivityGetPayload<S['select'][P]>>  :
        P extends 'answers' ? Array < AnswerGetPayload<S['select'][P]>>  :
        P extends 'creditsAffilate' ? Array < CreditGetPayload<S['select'][P]>>  :
        P extends 'credits' ? Array < CreditGetPayload<S['select'][P]>>  :
        P extends 'installment' ? Array < InstallmentGetPayload<S['select'][P]>>  :
        P extends 'login' ? Array < LoginGetPayload<S['select'][P]>>  :
        P extends 'ordersAffiliate' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'otherMemberKYC' ? Array < OtherMemberKYCGetPayload<S['select'][P]>>  :
        P extends 'product' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'settlement' ? Array < SettlementGetPayload<S['select'][P]>>  :
        P extends 'usersWallets' ? Array < UsersWalletsGetPayload<S['select'][P]>>  :
        P extends 'verify' ? Array < VerifyGetPayload<S['select'][P]>>  :
        P extends 'visit' ? Array < VisitGetPayload<S['select'][P]>>  :
        P extends 'wallets' ? Array < WalletGetPayload<S['select'][P]>>  :
        P extends 'Settlement' ? Array < SettlementGetPayload<S['select'][P]>>  :
        P extends 'creditRequests' ? CreditRequestGetPayload<S['select'][P]> | null :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    activity<T extends ActivityFindManyArgs = {}>(args?: Subset<T, ActivityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Activity>>, PrismaPromise<Array<ActivityGetPayload<T>>>>;

    answers<T extends AnswerFindManyArgs = {}>(args?: Subset<T, AnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Answer>>, PrismaPromise<Array<AnswerGetPayload<T>>>>;

    creditsAffilate<T extends CreditFindManyArgs = {}>(args?: Subset<T, CreditFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Credit>>, PrismaPromise<Array<CreditGetPayload<T>>>>;

    credits<T extends CreditFindManyArgs = {}>(args?: Subset<T, CreditFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Credit>>, PrismaPromise<Array<CreditGetPayload<T>>>>;

    installment<T extends InstallmentFindManyArgs = {}>(args?: Subset<T, InstallmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Installment>>, PrismaPromise<Array<InstallmentGetPayload<T>>>>;

    login<T extends LoginFindManyArgs = {}>(args?: Subset<T, LoginFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Login>>, PrismaPromise<Array<LoginGetPayload<T>>>>;

    ordersAffiliate<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    otherMemberKYC<T extends OtherMemberKYCFindManyArgs = {}>(args?: Subset<T, OtherMemberKYCFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OtherMemberKYC>>, PrismaPromise<Array<OtherMemberKYCGetPayload<T>>>>;

    product<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    settlement<T extends SettlementFindManyArgs = {}>(args?: Subset<T, SettlementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Settlement>>, PrismaPromise<Array<SettlementGetPayload<T>>>>;

    usersWallets<T extends UsersWalletsFindManyArgs = {}>(args?: Subset<T, UsersWalletsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UsersWallets>>, PrismaPromise<Array<UsersWalletsGetPayload<T>>>>;

    verify<T extends VerifyFindManyArgs = {}>(args?: Subset<T, VerifyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Verify>>, PrismaPromise<Array<VerifyGetPayload<T>>>>;

    visit<T extends VisitFindManyArgs = {}>(args?: Subset<T, VisitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Visit>>, PrismaPromise<Array<VisitGetPayload<T>>>>;

    wallets<T extends WalletFindManyArgs = {}>(args?: Subset<T, WalletFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Wallet>>, PrismaPromise<Array<WalletGetPayload<T>>>>;

    Settlement<T extends SettlementFindManyArgs = {}>(args?: Subset<T, SettlementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Settlement>>, PrismaPromise<Array<SettlementGetPayload<T>>>>;

    creditRequests<T extends CreditRequestArgs = {}>(args?: Subset<T, CreditRequestArgs>): CheckSelect<T, Prisma__CreditRequestClient<CreditRequest | null >, Prisma__CreditRequestClient<CreditRequestGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model UsersWallets
   */


  export type AggregateUsersWallets = {
    _count: UsersWalletsCountAggregateOutputType | null
    _min: UsersWalletsMinAggregateOutputType | null
    _max: UsersWalletsMaxAggregateOutputType | null
  }

  export type UsersWalletsMinAggregateOutputType = {
    userId: string | null
    walletId: string | null
    role: WalletRole | null
  }

  export type UsersWalletsMaxAggregateOutputType = {
    userId: string | null
    walletId: string | null
    role: WalletRole | null
  }

  export type UsersWalletsCountAggregateOutputType = {
    userId: number
    walletId: number
    role: number
    _all: number
  }


  export type UsersWalletsMinAggregateInputType = {
    userId?: true
    walletId?: true
    role?: true
  }

  export type UsersWalletsMaxAggregateInputType = {
    userId?: true
    walletId?: true
    role?: true
  }

  export type UsersWalletsCountAggregateInputType = {
    userId?: true
    walletId?: true
    role?: true
    _all?: true
  }

  export type UsersWalletsAggregateArgs = {
    /**
     * Filter which UsersWallets to aggregate.
     * 
    **/
    where?: UsersWalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersWallets to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersWalletsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UsersWalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersWallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersWallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersWallets
    **/
    _count?: true | UsersWalletsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersWalletsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersWalletsMaxAggregateInputType
  }

  export type GetUsersWalletsAggregateType<T extends UsersWalletsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersWallets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersWallets[P]>
      : GetScalarType<T[P], AggregateUsersWallets[P]>
  }




  export type UsersWalletsGroupByArgs = {
    where?: UsersWalletsWhereInput
    orderBy?: Enumerable<UsersWalletsOrderByWithAggregationInput>
    by: Array<UsersWalletsScalarFieldEnum>
    having?: UsersWalletsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersWalletsCountAggregateInputType | true
    _min?: UsersWalletsMinAggregateInputType
    _max?: UsersWalletsMaxAggregateInputType
  }


  export type UsersWalletsGroupByOutputType = {
    userId: string
    walletId: string
    role: WalletRole
    _count: UsersWalletsCountAggregateOutputType | null
    _min: UsersWalletsMinAggregateOutputType | null
    _max: UsersWalletsMaxAggregateOutputType | null
  }

  type GetUsersWalletsGroupByPayload<T extends UsersWalletsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsersWalletsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersWalletsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersWalletsGroupByOutputType[P]>
            : GetScalarType<T[P], UsersWalletsGroupByOutputType[P]>
        }
      >
    >


  export type UsersWalletsSelect = {
    userId?: boolean
    walletId?: boolean
    role?: boolean
    user?: boolean | UserArgs
    wallet?: boolean | WalletArgs
  }

  export type UsersWalletsInclude = {
    user?: boolean | UserArgs
    wallet?: boolean | WalletArgs
  }

  export type UsersWalletsGetPayload<
    S extends boolean | null | undefined | UsersWalletsArgs,
    U = keyof S
      > = S extends true
        ? UsersWallets
    : S extends undefined
    ? never
    : S extends UsersWalletsArgs | UsersWalletsFindManyArgs
    ?'include' extends U
    ? UsersWallets  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :  P extends keyof UsersWallets ? UsersWallets[P] : never
  } 
    : UsersWallets
  : UsersWallets


  type UsersWalletsCountArgs = Merge<
    Omit<UsersWalletsFindManyArgs, 'select' | 'include'> & {
      select?: UsersWalletsCountAggregateInputType | true
    }
  >

  export interface UsersWalletsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UsersWallets that matches the filter.
     * @param {UsersWalletsFindUniqueArgs} args - Arguments to find a UsersWallets
     * @example
     * // Get one UsersWallets
     * const usersWallets = await prisma.usersWallets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersWalletsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsersWalletsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UsersWallets'> extends True ? CheckSelect<T, Prisma__UsersWalletsClient<UsersWallets>, Prisma__UsersWalletsClient<UsersWalletsGetPayload<T>>> : CheckSelect<T, Prisma__UsersWalletsClient<UsersWallets | null >, Prisma__UsersWalletsClient<UsersWalletsGetPayload<T> | null >>

    /**
     * Find the first UsersWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersWalletsFindFirstArgs} args - Arguments to find a UsersWallets
     * @example
     * // Get one UsersWallets
     * const usersWallets = await prisma.usersWallets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersWalletsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsersWalletsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UsersWallets'> extends True ? CheckSelect<T, Prisma__UsersWalletsClient<UsersWallets>, Prisma__UsersWalletsClient<UsersWalletsGetPayload<T>>> : CheckSelect<T, Prisma__UsersWalletsClient<UsersWallets | null >, Prisma__UsersWalletsClient<UsersWalletsGetPayload<T> | null >>

    /**
     * Find zero or more UsersWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersWalletsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersWallets
     * const usersWallets = await prisma.usersWallets.findMany()
     * 
     * // Get first 10 UsersWallets
     * const usersWallets = await prisma.usersWallets.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const usersWalletsWithUserIdOnly = await prisma.usersWallets.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UsersWalletsFindManyArgs>(
      args?: SelectSubset<T, UsersWalletsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UsersWallets>>, PrismaPromise<Array<UsersWalletsGetPayload<T>>>>

    /**
     * Create a UsersWallets.
     * @param {UsersWalletsCreateArgs} args - Arguments to create a UsersWallets.
     * @example
     * // Create one UsersWallets
     * const UsersWallets = await prisma.usersWallets.create({
     *   data: {
     *     // ... data to create a UsersWallets
     *   }
     * })
     * 
    **/
    create<T extends UsersWalletsCreateArgs>(
      args: SelectSubset<T, UsersWalletsCreateArgs>
    ): CheckSelect<T, Prisma__UsersWalletsClient<UsersWallets>, Prisma__UsersWalletsClient<UsersWalletsGetPayload<T>>>

    /**
     * Create many UsersWallets.
     *     @param {UsersWalletsCreateManyArgs} args - Arguments to create many UsersWallets.
     *     @example
     *     // Create many UsersWallets
     *     const usersWallets = await prisma.usersWallets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersWalletsCreateManyArgs>(
      args?: SelectSubset<T, UsersWalletsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UsersWallets.
     * @param {UsersWalletsDeleteArgs} args - Arguments to delete one UsersWallets.
     * @example
     * // Delete one UsersWallets
     * const UsersWallets = await prisma.usersWallets.delete({
     *   where: {
     *     // ... filter to delete one UsersWallets
     *   }
     * })
     * 
    **/
    delete<T extends UsersWalletsDeleteArgs>(
      args: SelectSubset<T, UsersWalletsDeleteArgs>
    ): CheckSelect<T, Prisma__UsersWalletsClient<UsersWallets>, Prisma__UsersWalletsClient<UsersWalletsGetPayload<T>>>

    /**
     * Update one UsersWallets.
     * @param {UsersWalletsUpdateArgs} args - Arguments to update one UsersWallets.
     * @example
     * // Update one UsersWallets
     * const usersWallets = await prisma.usersWallets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersWalletsUpdateArgs>(
      args: SelectSubset<T, UsersWalletsUpdateArgs>
    ): CheckSelect<T, Prisma__UsersWalletsClient<UsersWallets>, Prisma__UsersWalletsClient<UsersWalletsGetPayload<T>>>

    /**
     * Delete zero or more UsersWallets.
     * @param {UsersWalletsDeleteManyArgs} args - Arguments to filter UsersWallets to delete.
     * @example
     * // Delete a few UsersWallets
     * const { count } = await prisma.usersWallets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersWalletsDeleteManyArgs>(
      args?: SelectSubset<T, UsersWalletsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersWalletsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersWallets
     * const usersWallets = await prisma.usersWallets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersWalletsUpdateManyArgs>(
      args: SelectSubset<T, UsersWalletsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersWallets.
     * @param {UsersWalletsUpsertArgs} args - Arguments to update or create a UsersWallets.
     * @example
     * // Update or create a UsersWallets
     * const usersWallets = await prisma.usersWallets.upsert({
     *   create: {
     *     // ... data to create a UsersWallets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersWallets we want to update
     *   }
     * })
    **/
    upsert<T extends UsersWalletsUpsertArgs>(
      args: SelectSubset<T, UsersWalletsUpsertArgs>
    ): CheckSelect<T, Prisma__UsersWalletsClient<UsersWallets>, Prisma__UsersWalletsClient<UsersWalletsGetPayload<T>>>

    /**
     * Count the number of UsersWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersWalletsCountArgs} args - Arguments to filter UsersWallets to count.
     * @example
     * // Count the number of UsersWallets
     * const count = await prisma.usersWallets.count({
     *   where: {
     *     // ... the filter for the UsersWallets we want to count
     *   }
     * })
    **/
    count<T extends UsersWalletsCountArgs>(
      args?: Subset<T, UsersWalletsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersWalletsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersWalletsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersWalletsAggregateArgs>(args: Subset<T, UsersWalletsAggregateArgs>): PrismaPromise<GetUsersWalletsAggregateType<T>>

    /**
     * Group by UsersWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersWalletsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersWalletsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersWalletsGroupByArgs['orderBy'] }
        : { orderBy?: UsersWalletsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersWalletsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersWalletsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersWallets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsersWalletsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UsersWallets findUnique
   */
  export type UsersWalletsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UsersWallets
     * 
    **/
    select?: UsersWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersWalletsInclude | null
    /**
     * Throw an Error if a UsersWallets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UsersWallets to fetch.
     * 
    **/
    where: UsersWalletsWhereUniqueInput
  }


  /**
   * UsersWallets findFirst
   */
  export type UsersWalletsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UsersWallets
     * 
    **/
    select?: UsersWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersWalletsInclude | null
    /**
     * Throw an Error if a UsersWallets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UsersWallets to fetch.
     * 
    **/
    where?: UsersWalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersWallets to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersWalletsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersWallets.
     * 
    **/
    cursor?: UsersWalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersWallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersWallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersWallets.
     * 
    **/
    distinct?: Enumerable<UsersWalletsScalarFieldEnum>
  }


  /**
   * UsersWallets findMany
   */
  export type UsersWalletsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UsersWallets
     * 
    **/
    select?: UsersWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersWalletsInclude | null
    /**
     * Filter, which UsersWallets to fetch.
     * 
    **/
    where?: UsersWalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersWallets to fetch.
     * 
    **/
    orderBy?: Enumerable<UsersWalletsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersWallets.
     * 
    **/
    cursor?: UsersWalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersWallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersWallets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersWalletsScalarFieldEnum>
  }


  /**
   * UsersWallets create
   */
  export type UsersWalletsCreateArgs = {
    /**
     * Select specific fields to fetch from the UsersWallets
     * 
    **/
    select?: UsersWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersWalletsInclude | null
    /**
     * The data needed to create a UsersWallets.
     * 
    **/
    data: XOR<UsersWalletsCreateInput, UsersWalletsUncheckedCreateInput>
  }


  /**
   * UsersWallets createMany
   */
  export type UsersWalletsCreateManyArgs = {
    /**
     * The data used to create many UsersWallets.
     * 
    **/
    data: Enumerable<UsersWalletsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UsersWallets update
   */
  export type UsersWalletsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UsersWallets
     * 
    **/
    select?: UsersWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersWalletsInclude | null
    /**
     * The data needed to update a UsersWallets.
     * 
    **/
    data: XOR<UsersWalletsUpdateInput, UsersWalletsUncheckedUpdateInput>
    /**
     * Choose, which UsersWallets to update.
     * 
    **/
    where: UsersWalletsWhereUniqueInput
  }


  /**
   * UsersWallets updateMany
   */
  export type UsersWalletsUpdateManyArgs = {
    /**
     * The data used to update UsersWallets.
     * 
    **/
    data: XOR<UsersWalletsUpdateManyMutationInput, UsersWalletsUncheckedUpdateManyInput>
    /**
     * Filter which UsersWallets to update
     * 
    **/
    where?: UsersWalletsWhereInput
  }


  /**
   * UsersWallets upsert
   */
  export type UsersWalletsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UsersWallets
     * 
    **/
    select?: UsersWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersWalletsInclude | null
    /**
     * The filter to search for the UsersWallets to update in case it exists.
     * 
    **/
    where: UsersWalletsWhereUniqueInput
    /**
     * In case the UsersWallets found by the `where` argument doesn't exist, create a new UsersWallets with this data.
     * 
    **/
    create: XOR<UsersWalletsCreateInput, UsersWalletsUncheckedCreateInput>
    /**
     * In case the UsersWallets was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UsersWalletsUpdateInput, UsersWalletsUncheckedUpdateInput>
  }


  /**
   * UsersWallets delete
   */
  export type UsersWalletsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UsersWallets
     * 
    **/
    select?: UsersWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersWalletsInclude | null
    /**
     * Filter which UsersWallets to delete.
     * 
    **/
    where: UsersWalletsWhereUniqueInput
  }


  /**
   * UsersWallets deleteMany
   */
  export type UsersWalletsDeleteManyArgs = {
    /**
     * Filter which UsersWallets to delete
     * 
    **/
    where?: UsersWalletsWhereInput
  }


  /**
   * UsersWallets without action
   */
  export type UsersWalletsArgs = {
    /**
     * Select specific fields to fetch from the UsersWallets
     * 
    **/
    select?: UsersWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsersWalletsInclude | null
  }



  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    customerId: string | null
    vendorId: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    customerId: string | null
    vendorId: string | null
  }

  export type CustomerCountAggregateOutputType = {
    customerId: number
    vendorId: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    customerId?: true
    vendorId?: true
  }

  export type CustomerMaxAggregateInputType = {
    customerId?: true
    vendorId?: true
  }

  export type CustomerCountAggregateInputType = {
    customerId?: true
    vendorId?: true
    _all?: true
  }

  export type CustomerAggregateArgs = {
    /**
     * Filter which Customer to aggregate.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: Array<CustomerScalarFieldEnum>
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    customerId: string
    vendorId: string
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect = {
    customerId?: boolean
    vendorId?: boolean
    customer?: boolean | WalletArgs
    vendor?: boolean | WalletArgs
  }

  export type CustomerInclude = {
    customer?: boolean | WalletArgs
    vendor?: boolean | WalletArgs
  }

  export type CustomerGetPayload<
    S extends boolean | null | undefined | CustomerArgs,
    U = keyof S
      > = S extends true
        ? Customer
    : S extends undefined
    ? never
    : S extends CustomerArgs | CustomerFindManyArgs
    ?'include' extends U
    ? Customer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'customer' ? WalletGetPayload<S['include'][P]> :
        P extends 'vendor' ? WalletGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'customer' ? WalletGetPayload<S['select'][P]> :
        P extends 'vendor' ? WalletGetPayload<S['select'][P]> :  P extends keyof Customer ? Customer[P] : never
  } 
    : Customer
  : Customer


  type CustomerCountArgs = Merge<
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }
  >

  export interface CustomerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>> : CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>> : CheckSelect<T, Prisma__CustomerClient<Customer | null >, Prisma__CustomerClient<CustomerGetPayload<T> | null >>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `customerId`
     * const customerWithCustomerIdOnly = await prisma.customer.findMany({ select: { customerId: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Customer>>, PrismaPromise<Array<CustomerGetPayload<T>>>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerClient<Customer>, Prisma__CustomerClient<CustomerGetPayload<T>>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    vendor<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Throw an Error if a Customer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Throw an Error if a Customer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Customer to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     * 
    **/
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The data needed to create a Customer.
     * 
    **/
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs = {
    /**
     * The data used to create many Customers.
     * 
    **/
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The data needed to update a Customer.
     * 
    **/
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    /**
     * The data used to update Customers.
     * 
    **/
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     * 
    **/
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * The filter to search for the Customer to update in case it exists.
     * 
    **/
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     * 
    **/
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
    /**
     * Filter which Customer to delete.
     * 
    **/
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     * 
    **/
    where?: CustomerWhereInput
  }


  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     * 
    **/
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerInclude | null
  }



  /**
   * Model Supplier
   */


  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    supplierId: string | null
    vendorId: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    supplierId: string | null
    vendorId: string | null
  }

  export type SupplierCountAggregateOutputType = {
    supplierId: number
    vendorId: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    supplierId?: true
    vendorId?: true
  }

  export type SupplierMaxAggregateInputType = {
    supplierId?: true
    vendorId?: true
  }

  export type SupplierCountAggregateInputType = {
    supplierId?: true
    vendorId?: true
    _all?: true
  }

  export type SupplierAggregateArgs = {
    /**
     * Filter which Supplier to aggregate.
     * 
    **/
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<SupplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs = {
    where?: SupplierWhereInput
    orderBy?: Enumerable<SupplierOrderByWithAggregationInput>
    by: Array<SupplierScalarFieldEnum>
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }


  export type SupplierGroupByOutputType = {
    supplierId: string
    vendorId: string
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect = {
    supplierId?: boolean
    vendorId?: boolean
    supplier?: boolean | WalletArgs
    vendor?: boolean | WalletArgs
  }

  export type SupplierInclude = {
    supplier?: boolean | WalletArgs
    vendor?: boolean | WalletArgs
  }

  export type SupplierGetPayload<
    S extends boolean | null | undefined | SupplierArgs,
    U = keyof S
      > = S extends true
        ? Supplier
    : S extends undefined
    ? never
    : S extends SupplierArgs | SupplierFindManyArgs
    ?'include' extends U
    ? Supplier  & {
    [P in TrueKeys<S['include']>]:
        P extends 'supplier' ? WalletGetPayload<S['include'][P]> :
        P extends 'vendor' ? WalletGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'supplier' ? WalletGetPayload<S['select'][P]> :
        P extends 'vendor' ? WalletGetPayload<S['select'][P]> :  P extends keyof Supplier ? Supplier[P] : never
  } 
    : Supplier
  : Supplier


  type SupplierCountArgs = Merge<
    Omit<SupplierFindManyArgs, 'select' | 'include'> & {
      select?: SupplierCountAggregateInputType | true
    }
  >

  export interface SupplierDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SupplierFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Supplier'> extends True ? CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>> : CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SupplierFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Supplier'> extends True ? CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>> : CheckSelect<T, Prisma__SupplierClient<Supplier | null >, Prisma__SupplierClient<SupplierGetPayload<T> | null >>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `supplierId`
     * const supplierWithSupplierIdOnly = await prisma.supplier.findMany({ select: { supplierId: true } })
     * 
    **/
    findMany<T extends SupplierFindManyArgs>(
      args?: SelectSubset<T, SupplierFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Supplier>>, PrismaPromise<Array<SupplierGetPayload<T>>>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends SupplierCreateArgs>(
      args: SelectSubset<T, SupplierCreateArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Create many Suppliers.
     *     @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierCreateManyArgs>(
      args?: SelectSubset<T, SupplierCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends SupplierDeleteArgs>(
      args: SelectSubset<T, SupplierDeleteArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierUpdateArgs>(
      args: SelectSubset<T, SupplierUpdateArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierDeleteManyArgs>(
      args?: SelectSubset<T, SupplierDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierUpdateManyArgs>(
      args: SelectSubset<T, SupplierUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierUpsertArgs>(
      args: SelectSubset<T, SupplierUpsertArgs>
    ): CheckSelect<T, Prisma__SupplierClient<Supplier>, Prisma__SupplierClient<SupplierGetPayload<T>>>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SupplierClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    supplier<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    vendor<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * Throw an Error if a Supplier can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Supplier to fetch.
     * 
    **/
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * Throw an Error if a Supplier can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Supplier to fetch.
     * 
    **/
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<SupplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     * 
    **/
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     * 
    **/
    distinct?: Enumerable<SupplierScalarFieldEnum>
  }


  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * Filter, which Suppliers to fetch.
     * 
    **/
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     * 
    **/
    orderBy?: Enumerable<SupplierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     * 
    **/
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SupplierScalarFieldEnum>
  }


  /**
   * Supplier create
   */
  export type SupplierCreateArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * The data needed to create a Supplier.
     * 
    **/
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }


  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs = {
    /**
     * The data used to create many Suppliers.
     * 
    **/
    data: Enumerable<SupplierCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Supplier update
   */
  export type SupplierUpdateArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * The data needed to update a Supplier.
     * 
    **/
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     * 
    **/
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs = {
    /**
     * The data used to update Suppliers.
     * 
    **/
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     * 
    **/
    where?: SupplierWhereInput
  }


  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     * 
    **/
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     * 
    **/
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }


  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
    /**
     * Filter which Supplier to delete.
     * 
    **/
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs = {
    /**
     * Filter which Suppliers to delete
     * 
    **/
    where?: SupplierWhereInput
  }


  /**
   * Supplier without action
   */
  export type SupplierArgs = {
    /**
     * Select specific fields to fetch from the Supplier
     * 
    **/
    select?: SupplierSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SupplierInclude | null
  }



  /**
   * Model Badge
   */


  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    count: number | null
    level: number | null
  }

  export type BadgeSumAggregateOutputType = {
    count: number | null
    level: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    account: string | null
    active: boolean | null
    createdAt: Date | null
    type: BadgeType | null
    count: number | null
    level: number | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    account: string | null
    active: boolean | null
    createdAt: Date | null
    type: BadgeType | null
    count: number | null
    level: number | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    account: number
    active: number
    createdAt: number
    type: number
    count: number
    level: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    count?: true
    level?: true
  }

  export type BadgeSumAggregateInputType = {
    count?: true
    level?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    account?: true
    active?: true
    createdAt?: true
    type?: true
    count?: true
    level?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    account?: true
    active?: true
    createdAt?: true
    type?: true
    count?: true
    level?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    account?: true
    active?: true
    createdAt?: true
    type?: true
    count?: true
    level?: true
    _all?: true
  }

  export type BadgeAggregateArgs = {
    /**
     * Filter which Badge to aggregate.
     * 
    **/
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     * 
    **/
    orderBy?: Enumerable<BadgeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs = {
    where?: BadgeWhereInput
    orderBy?: Enumerable<BadgeOrderByWithAggregationInput>
    by: Array<BadgeScalarFieldEnum>
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }


  export type BadgeGroupByOutputType = {
    id: string
    account: string
    active: boolean | null
    createdAt: Date | null
    type: BadgeType | null
    count: number | null
    level: number | null
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect = {
    id?: boolean
    account?: boolean
    active?: boolean
    createdAt?: boolean
    type?: boolean
    count?: boolean
    level?: boolean
    wallet?: boolean | WalletArgs
  }

  export type BadgeInclude = {
    wallet?: boolean | WalletArgs
  }

  export type BadgeGetPayload<
    S extends boolean | null | undefined | BadgeArgs,
    U = keyof S
      > = S extends true
        ? Badge
    : S extends undefined
    ? never
    : S extends BadgeArgs | BadgeFindManyArgs
    ?'include' extends U
    ? Badge  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :  P extends keyof Badge ? Badge[P] : never
  } 
    : Badge
  : Badge


  type BadgeCountArgs = Merge<
    Omit<BadgeFindManyArgs, 'select' | 'include'> & {
      select?: BadgeCountAggregateInputType | true
    }
  >

  export interface BadgeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BadgeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BadgeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Badge'> extends True ? CheckSelect<T, Prisma__BadgeClient<Badge>, Prisma__BadgeClient<BadgeGetPayload<T>>> : CheckSelect<T, Prisma__BadgeClient<Badge | null >, Prisma__BadgeClient<BadgeGetPayload<T> | null >>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BadgeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BadgeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Badge'> extends True ? CheckSelect<T, Prisma__BadgeClient<Badge>, Prisma__BadgeClient<BadgeGetPayload<T>>> : CheckSelect<T, Prisma__BadgeClient<Badge | null >, Prisma__BadgeClient<BadgeGetPayload<T> | null >>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BadgeFindManyArgs>(
      args?: SelectSubset<T, BadgeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Badge>>, PrismaPromise<Array<BadgeGetPayload<T>>>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
    **/
    create<T extends BadgeCreateArgs>(
      args: SelectSubset<T, BadgeCreateArgs>
    ): CheckSelect<T, Prisma__BadgeClient<Badge>, Prisma__BadgeClient<BadgeGetPayload<T>>>

    /**
     * Create many Badges.
     *     @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     *     @example
     *     // Create many Badges
     *     const badge = await prisma.badge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BadgeCreateManyArgs>(
      args?: SelectSubset<T, BadgeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
    **/
    delete<T extends BadgeDeleteArgs>(
      args: SelectSubset<T, BadgeDeleteArgs>
    ): CheckSelect<T, Prisma__BadgeClient<Badge>, Prisma__BadgeClient<BadgeGetPayload<T>>>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BadgeUpdateArgs>(
      args: SelectSubset<T, BadgeUpdateArgs>
    ): CheckSelect<T, Prisma__BadgeClient<Badge>, Prisma__BadgeClient<BadgeGetPayload<T>>>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BadgeDeleteManyArgs>(
      args?: SelectSubset<T, BadgeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BadgeUpdateManyArgs>(
      args: SelectSubset<T, BadgeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
    **/
    upsert<T extends BadgeUpsertArgs>(
      args: SelectSubset<T, BadgeUpsertArgs>
    ): CheckSelect<T, Prisma__BadgeClient<Badge>, Prisma__BadgeClient<BadgeGetPayload<T>>>

    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BadgeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Badge
     * 
    **/
    select?: BadgeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BadgeInclude | null
    /**
     * Throw an Error if a Badge can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Badge to fetch.
     * 
    **/
    where: BadgeWhereUniqueInput
  }


  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Badge
     * 
    **/
    select?: BadgeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BadgeInclude | null
    /**
     * Throw an Error if a Badge can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Badge to fetch.
     * 
    **/
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     * 
    **/
    orderBy?: Enumerable<BadgeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     * 
    **/
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     * 
    **/
    distinct?: Enumerable<BadgeScalarFieldEnum>
  }


  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Badge
     * 
    **/
    select?: BadgeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BadgeInclude | null
    /**
     * Filter, which Badges to fetch.
     * 
    **/
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     * 
    **/
    orderBy?: Enumerable<BadgeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     * 
    **/
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BadgeScalarFieldEnum>
  }


  /**
   * Badge create
   */
  export type BadgeCreateArgs = {
    /**
     * Select specific fields to fetch from the Badge
     * 
    **/
    select?: BadgeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BadgeInclude | null
    /**
     * The data needed to create a Badge.
     * 
    **/
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }


  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs = {
    /**
     * The data used to create many Badges.
     * 
    **/
    data: Enumerable<BadgeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Badge update
   */
  export type BadgeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Badge
     * 
    **/
    select?: BadgeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BadgeInclude | null
    /**
     * The data needed to update a Badge.
     * 
    **/
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     * 
    **/
    where: BadgeWhereUniqueInput
  }


  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs = {
    /**
     * The data used to update Badges.
     * 
    **/
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     * 
    **/
    where?: BadgeWhereInput
  }


  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Badge
     * 
    **/
    select?: BadgeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BadgeInclude | null
    /**
     * The filter to search for the Badge to update in case it exists.
     * 
    **/
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     * 
    **/
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }


  /**
   * Badge delete
   */
  export type BadgeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Badge
     * 
    **/
    select?: BadgeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BadgeInclude | null
    /**
     * Filter which Badge to delete.
     * 
    **/
    where: BadgeWhereUniqueInput
  }


  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs = {
    /**
     * Filter which Badges to delete
     * 
    **/
    where?: BadgeWhereInput
  }


  /**
   * Badge without action
   */
  export type BadgeArgs = {
    /**
     * Select specific fields to fetch from the Badge
     * 
    **/
    select?: BadgeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BadgeInclude | null
  }



  /**
   * Model Blacklist
   */


  export type AggregateBlacklist = {
    _count: BlacklistCountAggregateOutputType | null
    _min: BlacklistMinAggregateOutputType | null
    _max: BlacklistMaxAggregateOutputType | null
  }

  export type BlacklistMinAggregateOutputType = {
    id: string | null
    taxId: string | null
    documentId: string | null
    phoneNumber: string | null
    createdAt: Date | null
  }

  export type BlacklistMaxAggregateOutputType = {
    id: string | null
    taxId: string | null
    documentId: string | null
    phoneNumber: string | null
    createdAt: Date | null
  }

  export type BlacklistCountAggregateOutputType = {
    id: number
    taxId: number
    documentId: number
    phoneNumber: number
    createdAt: number
    _all: number
  }


  export type BlacklistMinAggregateInputType = {
    id?: true
    taxId?: true
    documentId?: true
    phoneNumber?: true
    createdAt?: true
  }

  export type BlacklistMaxAggregateInputType = {
    id?: true
    taxId?: true
    documentId?: true
    phoneNumber?: true
    createdAt?: true
  }

  export type BlacklistCountAggregateInputType = {
    id?: true
    taxId?: true
    documentId?: true
    phoneNumber?: true
    createdAt?: true
    _all?: true
  }

  export type BlacklistAggregateArgs = {
    /**
     * Filter which Blacklist to aggregate.
     * 
    **/
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     * 
    **/
    orderBy?: Enumerable<BlacklistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blacklists
    **/
    _count?: true | BlacklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlacklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlacklistMaxAggregateInputType
  }

  export type GetBlacklistAggregateType<T extends BlacklistAggregateArgs> = {
        [P in keyof T & keyof AggregateBlacklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklist[P]>
      : GetScalarType<T[P], AggregateBlacklist[P]>
  }




  export type BlacklistGroupByArgs = {
    where?: BlacklistWhereInput
    orderBy?: Enumerable<BlacklistOrderByWithAggregationInput>
    by: Array<BlacklistScalarFieldEnum>
    having?: BlacklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlacklistCountAggregateInputType | true
    _min?: BlacklistMinAggregateInputType
    _max?: BlacklistMaxAggregateInputType
  }


  export type BlacklistGroupByOutputType = {
    id: string
    taxId: string | null
    documentId: string | null
    phoneNumber: string | null
    createdAt: Date | null
    _count: BlacklistCountAggregateOutputType | null
    _min: BlacklistMinAggregateOutputType | null
    _max: BlacklistMaxAggregateOutputType | null
  }

  type GetBlacklistGroupByPayload<T extends BlacklistGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BlacklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlacklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlacklistGroupByOutputType[P]>
            : GetScalarType<T[P], BlacklistGroupByOutputType[P]>
        }
      >
    >


  export type BlacklistSelect = {
    id?: boolean
    taxId?: boolean
    documentId?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
  }

  export type BlacklistGetPayload<
    S extends boolean | null | undefined | BlacklistArgs,
    U = keyof S
      > = S extends true
        ? Blacklist
    : S extends undefined
    ? never
    : S extends BlacklistArgs | BlacklistFindManyArgs
    ?'include' extends U
    ? Blacklist 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Blacklist ? Blacklist[P] : never
  } 
    : Blacklist
  : Blacklist


  type BlacklistCountArgs = Merge<
    Omit<BlacklistFindManyArgs, 'select' | 'include'> & {
      select?: BlacklistCountAggregateInputType | true
    }
  >

  export interface BlacklistDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Blacklist that matches the filter.
     * @param {BlacklistFindUniqueArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlacklistFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BlacklistFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Blacklist'> extends True ? CheckSelect<T, Prisma__BlacklistClient<Blacklist>, Prisma__BlacklistClient<BlacklistGetPayload<T>>> : CheckSelect<T, Prisma__BlacklistClient<Blacklist | null >, Prisma__BlacklistClient<BlacklistGetPayload<T> | null >>

    /**
     * Find the first Blacklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistFindFirstArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlacklistFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BlacklistFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Blacklist'> extends True ? CheckSelect<T, Prisma__BlacklistClient<Blacklist>, Prisma__BlacklistClient<BlacklistGetPayload<T>>> : CheckSelect<T, Prisma__BlacklistClient<Blacklist | null >, Prisma__BlacklistClient<BlacklistGetPayload<T> | null >>

    /**
     * Find zero or more Blacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blacklists
     * const blacklists = await prisma.blacklist.findMany()
     * 
     * // Get first 10 Blacklists
     * const blacklists = await prisma.blacklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blacklistWithIdOnly = await prisma.blacklist.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlacklistFindManyArgs>(
      args?: SelectSubset<T, BlacklistFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Blacklist>>, PrismaPromise<Array<BlacklistGetPayload<T>>>>

    /**
     * Create a Blacklist.
     * @param {BlacklistCreateArgs} args - Arguments to create a Blacklist.
     * @example
     * // Create one Blacklist
     * const Blacklist = await prisma.blacklist.create({
     *   data: {
     *     // ... data to create a Blacklist
     *   }
     * })
     * 
    **/
    create<T extends BlacklistCreateArgs>(
      args: SelectSubset<T, BlacklistCreateArgs>
    ): CheckSelect<T, Prisma__BlacklistClient<Blacklist>, Prisma__BlacklistClient<BlacklistGetPayload<T>>>

    /**
     * Create many Blacklists.
     *     @param {BlacklistCreateManyArgs} args - Arguments to create many Blacklists.
     *     @example
     *     // Create many Blacklists
     *     const blacklist = await prisma.blacklist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlacklistCreateManyArgs>(
      args?: SelectSubset<T, BlacklistCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Blacklist.
     * @param {BlacklistDeleteArgs} args - Arguments to delete one Blacklist.
     * @example
     * // Delete one Blacklist
     * const Blacklist = await prisma.blacklist.delete({
     *   where: {
     *     // ... filter to delete one Blacklist
     *   }
     * })
     * 
    **/
    delete<T extends BlacklistDeleteArgs>(
      args: SelectSubset<T, BlacklistDeleteArgs>
    ): CheckSelect<T, Prisma__BlacklistClient<Blacklist>, Prisma__BlacklistClient<BlacklistGetPayload<T>>>

    /**
     * Update one Blacklist.
     * @param {BlacklistUpdateArgs} args - Arguments to update one Blacklist.
     * @example
     * // Update one Blacklist
     * const blacklist = await prisma.blacklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlacklistUpdateArgs>(
      args: SelectSubset<T, BlacklistUpdateArgs>
    ): CheckSelect<T, Prisma__BlacklistClient<Blacklist>, Prisma__BlacklistClient<BlacklistGetPayload<T>>>

    /**
     * Delete zero or more Blacklists.
     * @param {BlacklistDeleteManyArgs} args - Arguments to filter Blacklists to delete.
     * @example
     * // Delete a few Blacklists
     * const { count } = await prisma.blacklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlacklistDeleteManyArgs>(
      args?: SelectSubset<T, BlacklistDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blacklists
     * const blacklist = await prisma.blacklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlacklistUpdateManyArgs>(
      args: SelectSubset<T, BlacklistUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Blacklist.
     * @param {BlacklistUpsertArgs} args - Arguments to update or create a Blacklist.
     * @example
     * // Update or create a Blacklist
     * const blacklist = await prisma.blacklist.upsert({
     *   create: {
     *     // ... data to create a Blacklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blacklist we want to update
     *   }
     * })
    **/
    upsert<T extends BlacklistUpsertArgs>(
      args: SelectSubset<T, BlacklistUpsertArgs>
    ): CheckSelect<T, Prisma__BlacklistClient<Blacklist>, Prisma__BlacklistClient<BlacklistGetPayload<T>>>

    /**
     * Count the number of Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistCountArgs} args - Arguments to filter Blacklists to count.
     * @example
     * // Count the number of Blacklists
     * const count = await prisma.blacklist.count({
     *   where: {
     *     // ... the filter for the Blacklists we want to count
     *   }
     * })
    **/
    count<T extends BlacklistCountArgs>(
      args?: Subset<T, BlacklistCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlacklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlacklistAggregateArgs>(args: Subset<T, BlacklistAggregateArgs>): PrismaPromise<GetBlacklistAggregateType<T>>

    /**
     * Group by Blacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlacklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlacklistGroupByArgs['orderBy'] }
        : { orderBy?: BlacklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlacklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlacklistGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blacklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BlacklistClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Blacklist findUnique
   */
  export type BlacklistFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Blacklist
     * 
    **/
    select?: BlacklistSelect | null
    /**
     * Throw an Error if a Blacklist can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Blacklist to fetch.
     * 
    **/
    where: BlacklistWhereUniqueInput
  }


  /**
   * Blacklist findFirst
   */
  export type BlacklistFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Blacklist
     * 
    **/
    select?: BlacklistSelect | null
    /**
     * Throw an Error if a Blacklist can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Blacklist to fetch.
     * 
    **/
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     * 
    **/
    orderBy?: Enumerable<BlacklistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blacklists.
     * 
    **/
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blacklists.
     * 
    **/
    distinct?: Enumerable<BlacklistScalarFieldEnum>
  }


  /**
   * Blacklist findMany
   */
  export type BlacklistFindManyArgs = {
    /**
     * Select specific fields to fetch from the Blacklist
     * 
    **/
    select?: BlacklistSelect | null
    /**
     * Filter, which Blacklists to fetch.
     * 
    **/
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     * 
    **/
    orderBy?: Enumerable<BlacklistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blacklists.
     * 
    **/
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BlacklistScalarFieldEnum>
  }


  /**
   * Blacklist create
   */
  export type BlacklistCreateArgs = {
    /**
     * Select specific fields to fetch from the Blacklist
     * 
    **/
    select?: BlacklistSelect | null
    /**
     * The data needed to create a Blacklist.
     * 
    **/
    data: XOR<BlacklistCreateInput, BlacklistUncheckedCreateInput>
  }


  /**
   * Blacklist createMany
   */
  export type BlacklistCreateManyArgs = {
    /**
     * The data used to create many Blacklists.
     * 
    **/
    data: Enumerable<BlacklistCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Blacklist update
   */
  export type BlacklistUpdateArgs = {
    /**
     * Select specific fields to fetch from the Blacklist
     * 
    **/
    select?: BlacklistSelect | null
    /**
     * The data needed to update a Blacklist.
     * 
    **/
    data: XOR<BlacklistUpdateInput, BlacklistUncheckedUpdateInput>
    /**
     * Choose, which Blacklist to update.
     * 
    **/
    where: BlacklistWhereUniqueInput
  }


  /**
   * Blacklist updateMany
   */
  export type BlacklistUpdateManyArgs = {
    /**
     * The data used to update Blacklists.
     * 
    **/
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyInput>
    /**
     * Filter which Blacklists to update
     * 
    **/
    where?: BlacklistWhereInput
  }


  /**
   * Blacklist upsert
   */
  export type BlacklistUpsertArgs = {
    /**
     * Select specific fields to fetch from the Blacklist
     * 
    **/
    select?: BlacklistSelect | null
    /**
     * The filter to search for the Blacklist to update in case it exists.
     * 
    **/
    where: BlacklistWhereUniqueInput
    /**
     * In case the Blacklist found by the `where` argument doesn't exist, create a new Blacklist with this data.
     * 
    **/
    create: XOR<BlacklistCreateInput, BlacklistUncheckedCreateInput>
    /**
     * In case the Blacklist was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BlacklistUpdateInput, BlacklistUncheckedUpdateInput>
  }


  /**
   * Blacklist delete
   */
  export type BlacklistDeleteArgs = {
    /**
     * Select specific fields to fetch from the Blacklist
     * 
    **/
    select?: BlacklistSelect | null
    /**
     * Filter which Blacklist to delete.
     * 
    **/
    where: BlacklistWhereUniqueInput
  }


  /**
   * Blacklist deleteMany
   */
  export type BlacklistDeleteManyArgs = {
    /**
     * Filter which Blacklists to delete
     * 
    **/
    where?: BlacklistWhereInput
  }


  /**
   * Blacklist without action
   */
  export type BlacklistArgs = {
    /**
     * Select specific fields to fetch from the Blacklist
     * 
    **/
    select?: BlacklistSelect | null
  }



  /**
   * Model Wallet
   */


  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: number | null
  }

  export type WalletSumAggregateOutputType = {
    balance: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    type: WalletTypesEnum | null
    balance: number | null
    account: string | null
    createdAt: Date | null
    currency: CurrencyEnum | null
    settlementAutomatic: boolean | null
    settlementDefaultId: string | null
    verificationStartedAt: Date | null
    shippingId: string | null
    picture: string | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    type: WalletTypesEnum | null
    balance: number | null
    account: string | null
    createdAt: Date | null
    currency: CurrencyEnum | null
    settlementAutomatic: boolean | null
    settlementDefaultId: string | null
    verificationStartedAt: Date | null
    shippingId: string | null
    picture: string | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    name: number
    category: number
    type: number
    balance: number
    account: number
    createdAt: number
    currency: number
    settlementAutomatic: number
    settlementDefaultId: number
    verificationStartedAt: number
    shippingId: number
    picture: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    type?: true
    balance?: true
    account?: true
    createdAt?: true
    currency?: true
    settlementAutomatic?: true
    settlementDefaultId?: true
    verificationStartedAt?: true
    shippingId?: true
    picture?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    type?: true
    balance?: true
    account?: true
    createdAt?: true
    currency?: true
    settlementAutomatic?: true
    settlementDefaultId?: true
    verificationStartedAt?: true
    shippingId?: true
    picture?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    type?: true
    balance?: true
    account?: true
    createdAt?: true
    currency?: true
    settlementAutomatic?: true
    settlementDefaultId?: true
    verificationStartedAt?: true
    shippingId?: true
    picture?: true
    _all?: true
  }

  export type WalletAggregateArgs = {
    /**
     * Filter which Wallet to aggregate.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs = {
    where?: WalletWhereInput
    orderBy?: Enumerable<WalletOrderByWithAggregationInput>
    by: Array<WalletScalarFieldEnum>
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }


  export type WalletGroupByOutputType = {
    id: string
    name: string | null
    category: string | null
    type: WalletTypesEnum
    balance: number
    account: string
    createdAt: Date
    currency: CurrencyEnum | null
    settlementAutomatic: boolean | null
    settlementDefaultId: string | null
    verificationStartedAt: Date | null
    shippingId: string | null
    picture: string | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect = {
    id?: boolean
    name?: boolean
    category?: boolean
    type?: boolean
    balance?: boolean
    account?: boolean
    createdAt?: boolean
    currency?: boolean
    settlementAutomatic?: boolean
    settlementDefaultId?: boolean
    verificationStartedAt?: boolean
    shippingId?: boolean
    picture?: boolean
    settlementDefault?: boolean | SettlementArgs
    answers?: boolean | AnswerFindManyArgs
    badges?: boolean | BadgeFindManyArgs
    billing?: boolean | BillingFindManyArgs
    creditorCredit?: boolean | CreditFindManyArgs
    debtorCredit?: boolean | CreditFindManyArgs
    creditConfigurations?: boolean | CreditConfigurationFindManyArgs
    customer?: boolean | CustomerFindManyArgs
    vendor?: boolean | CustomerFindManyArgs
    creditorInstallments?: boolean | InstallmentFindManyArgs
    debtorInstallments?: boolean | InstallmentFindManyArgs
    metaData?: boolean | MetaDataArgs
    order?: boolean | OrderFindManyArgs
    orders?: boolean | OrderFindManyArgs
    product?: boolean | ProductFindManyArgs
    settings?: boolean | SettingsArgs
    settlement?: boolean | SettlementFindManyArgs
    shipping?: boolean | ShippingFindManyArgs
    supplier?: boolean | SupplierFindManyArgs
    vendorSupplier?: boolean | SupplierFindManyArgs
    transaction?: boolean | TransactionFindManyArgs
    usersWallets?: boolean | UsersWalletsFindManyArgs
    visit?: boolean | VisitFindManyArgs
    users?: boolean | UserFindManyArgs
    trust?: boolean | TrustArgs
    _count?: boolean | WalletCountOutputTypeArgs
  }

  export type WalletInclude = {
    settlementDefault?: boolean | SettlementArgs
    answers?: boolean | AnswerFindManyArgs
    badges?: boolean | BadgeFindManyArgs
    billing?: boolean | BillingFindManyArgs
    creditorCredit?: boolean | CreditFindManyArgs
    debtorCredit?: boolean | CreditFindManyArgs
    creditConfigurations?: boolean | CreditConfigurationFindManyArgs
    customer?: boolean | CustomerFindManyArgs
    vendor?: boolean | CustomerFindManyArgs
    creditorInstallments?: boolean | InstallmentFindManyArgs
    debtorInstallments?: boolean | InstallmentFindManyArgs
    metaData?: boolean | MetaDataArgs
    order?: boolean | OrderFindManyArgs
    orders?: boolean | OrderFindManyArgs
    product?: boolean | ProductFindManyArgs
    settings?: boolean | SettingsArgs
    settlement?: boolean | SettlementFindManyArgs
    shipping?: boolean | ShippingFindManyArgs
    supplier?: boolean | SupplierFindManyArgs
    vendorSupplier?: boolean | SupplierFindManyArgs
    transaction?: boolean | TransactionFindManyArgs
    usersWallets?: boolean | UsersWalletsFindManyArgs
    visit?: boolean | VisitFindManyArgs
    users?: boolean | UserFindManyArgs
    trust?: boolean | TrustArgs
    _count?: boolean | WalletCountOutputTypeArgs
  }

  export type WalletGetPayload<
    S extends boolean | null | undefined | WalletArgs,
    U = keyof S
      > = S extends true
        ? Wallet
    : S extends undefined
    ? never
    : S extends WalletArgs | WalletFindManyArgs
    ?'include' extends U
    ? Wallet  & {
    [P in TrueKeys<S['include']>]:
        P extends 'settlementDefault' ? SettlementGetPayload<S['include'][P]> | null :
        P extends 'answers' ? Array < AnswerGetPayload<S['include'][P]>>  :
        P extends 'badges' ? Array < BadgeGetPayload<S['include'][P]>>  :
        P extends 'billing' ? Array < BillingGetPayload<S['include'][P]>>  :
        P extends 'creditorCredit' ? Array < CreditGetPayload<S['include'][P]>>  :
        P extends 'debtorCredit' ? Array < CreditGetPayload<S['include'][P]>>  :
        P extends 'creditConfigurations' ? Array < CreditConfigurationGetPayload<S['include'][P]>>  :
        P extends 'customer' ? Array < CustomerGetPayload<S['include'][P]>>  :
        P extends 'vendor' ? Array < CustomerGetPayload<S['include'][P]>>  :
        P extends 'creditorInstallments' ? Array < InstallmentGetPayload<S['include'][P]>>  :
        P extends 'debtorInstallments' ? Array < InstallmentGetPayload<S['include'][P]>>  :
        P extends 'metaData' ? MetaDataGetPayload<S['include'][P]> | null :
        P extends 'order' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'product' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'settings' ? SettingsGetPayload<S['include'][P]> | null :
        P extends 'settlement' ? Array < SettlementGetPayload<S['include'][P]>>  :
        P extends 'shipping' ? Array < ShippingGetPayload<S['include'][P]>>  :
        P extends 'supplier' ? Array < SupplierGetPayload<S['include'][P]>>  :
        P extends 'vendorSupplier' ? Array < SupplierGetPayload<S['include'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends 'usersWallets' ? Array < UsersWalletsGetPayload<S['include'][P]>>  :
        P extends 'visit' ? Array < VisitGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'trust' ? TrustGetPayload<S['include'][P]> | null :
        P extends '_count' ? WalletCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'settlementDefault' ? SettlementGetPayload<S['select'][P]> | null :
        P extends 'answers' ? Array < AnswerGetPayload<S['select'][P]>>  :
        P extends 'badges' ? Array < BadgeGetPayload<S['select'][P]>>  :
        P extends 'billing' ? Array < BillingGetPayload<S['select'][P]>>  :
        P extends 'creditorCredit' ? Array < CreditGetPayload<S['select'][P]>>  :
        P extends 'debtorCredit' ? Array < CreditGetPayload<S['select'][P]>>  :
        P extends 'creditConfigurations' ? Array < CreditConfigurationGetPayload<S['select'][P]>>  :
        P extends 'customer' ? Array < CustomerGetPayload<S['select'][P]>>  :
        P extends 'vendor' ? Array < CustomerGetPayload<S['select'][P]>>  :
        P extends 'creditorInstallments' ? Array < InstallmentGetPayload<S['select'][P]>>  :
        P extends 'debtorInstallments' ? Array < InstallmentGetPayload<S['select'][P]>>  :
        P extends 'metaData' ? MetaDataGetPayload<S['select'][P]> | null :
        P extends 'order' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'orders' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'product' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'settings' ? SettingsGetPayload<S['select'][P]> | null :
        P extends 'settlement' ? Array < SettlementGetPayload<S['select'][P]>>  :
        P extends 'shipping' ? Array < ShippingGetPayload<S['select'][P]>>  :
        P extends 'supplier' ? Array < SupplierGetPayload<S['select'][P]>>  :
        P extends 'vendorSupplier' ? Array < SupplierGetPayload<S['select'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends 'usersWallets' ? Array < UsersWalletsGetPayload<S['select'][P]>>  :
        P extends 'visit' ? Array < VisitGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'trust' ? TrustGetPayload<S['select'][P]> | null :
        P extends '_count' ? WalletCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Wallet ? Wallet[P] : never
  } 
    : Wallet
  : Wallet


  type WalletCountArgs = Merge<
    Omit<WalletFindManyArgs, 'select' | 'include'> & {
      select?: WalletCountAggregateInputType | true
    }
  >

  export interface WalletDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WalletFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WalletFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Wallet'> extends True ? CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>> : CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WalletFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WalletFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Wallet'> extends True ? CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>> : CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WalletFindManyArgs>(
      args?: SelectSubset<T, WalletFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Wallet>>, PrismaPromise<Array<WalletGetPayload<T>>>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
    **/
    create<T extends WalletCreateArgs>(
      args: SelectSubset<T, WalletCreateArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Create many Wallets.
     *     @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     *     @example
     *     // Create many Wallets
     *     const wallet = await prisma.wallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WalletCreateManyArgs>(
      args?: SelectSubset<T, WalletCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
    **/
    delete<T extends WalletDeleteArgs>(
      args: SelectSubset<T, WalletDeleteArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WalletUpdateArgs>(
      args: SelectSubset<T, WalletUpdateArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WalletDeleteManyArgs>(
      args?: SelectSubset<T, WalletDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WalletUpdateManyArgs>(
      args: SelectSubset<T, WalletUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
    **/
    upsert<T extends WalletUpsertArgs>(
      args: SelectSubset<T, WalletUpsertArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WalletClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    settlementDefault<T extends SettlementArgs = {}>(args?: Subset<T, SettlementArgs>): CheckSelect<T, Prisma__SettlementClient<Settlement | null >, Prisma__SettlementClient<SettlementGetPayload<T> | null >>;

    answers<T extends AnswerFindManyArgs = {}>(args?: Subset<T, AnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Answer>>, PrismaPromise<Array<AnswerGetPayload<T>>>>;

    badges<T extends BadgeFindManyArgs = {}>(args?: Subset<T, BadgeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Badge>>, PrismaPromise<Array<BadgeGetPayload<T>>>>;

    billing<T extends BillingFindManyArgs = {}>(args?: Subset<T, BillingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Billing>>, PrismaPromise<Array<BillingGetPayload<T>>>>;

    creditorCredit<T extends CreditFindManyArgs = {}>(args?: Subset<T, CreditFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Credit>>, PrismaPromise<Array<CreditGetPayload<T>>>>;

    debtorCredit<T extends CreditFindManyArgs = {}>(args?: Subset<T, CreditFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Credit>>, PrismaPromise<Array<CreditGetPayload<T>>>>;

    creditConfigurations<T extends CreditConfigurationFindManyArgs = {}>(args?: Subset<T, CreditConfigurationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CreditConfiguration>>, PrismaPromise<Array<CreditConfigurationGetPayload<T>>>>;

    customer<T extends CustomerFindManyArgs = {}>(args?: Subset<T, CustomerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Customer>>, PrismaPromise<Array<CustomerGetPayload<T>>>>;

    vendor<T extends CustomerFindManyArgs = {}>(args?: Subset<T, CustomerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Customer>>, PrismaPromise<Array<CustomerGetPayload<T>>>>;

    creditorInstallments<T extends InstallmentFindManyArgs = {}>(args?: Subset<T, InstallmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Installment>>, PrismaPromise<Array<InstallmentGetPayload<T>>>>;

    debtorInstallments<T extends InstallmentFindManyArgs = {}>(args?: Subset<T, InstallmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Installment>>, PrismaPromise<Array<InstallmentGetPayload<T>>>>;

    metaData<T extends MetaDataArgs = {}>(args?: Subset<T, MetaDataArgs>): CheckSelect<T, Prisma__MetaDataClient<MetaData | null >, Prisma__MetaDataClient<MetaDataGetPayload<T> | null >>;

    order<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    product<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    settings<T extends SettingsArgs = {}>(args?: Subset<T, SettingsArgs>): CheckSelect<T, Prisma__SettingsClient<Settings | null >, Prisma__SettingsClient<SettingsGetPayload<T> | null >>;

    settlement<T extends SettlementFindManyArgs = {}>(args?: Subset<T, SettlementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Settlement>>, PrismaPromise<Array<SettlementGetPayload<T>>>>;

    shipping<T extends ShippingFindManyArgs = {}>(args?: Subset<T, ShippingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Shipping>>, PrismaPromise<Array<ShippingGetPayload<T>>>>;

    supplier<T extends SupplierFindManyArgs = {}>(args?: Subset<T, SupplierFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Supplier>>, PrismaPromise<Array<SupplierGetPayload<T>>>>;

    vendorSupplier<T extends SupplierFindManyArgs = {}>(args?: Subset<T, SupplierFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Supplier>>, PrismaPromise<Array<SupplierGetPayload<T>>>>;

    transaction<T extends TransactionFindManyArgs = {}>(args?: Subset<T, TransactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>;

    usersWallets<T extends UsersWalletsFindManyArgs = {}>(args?: Subset<T, UsersWalletsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UsersWallets>>, PrismaPromise<Array<UsersWalletsGetPayload<T>>>>;

    visit<T extends VisitFindManyArgs = {}>(args?: Subset<T, VisitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Visit>>, PrismaPromise<Array<VisitGetPayload<T>>>>;

    users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    trust<T extends TrustArgs = {}>(args?: Subset<T, TrustArgs>): CheckSelect<T, Prisma__TrustClient<Trust | null >, Prisma__TrustClient<TrustGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Throw an Error if a Wallet can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Wallet to fetch.
     * 
    **/
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Throw an Error if a Wallet can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Wallet to fetch.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     * 
    **/
    distinct?: Enumerable<WalletScalarFieldEnum>
  }


  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Filter, which Wallets to fetch.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WalletScalarFieldEnum>
  }


  /**
   * Wallet create
   */
  export type WalletCreateArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The data needed to create a Wallet.
     * 
    **/
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }


  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs = {
    /**
     * The data used to create many Wallets.
     * 
    **/
    data: Enumerable<WalletCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Wallet update
   */
  export type WalletUpdateArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The data needed to update a Wallet.
     * 
    **/
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     * 
    **/
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs = {
    /**
     * The data used to update Wallets.
     * 
    **/
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     * 
    **/
    where?: WalletWhereInput
  }


  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     * 
    **/
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     * 
    **/
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }


  /**
   * Wallet delete
   */
  export type WalletDeleteArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Filter which Wallet to delete.
     * 
    **/
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs = {
    /**
     * Filter which Wallets to delete
     * 
    **/
    where?: WalletWhereInput
  }


  /**
   * Wallet without action
   */
  export type WalletArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
  }



  /**
   * Model Trust
   */


  export type AggregateTrust = {
    _count: TrustCountAggregateOutputType | null
    _avg: TrustAvgAggregateOutputType | null
    _sum: TrustSumAggregateOutputType | null
    _min: TrustMinAggregateOutputType | null
    _max: TrustMaxAggregateOutputType | null
  }

  export type TrustAvgAggregateOutputType = {
    trustRating: number | null
    score: number | null
  }

  export type TrustSumAggregateOutputType = {
    trustRating: number | null
    score: number | null
  }

  export type TrustMinAggregateOutputType = {
    account: string | null
    trustRating: number | null
    score: number | null
    createdAt: Date | null
  }

  export type TrustMaxAggregateOutputType = {
    account: string | null
    trustRating: number | null
    score: number | null
    createdAt: Date | null
  }

  export type TrustCountAggregateOutputType = {
    account: number
    trustRating: number
    score: number
    createdAt: number
    _all: number
  }


  export type TrustAvgAggregateInputType = {
    trustRating?: true
    score?: true
  }

  export type TrustSumAggregateInputType = {
    trustRating?: true
    score?: true
  }

  export type TrustMinAggregateInputType = {
    account?: true
    trustRating?: true
    score?: true
    createdAt?: true
  }

  export type TrustMaxAggregateInputType = {
    account?: true
    trustRating?: true
    score?: true
    createdAt?: true
  }

  export type TrustCountAggregateInputType = {
    account?: true
    trustRating?: true
    score?: true
    createdAt?: true
    _all?: true
  }

  export type TrustAggregateArgs = {
    /**
     * Filter which Trust to aggregate.
     * 
    **/
    where?: TrustWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trusts to fetch.
     * 
    **/
    orderBy?: Enumerable<TrustOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TrustWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trusts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trusts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trusts
    **/
    _count?: true | TrustCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrustAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrustSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrustMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrustMaxAggregateInputType
  }

  export type GetTrustAggregateType<T extends TrustAggregateArgs> = {
        [P in keyof T & keyof AggregateTrust]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrust[P]>
      : GetScalarType<T[P], AggregateTrust[P]>
  }




  export type TrustGroupByArgs = {
    where?: TrustWhereInput
    orderBy?: Enumerable<TrustOrderByWithAggregationInput>
    by: Array<TrustScalarFieldEnum>
    having?: TrustScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrustCountAggregateInputType | true
    _avg?: TrustAvgAggregateInputType
    _sum?: TrustSumAggregateInputType
    _min?: TrustMinAggregateInputType
    _max?: TrustMaxAggregateInputType
  }


  export type TrustGroupByOutputType = {
    account: string
    trustRating: number | null
    score: number | null
    createdAt: Date
    _count: TrustCountAggregateOutputType | null
    _avg: TrustAvgAggregateOutputType | null
    _sum: TrustSumAggregateOutputType | null
    _min: TrustMinAggregateOutputType | null
    _max: TrustMaxAggregateOutputType | null
  }

  type GetTrustGroupByPayload<T extends TrustGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TrustGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrustGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrustGroupByOutputType[P]>
            : GetScalarType<T[P], TrustGroupByOutputType[P]>
        }
      >
    >


  export type TrustSelect = {
    account?: boolean
    trustRating?: boolean
    score?: boolean
    createdAt?: boolean
    Wallet?: boolean | WalletArgs
  }

  export type TrustInclude = {
    Wallet?: boolean | WalletArgs
  }

  export type TrustGetPayload<
    S extends boolean | null | undefined | TrustArgs,
    U = keyof S
      > = S extends true
        ? Trust
    : S extends undefined
    ? never
    : S extends TrustArgs | TrustFindManyArgs
    ?'include' extends U
    ? Trust  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Wallet' ? WalletGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Wallet' ? WalletGetPayload<S['select'][P]> | null :  P extends keyof Trust ? Trust[P] : never
  } 
    : Trust
  : Trust


  type TrustCountArgs = Merge<
    Omit<TrustFindManyArgs, 'select' | 'include'> & {
      select?: TrustCountAggregateInputType | true
    }
  >

  export interface TrustDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Trust that matches the filter.
     * @param {TrustFindUniqueArgs} args - Arguments to find a Trust
     * @example
     * // Get one Trust
     * const trust = await prisma.trust.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrustFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TrustFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Trust'> extends True ? CheckSelect<T, Prisma__TrustClient<Trust>, Prisma__TrustClient<TrustGetPayload<T>>> : CheckSelect<T, Prisma__TrustClient<Trust | null >, Prisma__TrustClient<TrustGetPayload<T> | null >>

    /**
     * Find the first Trust that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustFindFirstArgs} args - Arguments to find a Trust
     * @example
     * // Get one Trust
     * const trust = await prisma.trust.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrustFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TrustFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Trust'> extends True ? CheckSelect<T, Prisma__TrustClient<Trust>, Prisma__TrustClient<TrustGetPayload<T>>> : CheckSelect<T, Prisma__TrustClient<Trust | null >, Prisma__TrustClient<TrustGetPayload<T> | null >>

    /**
     * Find zero or more Trusts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trusts
     * const trusts = await prisma.trust.findMany()
     * 
     * // Get first 10 Trusts
     * const trusts = await prisma.trust.findMany({ take: 10 })
     * 
     * // Only select the `account`
     * const trustWithAccountOnly = await prisma.trust.findMany({ select: { account: true } })
     * 
    **/
    findMany<T extends TrustFindManyArgs>(
      args?: SelectSubset<T, TrustFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Trust>>, PrismaPromise<Array<TrustGetPayload<T>>>>

    /**
     * Create a Trust.
     * @param {TrustCreateArgs} args - Arguments to create a Trust.
     * @example
     * // Create one Trust
     * const Trust = await prisma.trust.create({
     *   data: {
     *     // ... data to create a Trust
     *   }
     * })
     * 
    **/
    create<T extends TrustCreateArgs>(
      args: SelectSubset<T, TrustCreateArgs>
    ): CheckSelect<T, Prisma__TrustClient<Trust>, Prisma__TrustClient<TrustGetPayload<T>>>

    /**
     * Create many Trusts.
     *     @param {TrustCreateManyArgs} args - Arguments to create many Trusts.
     *     @example
     *     // Create many Trusts
     *     const trust = await prisma.trust.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrustCreateManyArgs>(
      args?: SelectSubset<T, TrustCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Trust.
     * @param {TrustDeleteArgs} args - Arguments to delete one Trust.
     * @example
     * // Delete one Trust
     * const Trust = await prisma.trust.delete({
     *   where: {
     *     // ... filter to delete one Trust
     *   }
     * })
     * 
    **/
    delete<T extends TrustDeleteArgs>(
      args: SelectSubset<T, TrustDeleteArgs>
    ): CheckSelect<T, Prisma__TrustClient<Trust>, Prisma__TrustClient<TrustGetPayload<T>>>

    /**
     * Update one Trust.
     * @param {TrustUpdateArgs} args - Arguments to update one Trust.
     * @example
     * // Update one Trust
     * const trust = await prisma.trust.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrustUpdateArgs>(
      args: SelectSubset<T, TrustUpdateArgs>
    ): CheckSelect<T, Prisma__TrustClient<Trust>, Prisma__TrustClient<TrustGetPayload<T>>>

    /**
     * Delete zero or more Trusts.
     * @param {TrustDeleteManyArgs} args - Arguments to filter Trusts to delete.
     * @example
     * // Delete a few Trusts
     * const { count } = await prisma.trust.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrustDeleteManyArgs>(
      args?: SelectSubset<T, TrustDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trusts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trusts
     * const trust = await prisma.trust.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrustUpdateManyArgs>(
      args: SelectSubset<T, TrustUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Trust.
     * @param {TrustUpsertArgs} args - Arguments to update or create a Trust.
     * @example
     * // Update or create a Trust
     * const trust = await prisma.trust.upsert({
     *   create: {
     *     // ... data to create a Trust
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trust we want to update
     *   }
     * })
    **/
    upsert<T extends TrustUpsertArgs>(
      args: SelectSubset<T, TrustUpsertArgs>
    ): CheckSelect<T, Prisma__TrustClient<Trust>, Prisma__TrustClient<TrustGetPayload<T>>>

    /**
     * Count the number of Trusts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustCountArgs} args - Arguments to filter Trusts to count.
     * @example
     * // Count the number of Trusts
     * const count = await prisma.trust.count({
     *   where: {
     *     // ... the filter for the Trusts we want to count
     *   }
     * })
    **/
    count<T extends TrustCountArgs>(
      args?: Subset<T, TrustCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrustCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trust.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrustAggregateArgs>(args: Subset<T, TrustAggregateArgs>): PrismaPromise<GetTrustAggregateType<T>>

    /**
     * Group by Trust.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrustGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrustGroupByArgs['orderBy'] }
        : { orderBy?: TrustGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrustGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrustGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trust.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrustClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Trust findUnique
   */
  export type TrustFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Trust
     * 
    **/
    select?: TrustSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrustInclude | null
    /**
     * Throw an Error if a Trust can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Trust to fetch.
     * 
    **/
    where: TrustWhereUniqueInput
  }


  /**
   * Trust findFirst
   */
  export type TrustFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Trust
     * 
    **/
    select?: TrustSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrustInclude | null
    /**
     * Throw an Error if a Trust can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Trust to fetch.
     * 
    **/
    where?: TrustWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trusts to fetch.
     * 
    **/
    orderBy?: Enumerable<TrustOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trusts.
     * 
    **/
    cursor?: TrustWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trusts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trusts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trusts.
     * 
    **/
    distinct?: Enumerable<TrustScalarFieldEnum>
  }


  /**
   * Trust findMany
   */
  export type TrustFindManyArgs = {
    /**
     * Select specific fields to fetch from the Trust
     * 
    **/
    select?: TrustSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrustInclude | null
    /**
     * Filter, which Trusts to fetch.
     * 
    **/
    where?: TrustWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trusts to fetch.
     * 
    **/
    orderBy?: Enumerable<TrustOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trusts.
     * 
    **/
    cursor?: TrustWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trusts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trusts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TrustScalarFieldEnum>
  }


  /**
   * Trust create
   */
  export type TrustCreateArgs = {
    /**
     * Select specific fields to fetch from the Trust
     * 
    **/
    select?: TrustSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrustInclude | null
    /**
     * The data needed to create a Trust.
     * 
    **/
    data: XOR<TrustCreateInput, TrustUncheckedCreateInput>
  }


  /**
   * Trust createMany
   */
  export type TrustCreateManyArgs = {
    /**
     * The data used to create many Trusts.
     * 
    **/
    data: Enumerable<TrustCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Trust update
   */
  export type TrustUpdateArgs = {
    /**
     * Select specific fields to fetch from the Trust
     * 
    **/
    select?: TrustSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrustInclude | null
    /**
     * The data needed to update a Trust.
     * 
    **/
    data: XOR<TrustUpdateInput, TrustUncheckedUpdateInput>
    /**
     * Choose, which Trust to update.
     * 
    **/
    where: TrustWhereUniqueInput
  }


  /**
   * Trust updateMany
   */
  export type TrustUpdateManyArgs = {
    /**
     * The data used to update Trusts.
     * 
    **/
    data: XOR<TrustUpdateManyMutationInput, TrustUncheckedUpdateManyInput>
    /**
     * Filter which Trusts to update
     * 
    **/
    where?: TrustWhereInput
  }


  /**
   * Trust upsert
   */
  export type TrustUpsertArgs = {
    /**
     * Select specific fields to fetch from the Trust
     * 
    **/
    select?: TrustSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrustInclude | null
    /**
     * The filter to search for the Trust to update in case it exists.
     * 
    **/
    where: TrustWhereUniqueInput
    /**
     * In case the Trust found by the `where` argument doesn't exist, create a new Trust with this data.
     * 
    **/
    create: XOR<TrustCreateInput, TrustUncheckedCreateInput>
    /**
     * In case the Trust was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TrustUpdateInput, TrustUncheckedUpdateInput>
  }


  /**
   * Trust delete
   */
  export type TrustDeleteArgs = {
    /**
     * Select specific fields to fetch from the Trust
     * 
    **/
    select?: TrustSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrustInclude | null
    /**
     * Filter which Trust to delete.
     * 
    **/
    where: TrustWhereUniqueInput
  }


  /**
   * Trust deleteMany
   */
  export type TrustDeleteManyArgs = {
    /**
     * Filter which Trusts to delete
     * 
    **/
    where?: TrustWhereInput
  }


  /**
   * Trust without action
   */
  export type TrustArgs = {
    /**
     * Select specific fields to fetch from the Trust
     * 
    **/
    select?: TrustSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TrustInclude | null
  }



  /**
   * Model MetaData
   */


  export type AggregateMetaData = {
    _count: MetaDataCountAggregateOutputType | null
    _avg: MetaDataAvgAggregateOutputType | null
    _sum: MetaDataSumAggregateOutputType | null
    _min: MetaDataMinAggregateOutputType | null
    _max: MetaDataMaxAggregateOutputType | null
  }

  export type MetaDataAvgAggregateOutputType = {
    maxBuyerOrderAmount: number | null
  }

  export type MetaDataSumAggregateOutputType = {
    maxBuyerOrderAmount: number | null
  }

  export type MetaDataMinAggregateOutputType = {
    walletAccount: string | null
    taxId: string | null
    taxName: string | null
    seller: boolean | null
    sellerPhase: phaseEnum | null
    buyerPhase: phaseEnum | null
    partnerRole: partnerRoleEnum | null
    documentCOI: string | null
    documentCR12: string | null
    documentSCF: string | null
    documentSCA: string | null
    documentStore: string | null
    documentKRAcert: string | null
    legalStatus: legalStatusEnum | null
    buyer: boolean | null
    maxBuyerOrderAmount: number | null
  }

  export type MetaDataMaxAggregateOutputType = {
    walletAccount: string | null
    taxId: string | null
    taxName: string | null
    seller: boolean | null
    sellerPhase: phaseEnum | null
    buyerPhase: phaseEnum | null
    partnerRole: partnerRoleEnum | null
    documentCOI: string | null
    documentCR12: string | null
    documentSCF: string | null
    documentSCA: string | null
    documentStore: string | null
    documentKRAcert: string | null
    legalStatus: legalStatusEnum | null
    buyer: boolean | null
    maxBuyerOrderAmount: number | null
  }

  export type MetaDataCountAggregateOutputType = {
    walletAccount: number
    CRB: number
    taxId: number
    taxName: number
    seller: number
    sellerPhase: number
    buyerPhase: number
    partnerRole: number
    documentCOI: number
    documentCR12: number
    documentSCF: number
    documentSCA: number
    documentStore: number
    documentKRAcert: number
    legalStatus: number
    metaBaseURL: number
    buyer: number
    maxBuyerOrderAmount: number
    _all: number
  }


  export type MetaDataAvgAggregateInputType = {
    maxBuyerOrderAmount?: true
  }

  export type MetaDataSumAggregateInputType = {
    maxBuyerOrderAmount?: true
  }

  export type MetaDataMinAggregateInputType = {
    walletAccount?: true
    taxId?: true
    taxName?: true
    seller?: true
    sellerPhase?: true
    buyerPhase?: true
    partnerRole?: true
    documentCOI?: true
    documentCR12?: true
    documentSCF?: true
    documentSCA?: true
    documentStore?: true
    documentKRAcert?: true
    legalStatus?: true
    buyer?: true
    maxBuyerOrderAmount?: true
  }

  export type MetaDataMaxAggregateInputType = {
    walletAccount?: true
    taxId?: true
    taxName?: true
    seller?: true
    sellerPhase?: true
    buyerPhase?: true
    partnerRole?: true
    documentCOI?: true
    documentCR12?: true
    documentSCF?: true
    documentSCA?: true
    documentStore?: true
    documentKRAcert?: true
    legalStatus?: true
    buyer?: true
    maxBuyerOrderAmount?: true
  }

  export type MetaDataCountAggregateInputType = {
    walletAccount?: true
    CRB?: true
    taxId?: true
    taxName?: true
    seller?: true
    sellerPhase?: true
    buyerPhase?: true
    partnerRole?: true
    documentCOI?: true
    documentCR12?: true
    documentSCF?: true
    documentSCA?: true
    documentStore?: true
    documentKRAcert?: true
    legalStatus?: true
    metaBaseURL?: true
    buyer?: true
    maxBuyerOrderAmount?: true
    _all?: true
  }

  export type MetaDataAggregateArgs = {
    /**
     * Filter which MetaData to aggregate.
     * 
    **/
    where?: MetaDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaData to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MetaDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaData.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetaData
    **/
    _count?: true | MetaDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetaDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetaDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaDataMaxAggregateInputType
  }

  export type GetMetaDataAggregateType<T extends MetaDataAggregateArgs> = {
        [P in keyof T & keyof AggregateMetaData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetaData[P]>
      : GetScalarType<T[P], AggregateMetaData[P]>
  }




  export type MetaDataGroupByArgs = {
    where?: MetaDataWhereInput
    orderBy?: Enumerable<MetaDataOrderByWithAggregationInput>
    by: Array<MetaDataScalarFieldEnum>
    having?: MetaDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaDataCountAggregateInputType | true
    _avg?: MetaDataAvgAggregateInputType
    _sum?: MetaDataSumAggregateInputType
    _min?: MetaDataMinAggregateInputType
    _max?: MetaDataMaxAggregateInputType
  }


  export type MetaDataGroupByOutputType = {
    walletAccount: string
    CRB: JsonValue | null
    taxId: string | null
    taxName: string | null
    seller: boolean | null
    sellerPhase: phaseEnum | null
    buyerPhase: phaseEnum | null
    partnerRole: partnerRoleEnum | null
    documentCOI: string | null
    documentCR12: string | null
    documentSCF: string | null
    documentSCA: string | null
    documentStore: string | null
    documentKRAcert: string | null
    legalStatus: legalStatusEnum | null
    metaBaseURL: JsonValue | null
    buyer: boolean | null
    maxBuyerOrderAmount: number | null
    _count: MetaDataCountAggregateOutputType | null
    _avg: MetaDataAvgAggregateOutputType | null
    _sum: MetaDataSumAggregateOutputType | null
    _min: MetaDataMinAggregateOutputType | null
    _max: MetaDataMaxAggregateOutputType | null
  }

  type GetMetaDataGroupByPayload<T extends MetaDataGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MetaDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaDataGroupByOutputType[P]>
            : GetScalarType<T[P], MetaDataGroupByOutputType[P]>
        }
      >
    >


  export type MetaDataSelect = {
    walletAccount?: boolean
    CRB?: boolean
    taxId?: boolean
    taxName?: boolean
    seller?: boolean
    sellerPhase?: boolean
    buyerPhase?: boolean
    partnerRole?: boolean
    documentCOI?: boolean
    documentCR12?: boolean
    documentSCF?: boolean
    documentSCA?: boolean
    documentStore?: boolean
    documentKRAcert?: boolean
    legalStatus?: boolean
    metaBaseURL?: boolean
    buyer?: boolean
    maxBuyerOrderAmount?: boolean
    wallet?: boolean | WalletArgs
  }

  export type MetaDataInclude = {
    wallet?: boolean | WalletArgs
  }

  export type MetaDataGetPayload<
    S extends boolean | null | undefined | MetaDataArgs,
    U = keyof S
      > = S extends true
        ? MetaData
    : S extends undefined
    ? never
    : S extends MetaDataArgs | MetaDataFindManyArgs
    ?'include' extends U
    ? MetaData  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :  P extends keyof MetaData ? MetaData[P] : never
  } 
    : MetaData
  : MetaData


  type MetaDataCountArgs = Merge<
    Omit<MetaDataFindManyArgs, 'select' | 'include'> & {
      select?: MetaDataCountAggregateInputType | true
    }
  >

  export interface MetaDataDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MetaData that matches the filter.
     * @param {MetaDataFindUniqueArgs} args - Arguments to find a MetaData
     * @example
     * // Get one MetaData
     * const metaData = await prisma.metaData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MetaDataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MetaDataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MetaData'> extends True ? CheckSelect<T, Prisma__MetaDataClient<MetaData>, Prisma__MetaDataClient<MetaDataGetPayload<T>>> : CheckSelect<T, Prisma__MetaDataClient<MetaData | null >, Prisma__MetaDataClient<MetaDataGetPayload<T> | null >>

    /**
     * Find the first MetaData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaDataFindFirstArgs} args - Arguments to find a MetaData
     * @example
     * // Get one MetaData
     * const metaData = await prisma.metaData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MetaDataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MetaDataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MetaData'> extends True ? CheckSelect<T, Prisma__MetaDataClient<MetaData>, Prisma__MetaDataClient<MetaDataGetPayload<T>>> : CheckSelect<T, Prisma__MetaDataClient<MetaData | null >, Prisma__MetaDataClient<MetaDataGetPayload<T> | null >>

    /**
     * Find zero or more MetaData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetaData
     * const metaData = await prisma.metaData.findMany()
     * 
     * // Get first 10 MetaData
     * const metaData = await prisma.metaData.findMany({ take: 10 })
     * 
     * // Only select the `walletAccount`
     * const metaDataWithWalletAccountOnly = await prisma.metaData.findMany({ select: { walletAccount: true } })
     * 
    **/
    findMany<T extends MetaDataFindManyArgs>(
      args?: SelectSubset<T, MetaDataFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MetaData>>, PrismaPromise<Array<MetaDataGetPayload<T>>>>

    /**
     * Create a MetaData.
     * @param {MetaDataCreateArgs} args - Arguments to create a MetaData.
     * @example
     * // Create one MetaData
     * const MetaData = await prisma.metaData.create({
     *   data: {
     *     // ... data to create a MetaData
     *   }
     * })
     * 
    **/
    create<T extends MetaDataCreateArgs>(
      args: SelectSubset<T, MetaDataCreateArgs>
    ): CheckSelect<T, Prisma__MetaDataClient<MetaData>, Prisma__MetaDataClient<MetaDataGetPayload<T>>>

    /**
     * Create many MetaData.
     *     @param {MetaDataCreateManyArgs} args - Arguments to create many MetaData.
     *     @example
     *     // Create many MetaData
     *     const metaData = await prisma.metaData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MetaDataCreateManyArgs>(
      args?: SelectSubset<T, MetaDataCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MetaData.
     * @param {MetaDataDeleteArgs} args - Arguments to delete one MetaData.
     * @example
     * // Delete one MetaData
     * const MetaData = await prisma.metaData.delete({
     *   where: {
     *     // ... filter to delete one MetaData
     *   }
     * })
     * 
    **/
    delete<T extends MetaDataDeleteArgs>(
      args: SelectSubset<T, MetaDataDeleteArgs>
    ): CheckSelect<T, Prisma__MetaDataClient<MetaData>, Prisma__MetaDataClient<MetaDataGetPayload<T>>>

    /**
     * Update one MetaData.
     * @param {MetaDataUpdateArgs} args - Arguments to update one MetaData.
     * @example
     * // Update one MetaData
     * const metaData = await prisma.metaData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MetaDataUpdateArgs>(
      args: SelectSubset<T, MetaDataUpdateArgs>
    ): CheckSelect<T, Prisma__MetaDataClient<MetaData>, Prisma__MetaDataClient<MetaDataGetPayload<T>>>

    /**
     * Delete zero or more MetaData.
     * @param {MetaDataDeleteManyArgs} args - Arguments to filter MetaData to delete.
     * @example
     * // Delete a few MetaData
     * const { count } = await prisma.metaData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MetaDataDeleteManyArgs>(
      args?: SelectSubset<T, MetaDataDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetaData
     * const metaData = await prisma.metaData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MetaDataUpdateManyArgs>(
      args: SelectSubset<T, MetaDataUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MetaData.
     * @param {MetaDataUpsertArgs} args - Arguments to update or create a MetaData.
     * @example
     * // Update or create a MetaData
     * const metaData = await prisma.metaData.upsert({
     *   create: {
     *     // ... data to create a MetaData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetaData we want to update
     *   }
     * })
    **/
    upsert<T extends MetaDataUpsertArgs>(
      args: SelectSubset<T, MetaDataUpsertArgs>
    ): CheckSelect<T, Prisma__MetaDataClient<MetaData>, Prisma__MetaDataClient<MetaDataGetPayload<T>>>

    /**
     * Count the number of MetaData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaDataCountArgs} args - Arguments to filter MetaData to count.
     * @example
     * // Count the number of MetaData
     * const count = await prisma.metaData.count({
     *   where: {
     *     // ... the filter for the MetaData we want to count
     *   }
     * })
    **/
    count<T extends MetaDataCountArgs>(
      args?: Subset<T, MetaDataCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetaData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaDataAggregateArgs>(args: Subset<T, MetaDataAggregateArgs>): PrismaPromise<GetMetaDataAggregateType<T>>

    /**
     * Group by MetaData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetaDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetaDataGroupByArgs['orderBy'] }
        : { orderBy?: MetaDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetaDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaDataGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetaData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MetaDataClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MetaData findUnique
   */
  export type MetaDataFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MetaData
     * 
    **/
    select?: MetaDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaDataInclude | null
    /**
     * Throw an Error if a MetaData can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MetaData to fetch.
     * 
    **/
    where: MetaDataWhereUniqueInput
  }


  /**
   * MetaData findFirst
   */
  export type MetaDataFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MetaData
     * 
    **/
    select?: MetaDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaDataInclude | null
    /**
     * Throw an Error if a MetaData can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MetaData to fetch.
     * 
    **/
    where?: MetaDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaData to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaData.
     * 
    **/
    cursor?: MetaDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaData.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaData.
     * 
    **/
    distinct?: Enumerable<MetaDataScalarFieldEnum>
  }


  /**
   * MetaData findMany
   */
  export type MetaDataFindManyArgs = {
    /**
     * Select specific fields to fetch from the MetaData
     * 
    **/
    select?: MetaDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaDataInclude | null
    /**
     * Filter, which MetaData to fetch.
     * 
    **/
    where?: MetaDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaData to fetch.
     * 
    **/
    orderBy?: Enumerable<MetaDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetaData.
     * 
    **/
    cursor?: MetaDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaData.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MetaDataScalarFieldEnum>
  }


  /**
   * MetaData create
   */
  export type MetaDataCreateArgs = {
    /**
     * Select specific fields to fetch from the MetaData
     * 
    **/
    select?: MetaDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaDataInclude | null
    /**
     * The data needed to create a MetaData.
     * 
    **/
    data: XOR<MetaDataCreateInput, MetaDataUncheckedCreateInput>
  }


  /**
   * MetaData createMany
   */
  export type MetaDataCreateManyArgs = {
    /**
     * The data used to create many MetaData.
     * 
    **/
    data: Enumerable<MetaDataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MetaData update
   */
  export type MetaDataUpdateArgs = {
    /**
     * Select specific fields to fetch from the MetaData
     * 
    **/
    select?: MetaDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaDataInclude | null
    /**
     * The data needed to update a MetaData.
     * 
    **/
    data: XOR<MetaDataUpdateInput, MetaDataUncheckedUpdateInput>
    /**
     * Choose, which MetaData to update.
     * 
    **/
    where: MetaDataWhereUniqueInput
  }


  /**
   * MetaData updateMany
   */
  export type MetaDataUpdateManyArgs = {
    /**
     * The data used to update MetaData.
     * 
    **/
    data: XOR<MetaDataUpdateManyMutationInput, MetaDataUncheckedUpdateManyInput>
    /**
     * Filter which MetaData to update
     * 
    **/
    where?: MetaDataWhereInput
  }


  /**
   * MetaData upsert
   */
  export type MetaDataUpsertArgs = {
    /**
     * Select specific fields to fetch from the MetaData
     * 
    **/
    select?: MetaDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaDataInclude | null
    /**
     * The filter to search for the MetaData to update in case it exists.
     * 
    **/
    where: MetaDataWhereUniqueInput
    /**
     * In case the MetaData found by the `where` argument doesn't exist, create a new MetaData with this data.
     * 
    **/
    create: XOR<MetaDataCreateInput, MetaDataUncheckedCreateInput>
    /**
     * In case the MetaData was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MetaDataUpdateInput, MetaDataUncheckedUpdateInput>
  }


  /**
   * MetaData delete
   */
  export type MetaDataDeleteArgs = {
    /**
     * Select specific fields to fetch from the MetaData
     * 
    **/
    select?: MetaDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaDataInclude | null
    /**
     * Filter which MetaData to delete.
     * 
    **/
    where: MetaDataWhereUniqueInput
  }


  /**
   * MetaData deleteMany
   */
  export type MetaDataDeleteManyArgs = {
    /**
     * Filter which MetaData to delete
     * 
    **/
    where?: MetaDataWhereInput
  }


  /**
   * MetaData without action
   */
  export type MetaDataArgs = {
    /**
     * Select specific fields to fetch from the MetaData
     * 
    **/
    select?: MetaDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MetaDataInclude | null
  }



  /**
   * Model Transaction
   */


  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
    fee: number | null
    totalAmount: number | null
    balanceAfter: number | null
    balanceBefore: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
    fee: number | null
    totalAmount: number | null
    balanceAfter: number | null
    balanceBefore: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    amount: number | null
    fee: number | null
    totalAmount: number | null
    description: string | null
    paymentType: PaymentTypesEnum | null
    paymentTypeId: string | null
    currency: CurrencyEnum | null
    transactionType: TransactionTypeEnum | null
    method: TransactionMethodEnum | null
    walletId: string | null
    createdAt: Date | null
    name: string | null
    balanceAfter: number | null
    balanceBefore: number | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    fee: number | null
    totalAmount: number | null
    description: string | null
    paymentType: PaymentTypesEnum | null
    paymentTypeId: string | null
    currency: CurrencyEnum | null
    transactionType: TransactionTypeEnum | null
    method: TransactionMethodEnum | null
    walletId: string | null
    createdAt: Date | null
    name: string | null
    balanceAfter: number | null
    balanceBefore: number | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    amount: number
    fee: number
    totalAmount: number
    description: number
    paymentType: number
    paymentTypeId: number
    currency: number
    transactionType: number
    method: number
    walletId: number
    createdAt: number
    name: number
    balanceAfter: number
    balanceBefore: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    fee?: true
    totalAmount?: true
    balanceAfter?: true
    balanceBefore?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    fee?: true
    totalAmount?: true
    balanceAfter?: true
    balanceBefore?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    amount?: true
    fee?: true
    totalAmount?: true
    description?: true
    paymentType?: true
    paymentTypeId?: true
    currency?: true
    transactionType?: true
    method?: true
    walletId?: true
    createdAt?: true
    name?: true
    balanceAfter?: true
    balanceBefore?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    amount?: true
    fee?: true
    totalAmount?: true
    description?: true
    paymentType?: true
    paymentTypeId?: true
    currency?: true
    transactionType?: true
    method?: true
    walletId?: true
    createdAt?: true
    name?: true
    balanceAfter?: true
    balanceBefore?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    amount?: true
    fee?: true
    totalAmount?: true
    description?: true
    paymentType?: true
    paymentTypeId?: true
    currency?: true
    transactionType?: true
    method?: true
    walletId?: true
    createdAt?: true
    name?: true
    balanceAfter?: true
    balanceBefore?: true
    _all?: true
  }

  export type TransactionAggregateArgs = {
    /**
     * Filter which Transaction to aggregate.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs = {
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithAggregationInput>
    by: Array<TransactionScalarFieldEnum>
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }


  export type TransactionGroupByOutputType = {
    id: string
    amount: number
    fee: number
    totalAmount: number
    description: string | null
    paymentType: PaymentTypesEnum
    paymentTypeId: string | null
    currency: CurrencyEnum
    transactionType: TransactionTypeEnum | null
    method: TransactionMethodEnum | null
    walletId: string | null
    createdAt: Date
    name: string | null
    balanceAfter: number | null
    balanceBefore: number | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect = {
    id?: boolean
    amount?: boolean
    fee?: boolean
    totalAmount?: boolean
    description?: boolean
    paymentType?: boolean
    paymentTypeId?: boolean
    currency?: boolean
    transactionType?: boolean
    method?: boolean
    walletId?: boolean
    createdAt?: boolean
    name?: boolean
    balanceAfter?: boolean
    balanceBefore?: boolean
    wallet?: boolean | WalletArgs
  }

  export type TransactionInclude = {
    wallet?: boolean | WalletArgs
  }

  export type TransactionGetPayload<
    S extends boolean | null | undefined | TransactionArgs,
    U = keyof S
      > = S extends true
        ? Transaction
    : S extends undefined
    ? never
    : S extends TransactionArgs | TransactionFindManyArgs
    ?'include' extends U
    ? Transaction  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> | null :  P extends keyof Transaction ? Transaction[P] : never
  } 
    : Transaction
  : Transaction


  type TransactionCountArgs = Merge<
    Omit<TransactionFindManyArgs, 'select' | 'include'> & {
      select?: TransactionCountAggregateInputType | true
    }
  >

  export interface TransactionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs>(
      args?: SelectSubset<T, TransactionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs>(
      args: SelectSubset<T, TransactionCreateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Create many Transactions.
     *     @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transaction = await prisma.transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionCreateManyArgs>(
      args?: SelectSubset<T, TransactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs>(
      args: SelectSubset<T, TransactionDeleteArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs>(
      args: SelectSubset<T, TransactionUpdateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs>(
      args?: SelectSubset<T, TransactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs>(
      args: SelectSubset<T, TransactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs>(
      args: SelectSubset<T, TransactionUpsertArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransactionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Throw an Error if a Transaction can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transaction to fetch.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Throw an Error if a Transaction can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transaction to fetch.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     * 
    **/
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter, which Transactions to fetch.
     * 
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     * 
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to create a Transaction.
     * 
    **/
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs = {
    /**
     * The data used to create many Transactions.
     * 
    **/
    data: Enumerable<TransactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to update a Transaction.
     * 
    **/
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs = {
    /**
     * The data used to update Transactions.
     * 
    **/
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     * 
    **/
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     * 
    **/
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     * 
    **/
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
    /**
     * Filter which Transaction to delete.
     * 
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs = {
    /**
     * Filter which Transactions to delete
     * 
    **/
    where?: TransactionWhereInput
  }


  /**
   * Transaction without action
   */
  export type TransactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     * 
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
    unitPrice: number | null
  }

  export type ProductSumAggregateOutputType = {
    quantity: number | null
    price: number | null
    unitPrice: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    vendorId: string | null
    quantity: number | null
    vendorName: string | null
    vendorType: string | null
    name: string | null
    price: number | null
    unitPrice: number | null
    listedPublic: boolean | null
    description: string | null
    createdAt: Date | null
    currency: CurrencyEnum | null
    ecommercePlatform: EcommercePlatformEnum | null
    platformId: string | null
    affiliateId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    vendorId: string | null
    quantity: number | null
    vendorName: string | null
    vendorType: string | null
    name: string | null
    price: number | null
    unitPrice: number | null
    listedPublic: boolean | null
    description: string | null
    createdAt: Date | null
    currency: CurrencyEnum | null
    ecommercePlatform: EcommercePlatformEnum | null
    platformId: string | null
    affiliateId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    vendorId: number
    quantity: number
    vendorName: number
    vendorType: number
    name: number
    price: number
    unitPrice: number
    listedPublic: number
    description: number
    gallery: number
    categories: number
    createdAt: number
    currency: number
    ecommercePlatform: number
    platformId: number
    affiliateId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    quantity?: true
    price?: true
    unitPrice?: true
  }

  export type ProductSumAggregateInputType = {
    quantity?: true
    price?: true
    unitPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    vendorId?: true
    quantity?: true
    vendorName?: true
    vendorType?: true
    name?: true
    price?: true
    unitPrice?: true
    listedPublic?: true
    description?: true
    createdAt?: true
    currency?: true
    ecommercePlatform?: true
    platformId?: true
    affiliateId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    vendorId?: true
    quantity?: true
    vendorName?: true
    vendorType?: true
    name?: true
    price?: true
    unitPrice?: true
    listedPublic?: true
    description?: true
    createdAt?: true
    currency?: true
    ecommercePlatform?: true
    platformId?: true
    affiliateId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    vendorId?: true
    quantity?: true
    vendorName?: true
    vendorType?: true
    name?: true
    price?: true
    unitPrice?: true
    listedPublic?: true
    description?: true
    gallery?: true
    categories?: true
    createdAt?: true
    currency?: true
    ecommercePlatform?: true
    platformId?: true
    affiliateId?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    vendorId: string | null
    quantity: number | null
    vendorName: string | null
    vendorType: string | null
    name: string | null
    price: number | null
    unitPrice: number | null
    listedPublic: boolean | null
    description: string | null
    gallery: JsonValue | null
    categories: JsonValue | null
    createdAt: Date
    currency: CurrencyEnum | null
    ecommercePlatform: EcommercePlatformEnum | null
    platformId: string | null
    affiliateId: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    vendorId?: boolean
    quantity?: boolean
    vendorName?: boolean
    vendorType?: boolean
    name?: boolean
    price?: boolean
    unitPrice?: boolean
    listedPublic?: boolean
    description?: boolean
    gallery?: boolean
    categories?: boolean
    createdAt?: boolean
    currency?: boolean
    ecommercePlatform?: boolean
    platformId?: boolean
    affiliateId?: boolean
    affiliate?: boolean | UserArgs
    vendorWallet?: boolean | WalletArgs
  }

  export type ProductInclude = {
    affiliate?: boolean | UserArgs
    vendorWallet?: boolean | WalletArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]:
        P extends 'affiliate' ? UserGetPayload<S['include'][P]> | null :
        P extends 'vendorWallet' ? WalletGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'affiliate' ? UserGetPayload<S['select'][P]> | null :
        P extends 'vendorWallet' ? WalletGetPayload<S['select'][P]> | null :  P extends keyof Product ? Product[P] : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    affiliate<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    vendorWallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    amount: number | null
  }

  export type OrderSumAggregateOutputType = {
    amount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vendorId: string | null
    status: OrderStatusEnum | null
    notes: string | null
    name: string | null
    phoneNumber: string | null
    affiliateId: string | null
    deliveryCode: string | null
    createdAt: Date | null
    paymentStatus: PaymentStatusEnum | null
    amount: number | null
    paymentMethod: OrderPaymentMethodsEnum | null
    billingId: string | null
    shippingId: string | null
    ecommercePlatform: EcommercePlatformEnum | null
    currency: CurrencyEnum | null
    platformId: string | null
    customerId: string | null
    referenceNumber: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vendorId: string | null
    status: OrderStatusEnum | null
    notes: string | null
    name: string | null
    phoneNumber: string | null
    affiliateId: string | null
    deliveryCode: string | null
    createdAt: Date | null
    paymentStatus: PaymentStatusEnum | null
    amount: number | null
    paymentMethod: OrderPaymentMethodsEnum | null
    billingId: string | null
    shippingId: string | null
    ecommercePlatform: EcommercePlatformEnum | null
    currency: CurrencyEnum | null
    platformId: string | null
    customerId: string | null
    referenceNumber: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    vendorId: number
    status: number
    notes: number
    name: number
    phoneNumber: number
    affiliateId: number
    products: number
    items: number
    deliveryCode: number
    createdAt: number
    paymentStatus: number
    amount: number
    paymentMethod: number
    billingId: number
    shippingId: number
    ecommercePlatform: number
    currency: number
    platformId: number
    customerId: number
    referenceNumber: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    amount?: true
  }

  export type OrderSumAggregateInputType = {
    amount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    status?: true
    notes?: true
    name?: true
    phoneNumber?: true
    affiliateId?: true
    deliveryCode?: true
    createdAt?: true
    paymentStatus?: true
    amount?: true
    paymentMethod?: true
    billingId?: true
    shippingId?: true
    ecommercePlatform?: true
    currency?: true
    platformId?: true
    customerId?: true
    referenceNumber?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    status?: true
    notes?: true
    name?: true
    phoneNumber?: true
    affiliateId?: true
    deliveryCode?: true
    createdAt?: true
    paymentStatus?: true
    amount?: true
    paymentMethod?: true
    billingId?: true
    shippingId?: true
    ecommercePlatform?: true
    currency?: true
    platformId?: true
    customerId?: true
    referenceNumber?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    vendorId?: true
    status?: true
    notes?: true
    name?: true
    phoneNumber?: true
    affiliateId?: true
    products?: true
    items?: true
    deliveryCode?: true
    createdAt?: true
    paymentStatus?: true
    amount?: true
    paymentMethod?: true
    billingId?: true
    shippingId?: true
    ecommercePlatform?: true
    currency?: true
    platformId?: true
    customerId?: true
    referenceNumber?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: Array<OrderScalarFieldEnum>
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: string
    userId: string | null
    vendorId: string | null
    status: OrderStatusEnum | null
    notes: string | null
    name: string | null
    phoneNumber: string | null
    affiliateId: string | null
    products: JsonValue | null
    items: JsonValue | null
    deliveryCode: string | null
    createdAt: Date
    paymentStatus: PaymentStatusEnum
    amount: number
    paymentMethod: OrderPaymentMethodsEnum | null
    billingId: string | null
    shippingId: string | null
    ecommercePlatform: EcommercePlatformEnum | null
    currency: CurrencyEnum | null
    platformId: string | null
    customerId: string | null
    referenceNumber: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    userId?: boolean
    vendorId?: boolean
    status?: boolean
    notes?: boolean
    name?: boolean
    phoneNumber?: boolean
    affiliateId?: boolean
    products?: boolean
    items?: boolean
    deliveryCode?: boolean
    createdAt?: boolean
    paymentStatus?: boolean
    amount?: boolean
    paymentMethod?: boolean
    billingId?: boolean
    shippingId?: boolean
    ecommercePlatform?: boolean
    currency?: boolean
    platformId?: boolean
    customerId?: boolean
    referenceNumber?: boolean
    affiliate?: boolean | UserArgs
    billing?: boolean | BillingArgs
    customer?: boolean | WalletArgs
    shipping?: boolean | ShippingArgs
    user?: boolean | UserArgs
    vendorWallet?: boolean | WalletArgs
    credit?: boolean | CreditArgs
    installments?: boolean | InstallmentFindManyArgs
    creditRequest?: boolean | CreditRequestArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderInclude = {
    affiliate?: boolean | UserArgs
    billing?: boolean | BillingArgs
    customer?: boolean | WalletArgs
    shipping?: boolean | ShippingArgs
    user?: boolean | UserArgs
    vendorWallet?: boolean | WalletArgs
    credit?: boolean | CreditArgs
    installments?: boolean | InstallmentFindManyArgs
    creditRequest?: boolean | CreditRequestArgs
    _count?: boolean | OrderCountOutputTypeArgs
  }

  export type OrderGetPayload<
    S extends boolean | null | undefined | OrderArgs,
    U = keyof S
      > = S extends true
        ? Order
    : S extends undefined
    ? never
    : S extends OrderArgs | OrderFindManyArgs
    ?'include' extends U
    ? Order  & {
    [P in TrueKeys<S['include']>]:
        P extends 'affiliate' ? UserGetPayload<S['include'][P]> | null :
        P extends 'billing' ? BillingGetPayload<S['include'][P]> | null :
        P extends 'customer' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'shipping' ? ShippingGetPayload<S['include'][P]> | null :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'vendorWallet' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'credit' ? CreditGetPayload<S['include'][P]> | null :
        P extends 'installments' ? Array < InstallmentGetPayload<S['include'][P]>>  :
        P extends 'creditRequest' ? CreditRequestGetPayload<S['include'][P]> | null :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'affiliate' ? UserGetPayload<S['select'][P]> | null :
        P extends 'billing' ? BillingGetPayload<S['select'][P]> | null :
        P extends 'customer' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'shipping' ? ShippingGetPayload<S['select'][P]> | null :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'vendorWallet' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'credit' ? CreditGetPayload<S['select'][P]> | null :
        P extends 'installments' ? Array < InstallmentGetPayload<S['select'][P]>>  :
        P extends 'creditRequest' ? CreditRequestGetPayload<S['select'][P]> | null :
        P extends '_count' ? OrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Order ? Order[P] : never
  } 
    : Order
  : Order


  type OrderCountArgs = Merge<
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface OrderDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    affiliate<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    billing<T extends BillingArgs = {}>(args?: Subset<T, BillingArgs>): CheckSelect<T, Prisma__BillingClient<Billing | null >, Prisma__BillingClient<BillingGetPayload<T> | null >>;

    customer<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    shipping<T extends ShippingArgs = {}>(args?: Subset<T, ShippingArgs>): CheckSelect<T, Prisma__ShippingClient<Shipping | null >, Prisma__ShippingClient<ShippingGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    vendorWallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    credit<T extends CreditArgs = {}>(args?: Subset<T, CreditArgs>): CheckSelect<T, Prisma__CreditClient<Credit | null >, Prisma__CreditClient<CreditGetPayload<T> | null >>;

    installments<T extends InstallmentFindManyArgs = {}>(args?: Subset<T, InstallmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Installment>>, PrismaPromise<Array<InstallmentGetPayload<T>>>>;

    creditRequest<T extends CreditRequestArgs = {}>(args?: Subset<T, CreditRequestArgs>): CheckSelect<T, Prisma__CreditRequestClient<CreditRequest | null >, Prisma__CreditRequestClient<CreditRequestGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Throw an Error if a Order can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Throw an Error if a Order can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     * 
    **/
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     * 
    **/
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     * 
    **/
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     * 
    **/
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrderWhereInput
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
  }



  /**
   * Model Billing
   */


  export type AggregateBilling = {
    _count: BillingCountAggregateOutputType | null
    _min: BillingMinAggregateOutputType | null
    _max: BillingMaxAggregateOutputType | null
  }

  export type BillingMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    email: string | null
    phoneNumber: string | null
    walletId: string | null
  }

  export type BillingMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    email: string | null
    phoneNumber: string | null
    walletId: string | null
  }

  export type BillingCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    company: number
    address1: number
    address2: number
    city: number
    state: number
    postcode: number
    country: number
    email: number
    phoneNumber: number
    walletId: number
    _all: number
  }


  export type BillingMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    email?: true
    phoneNumber?: true
    walletId?: true
  }

  export type BillingMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    email?: true
    phoneNumber?: true
    walletId?: true
  }

  export type BillingCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    email?: true
    phoneNumber?: true
    walletId?: true
    _all?: true
  }

  export type BillingAggregateArgs = {
    /**
     * Filter which Billing to aggregate.
     * 
    **/
    where?: BillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billings to fetch.
     * 
    **/
    orderBy?: Enumerable<BillingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Billings
    **/
    _count?: true | BillingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingMaxAggregateInputType
  }

  export type GetBillingAggregateType<T extends BillingAggregateArgs> = {
        [P in keyof T & keyof AggregateBilling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilling[P]>
      : GetScalarType<T[P], AggregateBilling[P]>
  }




  export type BillingGroupByArgs = {
    where?: BillingWhereInput
    orderBy?: Enumerable<BillingOrderByWithAggregationInput>
    by: Array<BillingScalarFieldEnum>
    having?: BillingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingCountAggregateInputType | true
    _min?: BillingMinAggregateInputType
    _max?: BillingMaxAggregateInputType
  }


  export type BillingGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    email: string | null
    phoneNumber: string | null
    walletId: string | null
    _count: BillingCountAggregateOutputType | null
    _min: BillingMinAggregateOutputType | null
    _max: BillingMaxAggregateOutputType | null
  }

  type GetBillingGroupByPayload<T extends BillingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BillingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingGroupByOutputType[P]>
            : GetScalarType<T[P], BillingGroupByOutputType[P]>
        }
      >
    >


  export type BillingSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    address1?: boolean
    address2?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    country?: boolean
    email?: boolean
    phoneNumber?: boolean
    walletId?: boolean
    wallet?: boolean | WalletArgs
    order?: boolean | OrderFindManyArgs
    _count?: boolean | BillingCountOutputTypeArgs
  }

  export type BillingInclude = {
    wallet?: boolean | WalletArgs
    order?: boolean | OrderFindManyArgs
    _count?: boolean | BillingCountOutputTypeArgs
  }

  export type BillingGetPayload<
    S extends boolean | null | undefined | BillingArgs,
    U = keyof S
      > = S extends true
        ? Billing
    : S extends undefined
    ? never
    : S extends BillingArgs | BillingFindManyArgs
    ?'include' extends U
    ? Billing  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'order' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? BillingCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'order' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? BillingCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Billing ? Billing[P] : never
  } 
    : Billing
  : Billing


  type BillingCountArgs = Merge<
    Omit<BillingFindManyArgs, 'select' | 'include'> & {
      select?: BillingCountAggregateInputType | true
    }
  >

  export interface BillingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Billing that matches the filter.
     * @param {BillingFindUniqueArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BillingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BillingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Billing'> extends True ? CheckSelect<T, Prisma__BillingClient<Billing>, Prisma__BillingClient<BillingGetPayload<T>>> : CheckSelect<T, Prisma__BillingClient<Billing | null >, Prisma__BillingClient<BillingGetPayload<T> | null >>

    /**
     * Find the first Billing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingFindFirstArgs} args - Arguments to find a Billing
     * @example
     * // Get one Billing
     * const billing = await prisma.billing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BillingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BillingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Billing'> extends True ? CheckSelect<T, Prisma__BillingClient<Billing>, Prisma__BillingClient<BillingGetPayload<T>>> : CheckSelect<T, Prisma__BillingClient<Billing | null >, Prisma__BillingClient<BillingGetPayload<T> | null >>

    /**
     * Find zero or more Billings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billings
     * const billings = await prisma.billing.findMany()
     * 
     * // Get first 10 Billings
     * const billings = await prisma.billing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingWithIdOnly = await prisma.billing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BillingFindManyArgs>(
      args?: SelectSubset<T, BillingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Billing>>, PrismaPromise<Array<BillingGetPayload<T>>>>

    /**
     * Create a Billing.
     * @param {BillingCreateArgs} args - Arguments to create a Billing.
     * @example
     * // Create one Billing
     * const Billing = await prisma.billing.create({
     *   data: {
     *     // ... data to create a Billing
     *   }
     * })
     * 
    **/
    create<T extends BillingCreateArgs>(
      args: SelectSubset<T, BillingCreateArgs>
    ): CheckSelect<T, Prisma__BillingClient<Billing>, Prisma__BillingClient<BillingGetPayload<T>>>

    /**
     * Create many Billings.
     *     @param {BillingCreateManyArgs} args - Arguments to create many Billings.
     *     @example
     *     // Create many Billings
     *     const billing = await prisma.billing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BillingCreateManyArgs>(
      args?: SelectSubset<T, BillingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Billing.
     * @param {BillingDeleteArgs} args - Arguments to delete one Billing.
     * @example
     * // Delete one Billing
     * const Billing = await prisma.billing.delete({
     *   where: {
     *     // ... filter to delete one Billing
     *   }
     * })
     * 
    **/
    delete<T extends BillingDeleteArgs>(
      args: SelectSubset<T, BillingDeleteArgs>
    ): CheckSelect<T, Prisma__BillingClient<Billing>, Prisma__BillingClient<BillingGetPayload<T>>>

    /**
     * Update one Billing.
     * @param {BillingUpdateArgs} args - Arguments to update one Billing.
     * @example
     * // Update one Billing
     * const billing = await prisma.billing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BillingUpdateArgs>(
      args: SelectSubset<T, BillingUpdateArgs>
    ): CheckSelect<T, Prisma__BillingClient<Billing>, Prisma__BillingClient<BillingGetPayload<T>>>

    /**
     * Delete zero or more Billings.
     * @param {BillingDeleteManyArgs} args - Arguments to filter Billings to delete.
     * @example
     * // Delete a few Billings
     * const { count } = await prisma.billing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BillingDeleteManyArgs>(
      args?: SelectSubset<T, BillingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billings
     * const billing = await prisma.billing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BillingUpdateManyArgs>(
      args: SelectSubset<T, BillingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Billing.
     * @param {BillingUpsertArgs} args - Arguments to update or create a Billing.
     * @example
     * // Update or create a Billing
     * const billing = await prisma.billing.upsert({
     *   create: {
     *     // ... data to create a Billing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billing we want to update
     *   }
     * })
    **/
    upsert<T extends BillingUpsertArgs>(
      args: SelectSubset<T, BillingUpsertArgs>
    ): CheckSelect<T, Prisma__BillingClient<Billing>, Prisma__BillingClient<BillingGetPayload<T>>>

    /**
     * Count the number of Billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingCountArgs} args - Arguments to filter Billings to count.
     * @example
     * // Count the number of Billings
     * const count = await prisma.billing.count({
     *   where: {
     *     // ... the filter for the Billings we want to count
     *   }
     * })
    **/
    count<T extends BillingCountArgs>(
      args?: Subset<T, BillingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingAggregateArgs>(args: Subset<T, BillingAggregateArgs>): PrismaPromise<GetBillingAggregateType<T>>

    /**
     * Group by Billing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingGroupByArgs['orderBy'] }
        : { orderBy?: BillingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Billing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BillingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    order<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Billing findUnique
   */
  export type BillingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Billing
     * 
    **/
    select?: BillingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillingInclude | null
    /**
     * Throw an Error if a Billing can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Billing to fetch.
     * 
    **/
    where: BillingWhereUniqueInput
  }


  /**
   * Billing findFirst
   */
  export type BillingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Billing
     * 
    **/
    select?: BillingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillingInclude | null
    /**
     * Throw an Error if a Billing can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Billing to fetch.
     * 
    **/
    where?: BillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billings to fetch.
     * 
    **/
    orderBy?: Enumerable<BillingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billings.
     * 
    **/
    cursor?: BillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billings.
     * 
    **/
    distinct?: Enumerable<BillingScalarFieldEnum>
  }


  /**
   * Billing findMany
   */
  export type BillingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Billing
     * 
    **/
    select?: BillingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillingInclude | null
    /**
     * Filter, which Billings to fetch.
     * 
    **/
    where?: BillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billings to fetch.
     * 
    **/
    orderBy?: Enumerable<BillingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Billings.
     * 
    **/
    cursor?: BillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BillingScalarFieldEnum>
  }


  /**
   * Billing create
   */
  export type BillingCreateArgs = {
    /**
     * Select specific fields to fetch from the Billing
     * 
    **/
    select?: BillingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillingInclude | null
    /**
     * The data needed to create a Billing.
     * 
    **/
    data: XOR<BillingCreateInput, BillingUncheckedCreateInput>
  }


  /**
   * Billing createMany
   */
  export type BillingCreateManyArgs = {
    /**
     * The data used to create many Billings.
     * 
    **/
    data: Enumerable<BillingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Billing update
   */
  export type BillingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Billing
     * 
    **/
    select?: BillingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillingInclude | null
    /**
     * The data needed to update a Billing.
     * 
    **/
    data: XOR<BillingUpdateInput, BillingUncheckedUpdateInput>
    /**
     * Choose, which Billing to update.
     * 
    **/
    where: BillingWhereUniqueInput
  }


  /**
   * Billing updateMany
   */
  export type BillingUpdateManyArgs = {
    /**
     * The data used to update Billings.
     * 
    **/
    data: XOR<BillingUpdateManyMutationInput, BillingUncheckedUpdateManyInput>
    /**
     * Filter which Billings to update
     * 
    **/
    where?: BillingWhereInput
  }


  /**
   * Billing upsert
   */
  export type BillingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Billing
     * 
    **/
    select?: BillingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillingInclude | null
    /**
     * The filter to search for the Billing to update in case it exists.
     * 
    **/
    where: BillingWhereUniqueInput
    /**
     * In case the Billing found by the `where` argument doesn't exist, create a new Billing with this data.
     * 
    **/
    create: XOR<BillingCreateInput, BillingUncheckedCreateInput>
    /**
     * In case the Billing was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BillingUpdateInput, BillingUncheckedUpdateInput>
  }


  /**
   * Billing delete
   */
  export type BillingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Billing
     * 
    **/
    select?: BillingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillingInclude | null
    /**
     * Filter which Billing to delete.
     * 
    **/
    where: BillingWhereUniqueInput
  }


  /**
   * Billing deleteMany
   */
  export type BillingDeleteManyArgs = {
    /**
     * Filter which Billings to delete
     * 
    **/
    where?: BillingWhereInput
  }


  /**
   * Billing without action
   */
  export type BillingArgs = {
    /**
     * Select specific fields to fetch from the Billing
     * 
    **/
    select?: BillingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillingInclude | null
  }



  /**
   * Model BuyerContacts
   */


  export type AggregateBuyerContacts = {
    _count: BuyerContactsCountAggregateOutputType | null
    _min: BuyerContactsMinAggregateOutputType | null
    _max: BuyerContactsMaxAggregateOutputType | null
  }

  export type BuyerContactsMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    name: string | null
    phoneNumber: string | null
    createdAt: Date | null
  }

  export type BuyerContactsMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    name: string | null
    phoneNumber: string | null
    createdAt: Date | null
  }

  export type BuyerContactsCountAggregateOutputType = {
    id: number
    walletId: number
    name: number
    phoneNumber: number
    createdAt: number
    _all: number
  }


  export type BuyerContactsMinAggregateInputType = {
    id?: true
    walletId?: true
    name?: true
    phoneNumber?: true
    createdAt?: true
  }

  export type BuyerContactsMaxAggregateInputType = {
    id?: true
    walletId?: true
    name?: true
    phoneNumber?: true
    createdAt?: true
  }

  export type BuyerContactsCountAggregateInputType = {
    id?: true
    walletId?: true
    name?: true
    phoneNumber?: true
    createdAt?: true
    _all?: true
  }

  export type BuyerContactsAggregateArgs = {
    /**
     * Filter which BuyerContacts to aggregate.
     * 
    **/
    where?: BuyerContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyerContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<BuyerContactsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BuyerContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyerContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyerContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuyerContacts
    **/
    _count?: true | BuyerContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuyerContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuyerContactsMaxAggregateInputType
  }

  export type GetBuyerContactsAggregateType<T extends BuyerContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateBuyerContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuyerContacts[P]>
      : GetScalarType<T[P], AggregateBuyerContacts[P]>
  }




  export type BuyerContactsGroupByArgs = {
    where?: BuyerContactsWhereInput
    orderBy?: Enumerable<BuyerContactsOrderByWithAggregationInput>
    by: Array<BuyerContactsScalarFieldEnum>
    having?: BuyerContactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuyerContactsCountAggregateInputType | true
    _min?: BuyerContactsMinAggregateInputType
    _max?: BuyerContactsMaxAggregateInputType
  }


  export type BuyerContactsGroupByOutputType = {
    id: string
    walletId: string
    name: string
    phoneNumber: string
    createdAt: Date
    _count: BuyerContactsCountAggregateOutputType | null
    _min: BuyerContactsMinAggregateOutputType | null
    _max: BuyerContactsMaxAggregateOutputType | null
  }

  type GetBuyerContactsGroupByPayload<T extends BuyerContactsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BuyerContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuyerContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuyerContactsGroupByOutputType[P]>
            : GetScalarType<T[P], BuyerContactsGroupByOutputType[P]>
        }
      >
    >


  export type BuyerContactsSelect = {
    id?: boolean
    walletId?: boolean
    name?: boolean
    phoneNumber?: boolean
    createdAt?: boolean
  }

  export type BuyerContactsGetPayload<
    S extends boolean | null | undefined | BuyerContactsArgs,
    U = keyof S
      > = S extends true
        ? BuyerContacts
    : S extends undefined
    ? never
    : S extends BuyerContactsArgs | BuyerContactsFindManyArgs
    ?'include' extends U
    ? BuyerContacts 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BuyerContacts ? BuyerContacts[P] : never
  } 
    : BuyerContacts
  : BuyerContacts


  type BuyerContactsCountArgs = Merge<
    Omit<BuyerContactsFindManyArgs, 'select' | 'include'> & {
      select?: BuyerContactsCountAggregateInputType | true
    }
  >

  export interface BuyerContactsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one BuyerContacts that matches the filter.
     * @param {BuyerContactsFindUniqueArgs} args - Arguments to find a BuyerContacts
     * @example
     * // Get one BuyerContacts
     * const buyerContacts = await prisma.buyerContacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuyerContactsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BuyerContactsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BuyerContacts'> extends True ? CheckSelect<T, Prisma__BuyerContactsClient<BuyerContacts>, Prisma__BuyerContactsClient<BuyerContactsGetPayload<T>>> : CheckSelect<T, Prisma__BuyerContactsClient<BuyerContacts | null >, Prisma__BuyerContactsClient<BuyerContactsGetPayload<T> | null >>

    /**
     * Find the first BuyerContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerContactsFindFirstArgs} args - Arguments to find a BuyerContacts
     * @example
     * // Get one BuyerContacts
     * const buyerContacts = await prisma.buyerContacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuyerContactsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BuyerContactsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BuyerContacts'> extends True ? CheckSelect<T, Prisma__BuyerContactsClient<BuyerContacts>, Prisma__BuyerContactsClient<BuyerContactsGetPayload<T>>> : CheckSelect<T, Prisma__BuyerContactsClient<BuyerContacts | null >, Prisma__BuyerContactsClient<BuyerContactsGetPayload<T> | null >>

    /**
     * Find zero or more BuyerContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerContactsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuyerContacts
     * const buyerContacts = await prisma.buyerContacts.findMany()
     * 
     * // Get first 10 BuyerContacts
     * const buyerContacts = await prisma.buyerContacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buyerContactsWithIdOnly = await prisma.buyerContacts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuyerContactsFindManyArgs>(
      args?: SelectSubset<T, BuyerContactsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<BuyerContacts>>, PrismaPromise<Array<BuyerContactsGetPayload<T>>>>

    /**
     * Create a BuyerContacts.
     * @param {BuyerContactsCreateArgs} args - Arguments to create a BuyerContacts.
     * @example
     * // Create one BuyerContacts
     * const BuyerContacts = await prisma.buyerContacts.create({
     *   data: {
     *     // ... data to create a BuyerContacts
     *   }
     * })
     * 
    **/
    create<T extends BuyerContactsCreateArgs>(
      args: SelectSubset<T, BuyerContactsCreateArgs>
    ): CheckSelect<T, Prisma__BuyerContactsClient<BuyerContacts>, Prisma__BuyerContactsClient<BuyerContactsGetPayload<T>>>

    /**
     * Create many BuyerContacts.
     *     @param {BuyerContactsCreateManyArgs} args - Arguments to create many BuyerContacts.
     *     @example
     *     // Create many BuyerContacts
     *     const buyerContacts = await prisma.buyerContacts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuyerContactsCreateManyArgs>(
      args?: SelectSubset<T, BuyerContactsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BuyerContacts.
     * @param {BuyerContactsDeleteArgs} args - Arguments to delete one BuyerContacts.
     * @example
     * // Delete one BuyerContacts
     * const BuyerContacts = await prisma.buyerContacts.delete({
     *   where: {
     *     // ... filter to delete one BuyerContacts
     *   }
     * })
     * 
    **/
    delete<T extends BuyerContactsDeleteArgs>(
      args: SelectSubset<T, BuyerContactsDeleteArgs>
    ): CheckSelect<T, Prisma__BuyerContactsClient<BuyerContacts>, Prisma__BuyerContactsClient<BuyerContactsGetPayload<T>>>

    /**
     * Update one BuyerContacts.
     * @param {BuyerContactsUpdateArgs} args - Arguments to update one BuyerContacts.
     * @example
     * // Update one BuyerContacts
     * const buyerContacts = await prisma.buyerContacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuyerContactsUpdateArgs>(
      args: SelectSubset<T, BuyerContactsUpdateArgs>
    ): CheckSelect<T, Prisma__BuyerContactsClient<BuyerContacts>, Prisma__BuyerContactsClient<BuyerContactsGetPayload<T>>>

    /**
     * Delete zero or more BuyerContacts.
     * @param {BuyerContactsDeleteManyArgs} args - Arguments to filter BuyerContacts to delete.
     * @example
     * // Delete a few BuyerContacts
     * const { count } = await prisma.buyerContacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuyerContactsDeleteManyArgs>(
      args?: SelectSubset<T, BuyerContactsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuyerContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerContactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuyerContacts
     * const buyerContacts = await prisma.buyerContacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuyerContactsUpdateManyArgs>(
      args: SelectSubset<T, BuyerContactsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BuyerContacts.
     * @param {BuyerContactsUpsertArgs} args - Arguments to update or create a BuyerContacts.
     * @example
     * // Update or create a BuyerContacts
     * const buyerContacts = await prisma.buyerContacts.upsert({
     *   create: {
     *     // ... data to create a BuyerContacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuyerContacts we want to update
     *   }
     * })
    **/
    upsert<T extends BuyerContactsUpsertArgs>(
      args: SelectSubset<T, BuyerContactsUpsertArgs>
    ): CheckSelect<T, Prisma__BuyerContactsClient<BuyerContacts>, Prisma__BuyerContactsClient<BuyerContactsGetPayload<T>>>

    /**
     * Count the number of BuyerContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerContactsCountArgs} args - Arguments to filter BuyerContacts to count.
     * @example
     * // Count the number of BuyerContacts
     * const count = await prisma.buyerContacts.count({
     *   where: {
     *     // ... the filter for the BuyerContacts we want to count
     *   }
     * })
    **/
    count<T extends BuyerContactsCountArgs>(
      args?: Subset<T, BuyerContactsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuyerContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuyerContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuyerContactsAggregateArgs>(args: Subset<T, BuyerContactsAggregateArgs>): PrismaPromise<GetBuyerContactsAggregateType<T>>

    /**
     * Group by BuyerContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerContactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuyerContactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuyerContactsGroupByArgs['orderBy'] }
        : { orderBy?: BuyerContactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuyerContactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuyerContactsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuyerContacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BuyerContactsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * BuyerContacts findUnique
   */
  export type BuyerContactsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the BuyerContacts
     * 
    **/
    select?: BuyerContactsSelect | null
    /**
     * Throw an Error if a BuyerContacts can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BuyerContacts to fetch.
     * 
    **/
    where: BuyerContactsWhereUniqueInput
  }


  /**
   * BuyerContacts findFirst
   */
  export type BuyerContactsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the BuyerContacts
     * 
    **/
    select?: BuyerContactsSelect | null
    /**
     * Throw an Error if a BuyerContacts can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BuyerContacts to fetch.
     * 
    **/
    where?: BuyerContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyerContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<BuyerContactsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuyerContacts.
     * 
    **/
    cursor?: BuyerContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyerContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyerContacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuyerContacts.
     * 
    **/
    distinct?: Enumerable<BuyerContactsScalarFieldEnum>
  }


  /**
   * BuyerContacts findMany
   */
  export type BuyerContactsFindManyArgs = {
    /**
     * Select specific fields to fetch from the BuyerContacts
     * 
    **/
    select?: BuyerContactsSelect | null
    /**
     * Filter, which BuyerContacts to fetch.
     * 
    **/
    where?: BuyerContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyerContacts to fetch.
     * 
    **/
    orderBy?: Enumerable<BuyerContactsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuyerContacts.
     * 
    **/
    cursor?: BuyerContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyerContacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyerContacts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BuyerContactsScalarFieldEnum>
  }


  /**
   * BuyerContacts create
   */
  export type BuyerContactsCreateArgs = {
    /**
     * Select specific fields to fetch from the BuyerContacts
     * 
    **/
    select?: BuyerContactsSelect | null
    /**
     * The data needed to create a BuyerContacts.
     * 
    **/
    data: XOR<BuyerContactsCreateInput, BuyerContactsUncheckedCreateInput>
  }


  /**
   * BuyerContacts createMany
   */
  export type BuyerContactsCreateManyArgs = {
    /**
     * The data used to create many BuyerContacts.
     * 
    **/
    data: Enumerable<BuyerContactsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BuyerContacts update
   */
  export type BuyerContactsUpdateArgs = {
    /**
     * Select specific fields to fetch from the BuyerContacts
     * 
    **/
    select?: BuyerContactsSelect | null
    /**
     * The data needed to update a BuyerContacts.
     * 
    **/
    data: XOR<BuyerContactsUpdateInput, BuyerContactsUncheckedUpdateInput>
    /**
     * Choose, which BuyerContacts to update.
     * 
    **/
    where: BuyerContactsWhereUniqueInput
  }


  /**
   * BuyerContacts updateMany
   */
  export type BuyerContactsUpdateManyArgs = {
    /**
     * The data used to update BuyerContacts.
     * 
    **/
    data: XOR<BuyerContactsUpdateManyMutationInput, BuyerContactsUncheckedUpdateManyInput>
    /**
     * Filter which BuyerContacts to update
     * 
    **/
    where?: BuyerContactsWhereInput
  }


  /**
   * BuyerContacts upsert
   */
  export type BuyerContactsUpsertArgs = {
    /**
     * Select specific fields to fetch from the BuyerContacts
     * 
    **/
    select?: BuyerContactsSelect | null
    /**
     * The filter to search for the BuyerContacts to update in case it exists.
     * 
    **/
    where: BuyerContactsWhereUniqueInput
    /**
     * In case the BuyerContacts found by the `where` argument doesn't exist, create a new BuyerContacts with this data.
     * 
    **/
    create: XOR<BuyerContactsCreateInput, BuyerContactsUncheckedCreateInput>
    /**
     * In case the BuyerContacts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BuyerContactsUpdateInput, BuyerContactsUncheckedUpdateInput>
  }


  /**
   * BuyerContacts delete
   */
  export type BuyerContactsDeleteArgs = {
    /**
     * Select specific fields to fetch from the BuyerContacts
     * 
    **/
    select?: BuyerContactsSelect | null
    /**
     * Filter which BuyerContacts to delete.
     * 
    **/
    where: BuyerContactsWhereUniqueInput
  }


  /**
   * BuyerContacts deleteMany
   */
  export type BuyerContactsDeleteManyArgs = {
    /**
     * Filter which BuyerContacts to delete
     * 
    **/
    where?: BuyerContactsWhereInput
  }


  /**
   * BuyerContacts without action
   */
  export type BuyerContactsArgs = {
    /**
     * Select specific fields to fetch from the BuyerContacts
     * 
    **/
    select?: BuyerContactsSelect | null
  }



  /**
   * Model Shipping
   */


  export type AggregateShipping = {
    _count: ShippingCountAggregateOutputType | null
    _avg: ShippingAvgAggregateOutputType | null
    _sum: ShippingSumAggregateOutputType | null
    _min: ShippingMinAggregateOutputType | null
    _max: ShippingMaxAggregateOutputType | null
  }

  export type ShippingAvgAggregateOutputType = {
    shippingFee: number | null
  }

  export type ShippingSumAggregateOutputType = {
    shippingFee: number | null
  }

  export type ShippingMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    email: string | null
    longitude: string | null
    shippingType: ShippingTypeEnum | null
    shippingFee: number | null
    latitude: string | null
    phoneNumber: string | null
    walletId: string | null
    isDefault: boolean | null
    seviVerified: boolean | null
    createdAt: Date | null
  }

  export type ShippingMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    email: string | null
    longitude: string | null
    shippingType: ShippingTypeEnum | null
    shippingFee: number | null
    latitude: string | null
    phoneNumber: string | null
    walletId: string | null
    isDefault: boolean | null
    seviVerified: boolean | null
    createdAt: Date | null
  }

  export type ShippingCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    company: number
    address1: number
    address2: number
    city: number
    state: number
    postcode: number
    country: number
    email: number
    longitude: number
    shippingType: number
    shippingFee: number
    latitude: number
    phoneNumber: number
    walletId: number
    isDefault: number
    seviVerified: number
    createdAt: number
    _all: number
  }


  export type ShippingAvgAggregateInputType = {
    shippingFee?: true
  }

  export type ShippingSumAggregateInputType = {
    shippingFee?: true
  }

  export type ShippingMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    email?: true
    longitude?: true
    shippingType?: true
    shippingFee?: true
    latitude?: true
    phoneNumber?: true
    walletId?: true
    isDefault?: true
    seviVerified?: true
    createdAt?: true
  }

  export type ShippingMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    email?: true
    longitude?: true
    shippingType?: true
    shippingFee?: true
    latitude?: true
    phoneNumber?: true
    walletId?: true
    isDefault?: true
    seviVerified?: true
    createdAt?: true
  }

  export type ShippingCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    company?: true
    address1?: true
    address2?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    email?: true
    longitude?: true
    shippingType?: true
    shippingFee?: true
    latitude?: true
    phoneNumber?: true
    walletId?: true
    isDefault?: true
    seviVerified?: true
    createdAt?: true
    _all?: true
  }

  export type ShippingAggregateArgs = {
    /**
     * Filter which Shipping to aggregate.
     * 
    **/
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shippings
    **/
    _count?: true | ShippingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingMaxAggregateInputType
  }

  export type GetShippingAggregateType<T extends ShippingAggregateArgs> = {
        [P in keyof T & keyof AggregateShipping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipping[P]>
      : GetScalarType<T[P], AggregateShipping[P]>
  }




  export type ShippingGroupByArgs = {
    where?: ShippingWhereInput
    orderBy?: Enumerable<ShippingOrderByWithAggregationInput>
    by: Array<ShippingScalarFieldEnum>
    having?: ShippingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingCountAggregateInputType | true
    _avg?: ShippingAvgAggregateInputType
    _sum?: ShippingSumAggregateInputType
    _min?: ShippingMinAggregateInputType
    _max?: ShippingMaxAggregateInputType
  }


  export type ShippingGroupByOutputType = {
    id: string
    firstName: string | null
    lastName: string | null
    company: string | null
    address1: string | null
    address2: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    email: string | null
    longitude: string | null
    shippingType: ShippingTypeEnum | null
    shippingFee: number | null
    latitude: string | null
    phoneNumber: string | null
    walletId: string | null
    isDefault: boolean | null
    seviVerified: boolean | null
    createdAt: Date | null
    _count: ShippingCountAggregateOutputType | null
    _avg: ShippingAvgAggregateOutputType | null
    _sum: ShippingSumAggregateOutputType | null
    _min: ShippingMinAggregateOutputType | null
    _max: ShippingMaxAggregateOutputType | null
  }

  type GetShippingGroupByPayload<T extends ShippingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShippingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingGroupByOutputType[P]>
        }
      >
    >


  export type ShippingSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    address1?: boolean
    address2?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    country?: boolean
    email?: boolean
    longitude?: boolean
    shippingType?: boolean
    shippingFee?: boolean
    latitude?: boolean
    phoneNumber?: boolean
    walletId?: boolean
    isDefault?: boolean
    seviVerified?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletArgs
    Order?: boolean | OrderFindManyArgs
    _count?: boolean | ShippingCountOutputTypeArgs
  }

  export type ShippingInclude = {
    wallet?: boolean | WalletArgs
    Order?: boolean | OrderFindManyArgs
    _count?: boolean | ShippingCountOutputTypeArgs
  }

  export type ShippingGetPayload<
    S extends boolean | null | undefined | ShippingArgs,
    U = keyof S
      > = S extends true
        ? Shipping
    : S extends undefined
    ? never
    : S extends ShippingArgs | ShippingFindManyArgs
    ?'include' extends U
    ? Shipping  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'Order' ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends '_count' ? ShippingCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'Order' ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends '_count' ? ShippingCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Shipping ? Shipping[P] : never
  } 
    : Shipping
  : Shipping


  type ShippingCountArgs = Merge<
    Omit<ShippingFindManyArgs, 'select' | 'include'> & {
      select?: ShippingCountAggregateInputType | true
    }
  >

  export interface ShippingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Shipping that matches the filter.
     * @param {ShippingFindUniqueArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShippingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShippingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Shipping'> extends True ? CheckSelect<T, Prisma__ShippingClient<Shipping>, Prisma__ShippingClient<ShippingGetPayload<T>>> : CheckSelect<T, Prisma__ShippingClient<Shipping | null >, Prisma__ShippingClient<ShippingGetPayload<T> | null >>

    /**
     * Find the first Shipping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingFindFirstArgs} args - Arguments to find a Shipping
     * @example
     * // Get one Shipping
     * const shipping = await prisma.shipping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShippingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShippingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Shipping'> extends True ? CheckSelect<T, Prisma__ShippingClient<Shipping>, Prisma__ShippingClient<ShippingGetPayload<T>>> : CheckSelect<T, Prisma__ShippingClient<Shipping | null >, Prisma__ShippingClient<ShippingGetPayload<T> | null >>

    /**
     * Find zero or more Shippings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shippings
     * const shippings = await prisma.shipping.findMany()
     * 
     * // Get first 10 Shippings
     * const shippings = await prisma.shipping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingWithIdOnly = await prisma.shipping.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShippingFindManyArgs>(
      args?: SelectSubset<T, ShippingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Shipping>>, PrismaPromise<Array<ShippingGetPayload<T>>>>

    /**
     * Create a Shipping.
     * @param {ShippingCreateArgs} args - Arguments to create a Shipping.
     * @example
     * // Create one Shipping
     * const Shipping = await prisma.shipping.create({
     *   data: {
     *     // ... data to create a Shipping
     *   }
     * })
     * 
    **/
    create<T extends ShippingCreateArgs>(
      args: SelectSubset<T, ShippingCreateArgs>
    ): CheckSelect<T, Prisma__ShippingClient<Shipping>, Prisma__ShippingClient<ShippingGetPayload<T>>>

    /**
     * Create many Shippings.
     *     @param {ShippingCreateManyArgs} args - Arguments to create many Shippings.
     *     @example
     *     // Create many Shippings
     *     const shipping = await prisma.shipping.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShippingCreateManyArgs>(
      args?: SelectSubset<T, ShippingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Shipping.
     * @param {ShippingDeleteArgs} args - Arguments to delete one Shipping.
     * @example
     * // Delete one Shipping
     * const Shipping = await prisma.shipping.delete({
     *   where: {
     *     // ... filter to delete one Shipping
     *   }
     * })
     * 
    **/
    delete<T extends ShippingDeleteArgs>(
      args: SelectSubset<T, ShippingDeleteArgs>
    ): CheckSelect<T, Prisma__ShippingClient<Shipping>, Prisma__ShippingClient<ShippingGetPayload<T>>>

    /**
     * Update one Shipping.
     * @param {ShippingUpdateArgs} args - Arguments to update one Shipping.
     * @example
     * // Update one Shipping
     * const shipping = await prisma.shipping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShippingUpdateArgs>(
      args: SelectSubset<T, ShippingUpdateArgs>
    ): CheckSelect<T, Prisma__ShippingClient<Shipping>, Prisma__ShippingClient<ShippingGetPayload<T>>>

    /**
     * Delete zero or more Shippings.
     * @param {ShippingDeleteManyArgs} args - Arguments to filter Shippings to delete.
     * @example
     * // Delete a few Shippings
     * const { count } = await prisma.shipping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShippingDeleteManyArgs>(
      args?: SelectSubset<T, ShippingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shippings
     * const shipping = await prisma.shipping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShippingUpdateManyArgs>(
      args: SelectSubset<T, ShippingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Shipping.
     * @param {ShippingUpsertArgs} args - Arguments to update or create a Shipping.
     * @example
     * // Update or create a Shipping
     * const shipping = await prisma.shipping.upsert({
     *   create: {
     *     // ... data to create a Shipping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipping we want to update
     *   }
     * })
    **/
    upsert<T extends ShippingUpsertArgs>(
      args: SelectSubset<T, ShippingUpsertArgs>
    ): CheckSelect<T, Prisma__ShippingClient<Shipping>, Prisma__ShippingClient<ShippingGetPayload<T>>>

    /**
     * Count the number of Shippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingCountArgs} args - Arguments to filter Shippings to count.
     * @example
     * // Count the number of Shippings
     * const count = await prisma.shipping.count({
     *   where: {
     *     // ... the filter for the Shippings we want to count
     *   }
     * })
    **/
    count<T extends ShippingCountArgs>(
      args?: Subset<T, ShippingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingAggregateArgs>(args: Subset<T, ShippingAggregateArgs>): PrismaPromise<GetShippingAggregateType<T>>

    /**
     * Group by Shipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingGroupByArgs['orderBy'] }
        : { orderBy?: ShippingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShippingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    Order<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Shipping findUnique
   */
  export type ShippingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Shipping
     * 
    **/
    select?: ShippingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingInclude | null
    /**
     * Throw an Error if a Shipping can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Shipping to fetch.
     * 
    **/
    where: ShippingWhereUniqueInput
  }


  /**
   * Shipping findFirst
   */
  export type ShippingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Shipping
     * 
    **/
    select?: ShippingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingInclude | null
    /**
     * Throw an Error if a Shipping can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Shipping to fetch.
     * 
    **/
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shippings.
     * 
    **/
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shippings.
     * 
    **/
    distinct?: Enumerable<ShippingScalarFieldEnum>
  }


  /**
   * Shipping findMany
   */
  export type ShippingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Shipping
     * 
    **/
    select?: ShippingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingInclude | null
    /**
     * Filter, which Shippings to fetch.
     * 
    **/
    where?: ShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shippings to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shippings.
     * 
    **/
    cursor?: ShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shippings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shippings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShippingScalarFieldEnum>
  }


  /**
   * Shipping create
   */
  export type ShippingCreateArgs = {
    /**
     * Select specific fields to fetch from the Shipping
     * 
    **/
    select?: ShippingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingInclude | null
    /**
     * The data needed to create a Shipping.
     * 
    **/
    data: XOR<ShippingCreateInput, ShippingUncheckedCreateInput>
  }


  /**
   * Shipping createMany
   */
  export type ShippingCreateManyArgs = {
    /**
     * The data used to create many Shippings.
     * 
    **/
    data: Enumerable<ShippingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Shipping update
   */
  export type ShippingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Shipping
     * 
    **/
    select?: ShippingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingInclude | null
    /**
     * The data needed to update a Shipping.
     * 
    **/
    data: XOR<ShippingUpdateInput, ShippingUncheckedUpdateInput>
    /**
     * Choose, which Shipping to update.
     * 
    **/
    where: ShippingWhereUniqueInput
  }


  /**
   * Shipping updateMany
   */
  export type ShippingUpdateManyArgs = {
    /**
     * The data used to update Shippings.
     * 
    **/
    data: XOR<ShippingUpdateManyMutationInput, ShippingUncheckedUpdateManyInput>
    /**
     * Filter which Shippings to update
     * 
    **/
    where?: ShippingWhereInput
  }


  /**
   * Shipping upsert
   */
  export type ShippingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Shipping
     * 
    **/
    select?: ShippingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingInclude | null
    /**
     * The filter to search for the Shipping to update in case it exists.
     * 
    **/
    where: ShippingWhereUniqueInput
    /**
     * In case the Shipping found by the `where` argument doesn't exist, create a new Shipping with this data.
     * 
    **/
    create: XOR<ShippingCreateInput, ShippingUncheckedCreateInput>
    /**
     * In case the Shipping was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShippingUpdateInput, ShippingUncheckedUpdateInput>
  }


  /**
   * Shipping delete
   */
  export type ShippingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Shipping
     * 
    **/
    select?: ShippingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingInclude | null
    /**
     * Filter which Shipping to delete.
     * 
    **/
    where: ShippingWhereUniqueInput
  }


  /**
   * Shipping deleteMany
   */
  export type ShippingDeleteManyArgs = {
    /**
     * Filter which Shippings to delete
     * 
    **/
    where?: ShippingWhereInput
  }


  /**
   * Shipping without action
   */
  export type ShippingArgs = {
    /**
     * Select specific fields to fetch from the Shipping
     * 
    **/
    select?: ShippingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingInclude | null
  }



  /**
   * Model Credit
   */


  export type AggregateCredit = {
    _count: CreditCountAggregateOutputType | null
    _avg: CreditAvgAggregateOutputType | null
    _sum: CreditSumAggregateOutputType | null
    _min: CreditMinAggregateOutputType | null
    _max: CreditMaxAggregateOutputType | null
  }

  export type CreditAvgAggregateOutputType = {
    amount: number | null
    installmentsCount: number | null
    installmentsCountPaid: number | null
    totalPaid: number | null
    totalToPay: number | null
    duration: number | null
    fundUpfrontAmount: number | null
    fundFeesAmount: number | null
    amountWithFees: number | null
    seviFeesAmount: number | null
    orderWalletShareFeesAmount: number | null
    fundPostDeliveryAmount: number | null
  }

  export type CreditSumAggregateOutputType = {
    amount: number | null
    installmentsCount: number | null
    installmentsCountPaid: number | null
    totalPaid: number | null
    totalToPay: number | null
    duration: number | null
    fundUpfrontAmount: number | null
    fundFeesAmount: number | null
    amountWithFees: number | null
    seviFeesAmount: number | null
    orderWalletShareFeesAmount: number | null
    fundPostDeliveryAmount: number | null
  }

  export type CreditMinAggregateOutputType = {
    id: string | null
    typeId: string | null
    currency: CurrencyEnum | null
    orderId: string | null
    type: creditRefType | null
    amount: number | null
    debtorId: string | null
    creditorId: string | null
    installmentsCount: number | null
    installmentsCountPaid: number | null
    status: creditStatusEnum | null
    description: string | null
    totalPaid: number | null
    totalToPay: number | null
    agreedDate: Date | null
    userId: string | null
    createdAt: Date | null
    referenceNumber: string | null
    creditConfigurationId: string | null
    endDate: Date | null
    paidAt: Date | null
    duration: number | null
    durationSlices: SlicesEnum | null
    affiliateId: string | null
    defaultAt: Date | null
    fundUpfrontAmount: number | null
    orderWalletId: string | null
    fundFeesAmount: number | null
    amountWithFees: number | null
    seviFeesAmount: number | null
    orderWalletShareFeesAmount: number | null
    fundPostDeliveryAmount: number | null
  }

  export type CreditMaxAggregateOutputType = {
    id: string | null
    typeId: string | null
    currency: CurrencyEnum | null
    orderId: string | null
    type: creditRefType | null
    amount: number | null
    debtorId: string | null
    creditorId: string | null
    installmentsCount: number | null
    installmentsCountPaid: number | null
    status: creditStatusEnum | null
    description: string | null
    totalPaid: number | null
    totalToPay: number | null
    agreedDate: Date | null
    userId: string | null
    createdAt: Date | null
    referenceNumber: string | null
    creditConfigurationId: string | null
    endDate: Date | null
    paidAt: Date | null
    duration: number | null
    durationSlices: SlicesEnum | null
    affiliateId: string | null
    defaultAt: Date | null
    fundUpfrontAmount: number | null
    orderWalletId: string | null
    fundFeesAmount: number | null
    amountWithFees: number | null
    seviFeesAmount: number | null
    orderWalletShareFeesAmount: number | null
    fundPostDeliveryAmount: number | null
  }

  export type CreditCountAggregateOutputType = {
    id: number
    typeId: number
    currency: number
    orderId: number
    type: number
    amount: number
    debtorId: number
    creditorId: number
    installmentsCount: number
    installmentsCountPaid: number
    status: number
    description: number
    totalPaid: number
    totalToPay: number
    agreedDate: number
    userId: number
    createdAt: number
    referenceNumber: number
    creditConfigurationId: number
    endDate: number
    paidAt: number
    duration: number
    durationSlices: number
    affiliateId: number
    defaultAt: number
    fundUpfrontAmount: number
    orderWalletId: number
    fundFeesAmount: number
    amountWithFees: number
    seviFeesAmount: number
    orderWalletShareFeesAmount: number
    fundPostDeliveryAmount: number
    _all: number
  }


  export type CreditAvgAggregateInputType = {
    amount?: true
    installmentsCount?: true
    installmentsCountPaid?: true
    totalPaid?: true
    totalToPay?: true
    duration?: true
    fundUpfrontAmount?: true
    fundFeesAmount?: true
    amountWithFees?: true
    seviFeesAmount?: true
    orderWalletShareFeesAmount?: true
    fundPostDeliveryAmount?: true
  }

  export type CreditSumAggregateInputType = {
    amount?: true
    installmentsCount?: true
    installmentsCountPaid?: true
    totalPaid?: true
    totalToPay?: true
    duration?: true
    fundUpfrontAmount?: true
    fundFeesAmount?: true
    amountWithFees?: true
    seviFeesAmount?: true
    orderWalletShareFeesAmount?: true
    fundPostDeliveryAmount?: true
  }

  export type CreditMinAggregateInputType = {
    id?: true
    typeId?: true
    currency?: true
    orderId?: true
    type?: true
    amount?: true
    debtorId?: true
    creditorId?: true
    installmentsCount?: true
    installmentsCountPaid?: true
    status?: true
    description?: true
    totalPaid?: true
    totalToPay?: true
    agreedDate?: true
    userId?: true
    createdAt?: true
    referenceNumber?: true
    creditConfigurationId?: true
    endDate?: true
    paidAt?: true
    duration?: true
    durationSlices?: true
    affiliateId?: true
    defaultAt?: true
    fundUpfrontAmount?: true
    orderWalletId?: true
    fundFeesAmount?: true
    amountWithFees?: true
    seviFeesAmount?: true
    orderWalletShareFeesAmount?: true
    fundPostDeliveryAmount?: true
  }

  export type CreditMaxAggregateInputType = {
    id?: true
    typeId?: true
    currency?: true
    orderId?: true
    type?: true
    amount?: true
    debtorId?: true
    creditorId?: true
    installmentsCount?: true
    installmentsCountPaid?: true
    status?: true
    description?: true
    totalPaid?: true
    totalToPay?: true
    agreedDate?: true
    userId?: true
    createdAt?: true
    referenceNumber?: true
    creditConfigurationId?: true
    endDate?: true
    paidAt?: true
    duration?: true
    durationSlices?: true
    affiliateId?: true
    defaultAt?: true
    fundUpfrontAmount?: true
    orderWalletId?: true
    fundFeesAmount?: true
    amountWithFees?: true
    seviFeesAmount?: true
    orderWalletShareFeesAmount?: true
    fundPostDeliveryAmount?: true
  }

  export type CreditCountAggregateInputType = {
    id?: true
    typeId?: true
    currency?: true
    orderId?: true
    type?: true
    amount?: true
    debtorId?: true
    creditorId?: true
    installmentsCount?: true
    installmentsCountPaid?: true
    status?: true
    description?: true
    totalPaid?: true
    totalToPay?: true
    agreedDate?: true
    userId?: true
    createdAt?: true
    referenceNumber?: true
    creditConfigurationId?: true
    endDate?: true
    paidAt?: true
    duration?: true
    durationSlices?: true
    affiliateId?: true
    defaultAt?: true
    fundUpfrontAmount?: true
    orderWalletId?: true
    fundFeesAmount?: true
    amountWithFees?: true
    seviFeesAmount?: true
    orderWalletShareFeesAmount?: true
    fundPostDeliveryAmount?: true
    _all?: true
  }

  export type CreditAggregateArgs = {
    /**
     * Filter which Credit to aggregate.
     * 
    **/
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credits
    **/
    _count?: true | CreditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditMaxAggregateInputType
  }

  export type GetCreditAggregateType<T extends CreditAggregateArgs> = {
        [P in keyof T & keyof AggregateCredit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredit[P]>
      : GetScalarType<T[P], AggregateCredit[P]>
  }




  export type CreditGroupByArgs = {
    where?: CreditWhereInput
    orderBy?: Enumerable<CreditOrderByWithAggregationInput>
    by: Array<CreditScalarFieldEnum>
    having?: CreditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditCountAggregateInputType | true
    _avg?: CreditAvgAggregateInputType
    _sum?: CreditSumAggregateInputType
    _min?: CreditMinAggregateInputType
    _max?: CreditMaxAggregateInputType
  }


  export type CreditGroupByOutputType = {
    id: string
    typeId: string | null
    currency: CurrencyEnum | null
    orderId: string | null
    type: creditRefType | null
    amount: number | null
    debtorId: string | null
    creditorId: string | null
    installmentsCount: number | null
    installmentsCountPaid: number | null
    status: creditStatusEnum | null
    description: string | null
    totalPaid: number | null
    totalToPay: number | null
    agreedDate: Date | null
    userId: string | null
    createdAt: Date
    referenceNumber: string
    creditConfigurationId: string
    endDate: Date | null
    paidAt: Date | null
    duration: number | null
    durationSlices: SlicesEnum
    affiliateId: string | null
    defaultAt: Date | null
    fundUpfrontAmount: number | null
    orderWalletId: string | null
    fundFeesAmount: number | null
    amountWithFees: number | null
    seviFeesAmount: number | null
    orderWalletShareFeesAmount: number | null
    fundPostDeliveryAmount: number | null
    _count: CreditCountAggregateOutputType | null
    _avg: CreditAvgAggregateOutputType | null
    _sum: CreditSumAggregateOutputType | null
    _min: CreditMinAggregateOutputType | null
    _max: CreditMaxAggregateOutputType | null
  }

  type GetCreditGroupByPayload<T extends CreditGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CreditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditGroupByOutputType[P]>
            : GetScalarType<T[P], CreditGroupByOutputType[P]>
        }
      >
    >


  export type CreditSelect = {
    id?: boolean
    typeId?: boolean
    currency?: boolean
    orderId?: boolean
    type?: boolean
    amount?: boolean
    debtorId?: boolean
    creditorId?: boolean
    installmentsCount?: boolean
    installmentsCountPaid?: boolean
    status?: boolean
    description?: boolean
    totalPaid?: boolean
    totalToPay?: boolean
    agreedDate?: boolean
    userId?: boolean
    createdAt?: boolean
    referenceNumber?: boolean
    creditConfigurationId?: boolean
    endDate?: boolean
    paidAt?: boolean
    duration?: boolean
    durationSlices?: boolean
    affiliateId?: boolean
    defaultAt?: boolean
    fundUpfrontAmount?: boolean
    orderWalletId?: boolean
    fundFeesAmount?: boolean
    amountWithFees?: boolean
    seviFeesAmount?: boolean
    orderWalletShareFeesAmount?: boolean
    fundPostDeliveryAmount?: boolean
    affiliate?: boolean | UserArgs
    creditConfiguration?: boolean | CreditConfigurationArgs
    creditor?: boolean | WalletArgs
    debtor?: boolean | WalletArgs
    order?: boolean | OrderArgs
    user?: boolean | UserArgs
    installments?: boolean | InstallmentFindManyArgs
    _count?: boolean | CreditCountOutputTypeArgs
  }

  export type CreditInclude = {
    affiliate?: boolean | UserArgs
    creditConfiguration?: boolean | CreditConfigurationArgs
    creditor?: boolean | WalletArgs
    debtor?: boolean | WalletArgs
    order?: boolean | OrderArgs
    user?: boolean | UserArgs
    installments?: boolean | InstallmentFindManyArgs
    _count?: boolean | CreditCountOutputTypeArgs
  }

  export type CreditGetPayload<
    S extends boolean | null | undefined | CreditArgs,
    U = keyof S
      > = S extends true
        ? Credit
    : S extends undefined
    ? never
    : S extends CreditArgs | CreditFindManyArgs
    ?'include' extends U
    ? Credit  & {
    [P in TrueKeys<S['include']>]:
        P extends 'affiliate' ? UserGetPayload<S['include'][P]> | null :
        P extends 'creditConfiguration' ? CreditConfigurationGetPayload<S['include'][P]> :
        P extends 'creditor' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'debtor' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'order' ? OrderGetPayload<S['include'][P]> | null :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'installments' ? Array < InstallmentGetPayload<S['include'][P]>>  :
        P extends '_count' ? CreditCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'affiliate' ? UserGetPayload<S['select'][P]> | null :
        P extends 'creditConfiguration' ? CreditConfigurationGetPayload<S['select'][P]> :
        P extends 'creditor' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'debtor' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'order' ? OrderGetPayload<S['select'][P]> | null :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'installments' ? Array < InstallmentGetPayload<S['select'][P]>>  :
        P extends '_count' ? CreditCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Credit ? Credit[P] : never
  } 
    : Credit
  : Credit


  type CreditCountArgs = Merge<
    Omit<CreditFindManyArgs, 'select' | 'include'> & {
      select?: CreditCountAggregateInputType | true
    }
  >

  export interface CreditDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Credit that matches the filter.
     * @param {CreditFindUniqueArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreditFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreditFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Credit'> extends True ? CheckSelect<T, Prisma__CreditClient<Credit>, Prisma__CreditClient<CreditGetPayload<T>>> : CheckSelect<T, Prisma__CreditClient<Credit | null >, Prisma__CreditClient<CreditGetPayload<T> | null >>

    /**
     * Find the first Credit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditFindFirstArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreditFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreditFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Credit'> extends True ? CheckSelect<T, Prisma__CreditClient<Credit>, Prisma__CreditClient<CreditGetPayload<T>>> : CheckSelect<T, Prisma__CreditClient<Credit | null >, Prisma__CreditClient<CreditGetPayload<T> | null >>

    /**
     * Find zero or more Credits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credits
     * const credits = await prisma.credit.findMany()
     * 
     * // Get first 10 Credits
     * const credits = await prisma.credit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditWithIdOnly = await prisma.credit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreditFindManyArgs>(
      args?: SelectSubset<T, CreditFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Credit>>, PrismaPromise<Array<CreditGetPayload<T>>>>

    /**
     * Create a Credit.
     * @param {CreditCreateArgs} args - Arguments to create a Credit.
     * @example
     * // Create one Credit
     * const Credit = await prisma.credit.create({
     *   data: {
     *     // ... data to create a Credit
     *   }
     * })
     * 
    **/
    create<T extends CreditCreateArgs>(
      args: SelectSubset<T, CreditCreateArgs>
    ): CheckSelect<T, Prisma__CreditClient<Credit>, Prisma__CreditClient<CreditGetPayload<T>>>

    /**
     * Create many Credits.
     *     @param {CreditCreateManyArgs} args - Arguments to create many Credits.
     *     @example
     *     // Create many Credits
     *     const credit = await prisma.credit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreditCreateManyArgs>(
      args?: SelectSubset<T, CreditCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Credit.
     * @param {CreditDeleteArgs} args - Arguments to delete one Credit.
     * @example
     * // Delete one Credit
     * const Credit = await prisma.credit.delete({
     *   where: {
     *     // ... filter to delete one Credit
     *   }
     * })
     * 
    **/
    delete<T extends CreditDeleteArgs>(
      args: SelectSubset<T, CreditDeleteArgs>
    ): CheckSelect<T, Prisma__CreditClient<Credit>, Prisma__CreditClient<CreditGetPayload<T>>>

    /**
     * Update one Credit.
     * @param {CreditUpdateArgs} args - Arguments to update one Credit.
     * @example
     * // Update one Credit
     * const credit = await prisma.credit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreditUpdateArgs>(
      args: SelectSubset<T, CreditUpdateArgs>
    ): CheckSelect<T, Prisma__CreditClient<Credit>, Prisma__CreditClient<CreditGetPayload<T>>>

    /**
     * Delete zero or more Credits.
     * @param {CreditDeleteManyArgs} args - Arguments to filter Credits to delete.
     * @example
     * // Delete a few Credits
     * const { count } = await prisma.credit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreditDeleteManyArgs>(
      args?: SelectSubset<T, CreditDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credits
     * const credit = await prisma.credit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreditUpdateManyArgs>(
      args: SelectSubset<T, CreditUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Credit.
     * @param {CreditUpsertArgs} args - Arguments to update or create a Credit.
     * @example
     * // Update or create a Credit
     * const credit = await prisma.credit.upsert({
     *   create: {
     *     // ... data to create a Credit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credit we want to update
     *   }
     * })
    **/
    upsert<T extends CreditUpsertArgs>(
      args: SelectSubset<T, CreditUpsertArgs>
    ): CheckSelect<T, Prisma__CreditClient<Credit>, Prisma__CreditClient<CreditGetPayload<T>>>

    /**
     * Count the number of Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditCountArgs} args - Arguments to filter Credits to count.
     * @example
     * // Count the number of Credits
     * const count = await prisma.credit.count({
     *   where: {
     *     // ... the filter for the Credits we want to count
     *   }
     * })
    **/
    count<T extends CreditCountArgs>(
      args?: Subset<T, CreditCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditAggregateArgs>(args: Subset<T, CreditAggregateArgs>): PrismaPromise<GetCreditAggregateType<T>>

    /**
     * Group by Credit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditGroupByArgs['orderBy'] }
        : { orderBy?: CreditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreditClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    affiliate<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    creditConfiguration<T extends CreditConfigurationArgs = {}>(args?: Subset<T, CreditConfigurationArgs>): CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration | null >, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T> | null >>;

    creditor<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    debtor<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    installments<T extends InstallmentFindManyArgs = {}>(args?: Subset<T, InstallmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Installment>>, PrismaPromise<Array<InstallmentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Credit findUnique
   */
  export type CreditFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Credit
     * 
    **/
    select?: CreditSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditInclude | null
    /**
     * Throw an Error if a Credit can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Credit to fetch.
     * 
    **/
    where: CreditWhereUniqueInput
  }


  /**
   * Credit findFirst
   */
  export type CreditFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Credit
     * 
    **/
    select?: CreditSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditInclude | null
    /**
     * Throw an Error if a Credit can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Credit to fetch.
     * 
    **/
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credits.
     * 
    **/
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credits.
     * 
    **/
    distinct?: Enumerable<CreditScalarFieldEnum>
  }


  /**
   * Credit findMany
   */
  export type CreditFindManyArgs = {
    /**
     * Select specific fields to fetch from the Credit
     * 
    **/
    select?: CreditSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditInclude | null
    /**
     * Filter, which Credits to fetch.
     * 
    **/
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credits.
     * 
    **/
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreditScalarFieldEnum>
  }


  /**
   * Credit create
   */
  export type CreditCreateArgs = {
    /**
     * Select specific fields to fetch from the Credit
     * 
    **/
    select?: CreditSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditInclude | null
    /**
     * The data needed to create a Credit.
     * 
    **/
    data: XOR<CreditCreateInput, CreditUncheckedCreateInput>
  }


  /**
   * Credit createMany
   */
  export type CreditCreateManyArgs = {
    /**
     * The data used to create many Credits.
     * 
    **/
    data: Enumerable<CreditCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Credit update
   */
  export type CreditUpdateArgs = {
    /**
     * Select specific fields to fetch from the Credit
     * 
    **/
    select?: CreditSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditInclude | null
    /**
     * The data needed to update a Credit.
     * 
    **/
    data: XOR<CreditUpdateInput, CreditUncheckedUpdateInput>
    /**
     * Choose, which Credit to update.
     * 
    **/
    where: CreditWhereUniqueInput
  }


  /**
   * Credit updateMany
   */
  export type CreditUpdateManyArgs = {
    /**
     * The data used to update Credits.
     * 
    **/
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyInput>
    /**
     * Filter which Credits to update
     * 
    **/
    where?: CreditWhereInput
  }


  /**
   * Credit upsert
   */
  export type CreditUpsertArgs = {
    /**
     * Select specific fields to fetch from the Credit
     * 
    **/
    select?: CreditSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditInclude | null
    /**
     * The filter to search for the Credit to update in case it exists.
     * 
    **/
    where: CreditWhereUniqueInput
    /**
     * In case the Credit found by the `where` argument doesn't exist, create a new Credit with this data.
     * 
    **/
    create: XOR<CreditCreateInput, CreditUncheckedCreateInput>
    /**
     * In case the Credit was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreditUpdateInput, CreditUncheckedUpdateInput>
  }


  /**
   * Credit delete
   */
  export type CreditDeleteArgs = {
    /**
     * Select specific fields to fetch from the Credit
     * 
    **/
    select?: CreditSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditInclude | null
    /**
     * Filter which Credit to delete.
     * 
    **/
    where: CreditWhereUniqueInput
  }


  /**
   * Credit deleteMany
   */
  export type CreditDeleteManyArgs = {
    /**
     * Filter which Credits to delete
     * 
    **/
    where?: CreditWhereInput
  }


  /**
   * Credit without action
   */
  export type CreditArgs = {
    /**
     * Select specific fields to fetch from the Credit
     * 
    **/
    select?: CreditSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditInclude | null
  }



  /**
   * Model Installment
   */


  export type AggregateInstallment = {
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  export type InstallmentAvgAggregateOutputType = {
    installmentCount: number | null
    amount: number | null
    paidAmount: number | null
    amountWithPenalty: number | null
    seviFees: number | null
    penalty: number | null
    affiliateFees: number | null
  }

  export type InstallmentSumAggregateOutputType = {
    installmentCount: number | null
    amount: number | null
    paidAmount: number | null
    amountWithPenalty: number | null
    seviFees: number | null
    penalty: number | null
    affiliateFees: number | null
  }

  export type InstallmentMinAggregateOutputType = {
    id: string | null
    installmentCount: number | null
    startDate: Date | null
    endDate: Date | null
    referenceNumber: string | null
    amount: number | null
    paidAmount: number | null
    debtorId: string | null
    creditorId: string | null
    orderId: string | null
    status: installmentStatusTypeEnum | null
    firstTryFailedAt: Date | null
    creditId: string | null
    createdAt: Date | null
    userId: string | null
    amountWithPenalty: number | null
    seviFees: number | null
    penalty: number | null
    paidAt: Date | null
    creditConfigurationId: string | null
    affiliateFees: number | null
    currency: CurrencyEnum | null
  }

  export type InstallmentMaxAggregateOutputType = {
    id: string | null
    installmentCount: number | null
    startDate: Date | null
    endDate: Date | null
    referenceNumber: string | null
    amount: number | null
    paidAmount: number | null
    debtorId: string | null
    creditorId: string | null
    orderId: string | null
    status: installmentStatusTypeEnum | null
    firstTryFailedAt: Date | null
    creditId: string | null
    createdAt: Date | null
    userId: string | null
    amountWithPenalty: number | null
    seviFees: number | null
    penalty: number | null
    paidAt: Date | null
    creditConfigurationId: string | null
    affiliateFees: number | null
    currency: CurrencyEnum | null
  }

  export type InstallmentCountAggregateOutputType = {
    id: number
    installmentCount: number
    startDate: number
    endDate: number
    referenceNumber: number
    amount: number
    paidAmount: number
    debtorId: number
    creditorId: number
    orderId: number
    status: number
    firstTryFailedAt: number
    creditId: number
    createdAt: number
    userId: number
    amountWithPenalty: number
    seviFees: number
    penalty: number
    paidAt: number
    creditConfigurationId: number
    affiliateFees: number
    currency: number
    _all: number
  }


  export type InstallmentAvgAggregateInputType = {
    installmentCount?: true
    amount?: true
    paidAmount?: true
    amountWithPenalty?: true
    seviFees?: true
    penalty?: true
    affiliateFees?: true
  }

  export type InstallmentSumAggregateInputType = {
    installmentCount?: true
    amount?: true
    paidAmount?: true
    amountWithPenalty?: true
    seviFees?: true
    penalty?: true
    affiliateFees?: true
  }

  export type InstallmentMinAggregateInputType = {
    id?: true
    installmentCount?: true
    startDate?: true
    endDate?: true
    referenceNumber?: true
    amount?: true
    paidAmount?: true
    debtorId?: true
    creditorId?: true
    orderId?: true
    status?: true
    firstTryFailedAt?: true
    creditId?: true
    createdAt?: true
    userId?: true
    amountWithPenalty?: true
    seviFees?: true
    penalty?: true
    paidAt?: true
    creditConfigurationId?: true
    affiliateFees?: true
    currency?: true
  }

  export type InstallmentMaxAggregateInputType = {
    id?: true
    installmentCount?: true
    startDate?: true
    endDate?: true
    referenceNumber?: true
    amount?: true
    paidAmount?: true
    debtorId?: true
    creditorId?: true
    orderId?: true
    status?: true
    firstTryFailedAt?: true
    creditId?: true
    createdAt?: true
    userId?: true
    amountWithPenalty?: true
    seviFees?: true
    penalty?: true
    paidAt?: true
    creditConfigurationId?: true
    affiliateFees?: true
    currency?: true
  }

  export type InstallmentCountAggregateInputType = {
    id?: true
    installmentCount?: true
    startDate?: true
    endDate?: true
    referenceNumber?: true
    amount?: true
    paidAmount?: true
    debtorId?: true
    creditorId?: true
    orderId?: true
    status?: true
    firstTryFailedAt?: true
    creditId?: true
    createdAt?: true
    userId?: true
    amountWithPenalty?: true
    seviFees?: true
    penalty?: true
    paidAt?: true
    creditConfigurationId?: true
    affiliateFees?: true
    currency?: true
    _all?: true
  }

  export type InstallmentAggregateArgs = {
    /**
     * Filter which Installment to aggregate.
     * 
    **/
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     * 
    **/
    orderBy?: Enumerable<InstallmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Installments
    **/
    _count?: true | InstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallmentMaxAggregateInputType
  }

  export type GetInstallmentAggregateType<T extends InstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallment[P]>
      : GetScalarType<T[P], AggregateInstallment[P]>
  }




  export type InstallmentGroupByArgs = {
    where?: InstallmentWhereInput
    orderBy?: Enumerable<InstallmentOrderByWithAggregationInput>
    by: Array<InstallmentScalarFieldEnum>
    having?: InstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallmentCountAggregateInputType | true
    _avg?: InstallmentAvgAggregateInputType
    _sum?: InstallmentSumAggregateInputType
    _min?: InstallmentMinAggregateInputType
    _max?: InstallmentMaxAggregateInputType
  }


  export type InstallmentGroupByOutputType = {
    id: string
    installmentCount: number | null
    startDate: Date | null
    endDate: Date | null
    referenceNumber: string | null
    amount: number
    paidAmount: number
    debtorId: string | null
    creditorId: string | null
    orderId: string | null
    status: installmentStatusTypeEnum | null
    firstTryFailedAt: Date | null
    creditId: string | null
    createdAt: Date
    userId: string | null
    amountWithPenalty: number
    seviFees: number
    penalty: number
    paidAt: Date | null
    creditConfigurationId: string
    affiliateFees: number
    currency: CurrencyEnum | null
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  type GetInstallmentGroupByPayload<T extends InstallmentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
        }
      >
    >


  export type InstallmentSelect = {
    id?: boolean
    installmentCount?: boolean
    startDate?: boolean
    endDate?: boolean
    referenceNumber?: boolean
    amount?: boolean
    paidAmount?: boolean
    debtorId?: boolean
    creditorId?: boolean
    orderId?: boolean
    status?: boolean
    firstTryFailedAt?: boolean
    creditId?: boolean
    createdAt?: boolean
    userId?: boolean
    amountWithPenalty?: boolean
    seviFees?: boolean
    penalty?: boolean
    paidAt?: boolean
    creditConfigurationId?: boolean
    affiliateFees?: boolean
    currency?: boolean
    creditConfiguration?: boolean | CreditConfigurationArgs
    credit?: boolean | CreditArgs
    creditor?: boolean | WalletArgs
    debtor?: boolean | WalletArgs
    order?: boolean | OrderArgs
    user?: boolean | UserArgs
  }

  export type InstallmentInclude = {
    creditConfiguration?: boolean | CreditConfigurationArgs
    credit?: boolean | CreditArgs
    creditor?: boolean | WalletArgs
    debtor?: boolean | WalletArgs
    order?: boolean | OrderArgs
    user?: boolean | UserArgs
  }

  export type InstallmentGetPayload<
    S extends boolean | null | undefined | InstallmentArgs,
    U = keyof S
      > = S extends true
        ? Installment
    : S extends undefined
    ? never
    : S extends InstallmentArgs | InstallmentFindManyArgs
    ?'include' extends U
    ? Installment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'creditConfiguration' ? CreditConfigurationGetPayload<S['include'][P]> :
        P extends 'credit' ? CreditGetPayload<S['include'][P]> | null :
        P extends 'creditor' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'debtor' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'order' ? OrderGetPayload<S['include'][P]> | null :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'creditConfiguration' ? CreditConfigurationGetPayload<S['select'][P]> :
        P extends 'credit' ? CreditGetPayload<S['select'][P]> | null :
        P extends 'creditor' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'debtor' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'order' ? OrderGetPayload<S['select'][P]> | null :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Installment ? Installment[P] : never
  } 
    : Installment
  : Installment


  type InstallmentCountArgs = Merge<
    Omit<InstallmentFindManyArgs, 'select' | 'include'> & {
      select?: InstallmentCountAggregateInputType | true
    }
  >

  export interface InstallmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Installment that matches the filter.
     * @param {InstallmentFindUniqueArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstallmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InstallmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Installment'> extends True ? CheckSelect<T, Prisma__InstallmentClient<Installment>, Prisma__InstallmentClient<InstallmentGetPayload<T>>> : CheckSelect<T, Prisma__InstallmentClient<Installment | null >, Prisma__InstallmentClient<InstallmentGetPayload<T> | null >>

    /**
     * Find the first Installment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstallmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InstallmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Installment'> extends True ? CheckSelect<T, Prisma__InstallmentClient<Installment>, Prisma__InstallmentClient<InstallmentGetPayload<T>>> : CheckSelect<T, Prisma__InstallmentClient<Installment | null >, Prisma__InstallmentClient<InstallmentGetPayload<T> | null >>

    /**
     * Find zero or more Installments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Installments
     * const installments = await prisma.installment.findMany()
     * 
     * // Get first 10 Installments
     * const installments = await prisma.installment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installmentWithIdOnly = await prisma.installment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InstallmentFindManyArgs>(
      args?: SelectSubset<T, InstallmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Installment>>, PrismaPromise<Array<InstallmentGetPayload<T>>>>

    /**
     * Create a Installment.
     * @param {InstallmentCreateArgs} args - Arguments to create a Installment.
     * @example
     * // Create one Installment
     * const Installment = await prisma.installment.create({
     *   data: {
     *     // ... data to create a Installment
     *   }
     * })
     * 
    **/
    create<T extends InstallmentCreateArgs>(
      args: SelectSubset<T, InstallmentCreateArgs>
    ): CheckSelect<T, Prisma__InstallmentClient<Installment>, Prisma__InstallmentClient<InstallmentGetPayload<T>>>

    /**
     * Create many Installments.
     *     @param {InstallmentCreateManyArgs} args - Arguments to create many Installments.
     *     @example
     *     // Create many Installments
     *     const installment = await prisma.installment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstallmentCreateManyArgs>(
      args?: SelectSubset<T, InstallmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Installment.
     * @param {InstallmentDeleteArgs} args - Arguments to delete one Installment.
     * @example
     * // Delete one Installment
     * const Installment = await prisma.installment.delete({
     *   where: {
     *     // ... filter to delete one Installment
     *   }
     * })
     * 
    **/
    delete<T extends InstallmentDeleteArgs>(
      args: SelectSubset<T, InstallmentDeleteArgs>
    ): CheckSelect<T, Prisma__InstallmentClient<Installment>, Prisma__InstallmentClient<InstallmentGetPayload<T>>>

    /**
     * Update one Installment.
     * @param {InstallmentUpdateArgs} args - Arguments to update one Installment.
     * @example
     * // Update one Installment
     * const installment = await prisma.installment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstallmentUpdateArgs>(
      args: SelectSubset<T, InstallmentUpdateArgs>
    ): CheckSelect<T, Prisma__InstallmentClient<Installment>, Prisma__InstallmentClient<InstallmentGetPayload<T>>>

    /**
     * Delete zero or more Installments.
     * @param {InstallmentDeleteManyArgs} args - Arguments to filter Installments to delete.
     * @example
     * // Delete a few Installments
     * const { count } = await prisma.installment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstallmentDeleteManyArgs>(
      args?: SelectSubset<T, InstallmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Installments
     * const installment = await prisma.installment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstallmentUpdateManyArgs>(
      args: SelectSubset<T, InstallmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Installment.
     * @param {InstallmentUpsertArgs} args - Arguments to update or create a Installment.
     * @example
     * // Update or create a Installment
     * const installment = await prisma.installment.upsert({
     *   create: {
     *     // ... data to create a Installment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Installment we want to update
     *   }
     * })
    **/
    upsert<T extends InstallmentUpsertArgs>(
      args: SelectSubset<T, InstallmentUpsertArgs>
    ): CheckSelect<T, Prisma__InstallmentClient<Installment>, Prisma__InstallmentClient<InstallmentGetPayload<T>>>

    /**
     * Count the number of Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentCountArgs} args - Arguments to filter Installments to count.
     * @example
     * // Count the number of Installments
     * const count = await prisma.installment.count({
     *   where: {
     *     // ... the filter for the Installments we want to count
     *   }
     * })
    **/
    count<T extends InstallmentCountArgs>(
      args?: Subset<T, InstallmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallmentAggregateArgs>(args: Subset<T, InstallmentAggregateArgs>): PrismaPromise<GetInstallmentAggregateType<T>>

    /**
     * Group by Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallmentGroupByArgs['orderBy'] }
        : { orderBy?: InstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallmentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Installment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InstallmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    creditConfiguration<T extends CreditConfigurationArgs = {}>(args?: Subset<T, CreditConfigurationArgs>): CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration | null >, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T> | null >>;

    credit<T extends CreditArgs = {}>(args?: Subset<T, CreditArgs>): CheckSelect<T, Prisma__CreditClient<Credit | null >, Prisma__CreditClient<CreditGetPayload<T> | null >>;

    creditor<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    debtor<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Installment findUnique
   */
  export type InstallmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Installment
     * 
    **/
    select?: InstallmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InstallmentInclude | null
    /**
     * Throw an Error if a Installment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Installment to fetch.
     * 
    **/
    where: InstallmentWhereUniqueInput
  }


  /**
   * Installment findFirst
   */
  export type InstallmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Installment
     * 
    **/
    select?: InstallmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InstallmentInclude | null
    /**
     * Throw an Error if a Installment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Installment to fetch.
     * 
    **/
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     * 
    **/
    orderBy?: Enumerable<InstallmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     * 
    **/
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     * 
    **/
    distinct?: Enumerable<InstallmentScalarFieldEnum>
  }


  /**
   * Installment findMany
   */
  export type InstallmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Installment
     * 
    **/
    select?: InstallmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InstallmentInclude | null
    /**
     * Filter, which Installments to fetch.
     * 
    **/
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     * 
    **/
    orderBy?: Enumerable<InstallmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Installments.
     * 
    **/
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InstallmentScalarFieldEnum>
  }


  /**
   * Installment create
   */
  export type InstallmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Installment
     * 
    **/
    select?: InstallmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InstallmentInclude | null
    /**
     * The data needed to create a Installment.
     * 
    **/
    data: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
  }


  /**
   * Installment createMany
   */
  export type InstallmentCreateManyArgs = {
    /**
     * The data used to create many Installments.
     * 
    **/
    data: Enumerable<InstallmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Installment update
   */
  export type InstallmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Installment
     * 
    **/
    select?: InstallmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InstallmentInclude | null
    /**
     * The data needed to update a Installment.
     * 
    **/
    data: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
    /**
     * Choose, which Installment to update.
     * 
    **/
    where: InstallmentWhereUniqueInput
  }


  /**
   * Installment updateMany
   */
  export type InstallmentUpdateManyArgs = {
    /**
     * The data used to update Installments.
     * 
    **/
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyInput>
    /**
     * Filter which Installments to update
     * 
    **/
    where?: InstallmentWhereInput
  }


  /**
   * Installment upsert
   */
  export type InstallmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Installment
     * 
    **/
    select?: InstallmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InstallmentInclude | null
    /**
     * The filter to search for the Installment to update in case it exists.
     * 
    **/
    where: InstallmentWhereUniqueInput
    /**
     * In case the Installment found by the `where` argument doesn't exist, create a new Installment with this data.
     * 
    **/
    create: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
    /**
     * In case the Installment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
  }


  /**
   * Installment delete
   */
  export type InstallmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Installment
     * 
    **/
    select?: InstallmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InstallmentInclude | null
    /**
     * Filter which Installment to delete.
     * 
    **/
    where: InstallmentWhereUniqueInput
  }


  /**
   * Installment deleteMany
   */
  export type InstallmentDeleteManyArgs = {
    /**
     * Filter which Installments to delete
     * 
    **/
    where?: InstallmentWhereInput
  }


  /**
   * Installment without action
   */
  export type InstallmentArgs = {
    /**
     * Select specific fields to fetch from the Installment
     * 
    **/
    select?: InstallmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InstallmentInclude | null
  }



  /**
   * Model Activity
   */


  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    entityId: string | null
    entityType: ActivityEntityType | null
    priority: ActivityPriority | null
    phoneNumber: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    entityId: string | null
    entityType: ActivityEntityType | null
    priority: ActivityPriority | null
    phoneNumber: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    entityId: number
    entityType: number
    priority: number
    phoneNumber: number
    message: number
    isRead: number
    createdAt: number
    entity: number
    userId: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    entityId?: true
    entityType?: true
    priority?: true
    phoneNumber?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    entityId?: true
    entityType?: true
    priority?: true
    phoneNumber?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    entityId?: true
    entityType?: true
    priority?: true
    phoneNumber?: true
    message?: true
    isRead?: true
    createdAt?: true
    entity?: true
    userId?: true
    _all?: true
  }

  export type ActivityAggregateArgs = {
    /**
     * Filter which Activity to aggregate.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs = {
    where?: ActivityWhereInput
    orderBy?: Enumerable<ActivityOrderByWithAggregationInput>
    by: Array<ActivityScalarFieldEnum>
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }


  export type ActivityGroupByOutputType = {
    id: string
    entityId: string | null
    entityType: ActivityEntityType | null
    priority: ActivityPriority | null
    phoneNumber: string | null
    message: JsonValue | null
    isRead: boolean | null
    createdAt: Date
    entity: JsonValue | null
    userId: string | null
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect = {
    id?: boolean
    entityId?: boolean
    entityType?: boolean
    priority?: boolean
    phoneNumber?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    entity?: boolean
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type ActivityInclude = {
    user?: boolean | UserArgs
  }

  export type ActivityGetPayload<
    S extends boolean | null | undefined | ActivityArgs,
    U = keyof S
      > = S extends true
        ? Activity
    : S extends undefined
    ? never
    : S extends ActivityArgs | ActivityFindManyArgs
    ?'include' extends U
    ? Activity  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Activity ? Activity[P] : never
  } 
    : Activity
  : Activity


  type ActivityCountArgs = Merge<
    Omit<ActivityFindManyArgs, 'select' | 'include'> & {
      select?: ActivityCountAggregateInputType | true
    }
  >

  export interface ActivityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActivityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Activity'> extends True ? CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>> : CheckSelect<T, Prisma__ActivityClient<Activity | null >, Prisma__ActivityClient<ActivityGetPayload<T> | null >>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActivityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Activity'> extends True ? CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>> : CheckSelect<T, Prisma__ActivityClient<Activity | null >, Prisma__ActivityClient<ActivityGetPayload<T> | null >>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActivityFindManyArgs>(
      args?: SelectSubset<T, ActivityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Activity>>, PrismaPromise<Array<ActivityGetPayload<T>>>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
    **/
    create<T extends ActivityCreateArgs>(
      args: SelectSubset<T, ActivityCreateArgs>
    ): CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>>

    /**
     * Create many Activities.
     *     @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     *     @example
     *     // Create many Activities
     *     const activity = await prisma.activity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivityCreateManyArgs>(
      args?: SelectSubset<T, ActivityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
    **/
    delete<T extends ActivityDeleteArgs>(
      args: SelectSubset<T, ActivityDeleteArgs>
    ): CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivityUpdateArgs>(
      args: SelectSubset<T, ActivityUpdateArgs>
    ): CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivityDeleteManyArgs>(
      args?: SelectSubset<T, ActivityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivityUpdateManyArgs>(
      args: SelectSubset<T, ActivityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
    **/
    upsert<T extends ActivityUpsertArgs>(
      args: SelectSubset<T, ActivityUpsertArgs>
    ): CheckSelect<T, Prisma__ActivityClient<Activity>, Prisma__ActivityClient<ActivityGetPayload<T>>>

    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActivityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Throw an Error if a Activity can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Activity to fetch.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Throw an Error if a Activity can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Activity to fetch.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     * 
    **/
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter, which Activities to fetch.
     * 
    **/
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     * 
    **/
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     * 
    **/
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * Activity create
   */
  export type ActivityCreateArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The data needed to create a Activity.
     * 
    **/
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }


  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs = {
    /**
     * The data used to create many Activities.
     * 
    **/
    data: Enumerable<ActivityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Activity update
   */
  export type ActivityUpdateArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The data needed to update a Activity.
     * 
    **/
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs = {
    /**
     * The data used to update Activities.
     * 
    **/
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     * 
    **/
    where?: ActivityWhereInput
  }


  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * The filter to search for the Activity to update in case it exists.
     * 
    **/
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     * 
    **/
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }


  /**
   * Activity delete
   */
  export type ActivityDeleteArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
    /**
     * Filter which Activity to delete.
     * 
    **/
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs = {
    /**
     * Filter which Activities to delete
     * 
    **/
    where?: ActivityWhereInput
  }


  /**
   * Activity without action
   */
  export type ActivityArgs = {
    /**
     * Select specific fields to fetch from the Activity
     * 
    **/
    select?: ActivitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ActivityInclude | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    messageId: string | null
    SMS: string | null
    description: string | null
    pushNotificationTitle: string | null
    pushNotificationBody: string | null
    email: string | null
    language: language | null
  }

  export type MessageMaxAggregateOutputType = {
    messageId: string | null
    SMS: string | null
    description: string | null
    pushNotificationTitle: string | null
    pushNotificationBody: string | null
    email: string | null
    language: language | null
  }

  export type MessageCountAggregateOutputType = {
    messageId: number
    installmentSlices: number
    SMS: number
    description: number
    pushNotificationTitle: number
    pushNotificationBody: number
    email: number
    language: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    messageId?: true
    SMS?: true
    description?: true
    pushNotificationTitle?: true
    pushNotificationBody?: true
    email?: true
    language?: true
  }

  export type MessageMaxAggregateInputType = {
    messageId?: true
    SMS?: true
    description?: true
    pushNotificationTitle?: true
    pushNotificationBody?: true
    email?: true
    language?: true
  }

  export type MessageCountAggregateInputType = {
    messageId?: true
    installmentSlices?: true
    SMS?: true
    description?: true
    pushNotificationTitle?: true
    pushNotificationBody?: true
    email?: true
    language?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: Array<MessageScalarFieldEnum>
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    messageId: string
    installmentSlices: SlicesEnum[]
    SMS: string | null
    description: string | null
    pushNotificationTitle: string | null
    pushNotificationBody: string | null
    email: string | null
    language: language
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect = {
    messageId?: boolean
    installmentSlices?: boolean
    SMS?: boolean
    description?: boolean
    pushNotificationTitle?: boolean
    pushNotificationBody?: boolean
    email?: boolean
    language?: boolean
  }

  export type MessageGetPayload<
    S extends boolean | null | undefined | MessageArgs,
    U = keyof S
      > = S extends true
        ? Message
    : S extends undefined
    ? never
    : S extends MessageArgs | MessageFindManyArgs
    ?'include' extends U
    ? Message 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Message ? Message[P] : never
  } 
    : Message
  : Message


  type MessageCountArgs = Merge<
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }
  >

  export interface MessageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>> : CheckSelect<T, Prisma__MessageClient<Message | null >, Prisma__MessageClient<MessageGetPayload<T> | null >>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const messageWithMessageIdOnly = await prisma.message.findMany({ select: { messageId: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Message>>, PrismaPromise<Array<MessageGetPayload<T>>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Throw an Error if a Message can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Message to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     * 
    **/
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Filter, which Messages to fetch.
     * 
    **/
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     * 
    **/
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * The data needed to create a Message.
     * 
    **/
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    /**
     * The data used to create many Messages.
     * 
    **/
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * The data needed to update a Message.
     * 
    **/
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    /**
     * The data used to update Messages.
     * 
    **/
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     * 
    **/
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * The filter to search for the Message to update in case it exists.
     * 
    **/
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     * 
    **/
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
    /**
     * Filter which Message to delete.
     * 
    **/
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    /**
     * Filter which Messages to delete
     * 
    **/
    where?: MessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     * 
    **/
    select?: MessageSelect | null
  }



  /**
   * Model Verify
   */


  export type AggregateVerify = {
    _count: VerifyCountAggregateOutputType | null
    _min: VerifyMinAggregateOutputType | null
    _max: VerifyMaxAggregateOutputType | null
  }

  export type VerifyMinAggregateOutputType = {
    id: string | null
    UID: string | null
    phoneNumber: string | null
    countryCode: CountryCode | null
    createdAt: Date | null
    creditConfigId: string | null
    OTP: string | null
    email: string | null
    userId: string | null
    orderPaymentMethod: OrderPaymentMethodsEnum | null
  }

  export type VerifyMaxAggregateOutputType = {
    id: string | null
    UID: string | null
    phoneNumber: string | null
    countryCode: CountryCode | null
    createdAt: Date | null
    creditConfigId: string | null
    OTP: string | null
    email: string | null
    userId: string | null
    orderPaymentMethod: OrderPaymentMethodsEnum | null
  }

  export type VerifyCountAggregateOutputType = {
    id: number
    UID: number
    phoneNumber: number
    countryCode: number
    createdAt: number
    creditConfigId: number
    OTP: number
    email: number
    userId: number
    orderPaymentMethod: number
    _all: number
  }


  export type VerifyMinAggregateInputType = {
    id?: true
    UID?: true
    phoneNumber?: true
    countryCode?: true
    createdAt?: true
    creditConfigId?: true
    OTP?: true
    email?: true
    userId?: true
    orderPaymentMethod?: true
  }

  export type VerifyMaxAggregateInputType = {
    id?: true
    UID?: true
    phoneNumber?: true
    countryCode?: true
    createdAt?: true
    creditConfigId?: true
    OTP?: true
    email?: true
    userId?: true
    orderPaymentMethod?: true
  }

  export type VerifyCountAggregateInputType = {
    id?: true
    UID?: true
    phoneNumber?: true
    countryCode?: true
    createdAt?: true
    creditConfigId?: true
    OTP?: true
    email?: true
    userId?: true
    orderPaymentMethod?: true
    _all?: true
  }

  export type VerifyAggregateArgs = {
    /**
     * Filter which Verify to aggregate.
     * 
    **/
    where?: VerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifies to fetch.
     * 
    **/
    orderBy?: Enumerable<VerifyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifies
    **/
    _count?: true | VerifyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerifyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerifyMaxAggregateInputType
  }

  export type GetVerifyAggregateType<T extends VerifyAggregateArgs> = {
        [P in keyof T & keyof AggregateVerify]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerify[P]>
      : GetScalarType<T[P], AggregateVerify[P]>
  }




  export type VerifyGroupByArgs = {
    where?: VerifyWhereInput
    orderBy?: Enumerable<VerifyOrderByWithAggregationInput>
    by: Array<VerifyScalarFieldEnum>
    having?: VerifyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerifyCountAggregateInputType | true
    _min?: VerifyMinAggregateInputType
    _max?: VerifyMaxAggregateInputType
  }


  export type VerifyGroupByOutputType = {
    id: string
    UID: string | null
    phoneNumber: string | null
    countryCode: CountryCode | null
    createdAt: Date | null
    creditConfigId: string | null
    OTP: string | null
    email: string | null
    userId: string | null
    orderPaymentMethod: OrderPaymentMethodsEnum | null
    _count: VerifyCountAggregateOutputType | null
    _min: VerifyMinAggregateOutputType | null
    _max: VerifyMaxAggregateOutputType | null
  }

  type GetVerifyGroupByPayload<T extends VerifyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VerifyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerifyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerifyGroupByOutputType[P]>
            : GetScalarType<T[P], VerifyGroupByOutputType[P]>
        }
      >
    >


  export type VerifySelect = {
    id?: boolean
    UID?: boolean
    phoneNumber?: boolean
    countryCode?: boolean
    createdAt?: boolean
    creditConfigId?: boolean
    OTP?: boolean
    email?: boolean
    userId?: boolean
    orderPaymentMethod?: boolean
    user?: boolean | UserArgs
  }

  export type VerifyInclude = {
    user?: boolean | UserArgs
  }

  export type VerifyGetPayload<
    S extends boolean | null | undefined | VerifyArgs,
    U = keyof S
      > = S extends true
        ? Verify
    : S extends undefined
    ? never
    : S extends VerifyArgs | VerifyFindManyArgs
    ?'include' extends U
    ? Verify  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Verify ? Verify[P] : never
  } 
    : Verify
  : Verify


  type VerifyCountArgs = Merge<
    Omit<VerifyFindManyArgs, 'select' | 'include'> & {
      select?: VerifyCountAggregateInputType | true
    }
  >

  export interface VerifyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Verify that matches the filter.
     * @param {VerifyFindUniqueArgs} args - Arguments to find a Verify
     * @example
     * // Get one Verify
     * const verify = await prisma.verify.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerifyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VerifyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Verify'> extends True ? CheckSelect<T, Prisma__VerifyClient<Verify>, Prisma__VerifyClient<VerifyGetPayload<T>>> : CheckSelect<T, Prisma__VerifyClient<Verify | null >, Prisma__VerifyClient<VerifyGetPayload<T> | null >>

    /**
     * Find the first Verify that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyFindFirstArgs} args - Arguments to find a Verify
     * @example
     * // Get one Verify
     * const verify = await prisma.verify.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerifyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VerifyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Verify'> extends True ? CheckSelect<T, Prisma__VerifyClient<Verify>, Prisma__VerifyClient<VerifyGetPayload<T>>> : CheckSelect<T, Prisma__VerifyClient<Verify | null >, Prisma__VerifyClient<VerifyGetPayload<T> | null >>

    /**
     * Find zero or more Verifies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifies
     * const verifies = await prisma.verify.findMany()
     * 
     * // Get first 10 Verifies
     * const verifies = await prisma.verify.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verifyWithIdOnly = await prisma.verify.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VerifyFindManyArgs>(
      args?: SelectSubset<T, VerifyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Verify>>, PrismaPromise<Array<VerifyGetPayload<T>>>>

    /**
     * Create a Verify.
     * @param {VerifyCreateArgs} args - Arguments to create a Verify.
     * @example
     * // Create one Verify
     * const Verify = await prisma.verify.create({
     *   data: {
     *     // ... data to create a Verify
     *   }
     * })
     * 
    **/
    create<T extends VerifyCreateArgs>(
      args: SelectSubset<T, VerifyCreateArgs>
    ): CheckSelect<T, Prisma__VerifyClient<Verify>, Prisma__VerifyClient<VerifyGetPayload<T>>>

    /**
     * Create many Verifies.
     *     @param {VerifyCreateManyArgs} args - Arguments to create many Verifies.
     *     @example
     *     // Create many Verifies
     *     const verify = await prisma.verify.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerifyCreateManyArgs>(
      args?: SelectSubset<T, VerifyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Verify.
     * @param {VerifyDeleteArgs} args - Arguments to delete one Verify.
     * @example
     * // Delete one Verify
     * const Verify = await prisma.verify.delete({
     *   where: {
     *     // ... filter to delete one Verify
     *   }
     * })
     * 
    **/
    delete<T extends VerifyDeleteArgs>(
      args: SelectSubset<T, VerifyDeleteArgs>
    ): CheckSelect<T, Prisma__VerifyClient<Verify>, Prisma__VerifyClient<VerifyGetPayload<T>>>

    /**
     * Update one Verify.
     * @param {VerifyUpdateArgs} args - Arguments to update one Verify.
     * @example
     * // Update one Verify
     * const verify = await prisma.verify.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerifyUpdateArgs>(
      args: SelectSubset<T, VerifyUpdateArgs>
    ): CheckSelect<T, Prisma__VerifyClient<Verify>, Prisma__VerifyClient<VerifyGetPayload<T>>>

    /**
     * Delete zero or more Verifies.
     * @param {VerifyDeleteManyArgs} args - Arguments to filter Verifies to delete.
     * @example
     * // Delete a few Verifies
     * const { count } = await prisma.verify.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerifyDeleteManyArgs>(
      args?: SelectSubset<T, VerifyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifies
     * const verify = await prisma.verify.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerifyUpdateManyArgs>(
      args: SelectSubset<T, VerifyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Verify.
     * @param {VerifyUpsertArgs} args - Arguments to update or create a Verify.
     * @example
     * // Update or create a Verify
     * const verify = await prisma.verify.upsert({
     *   create: {
     *     // ... data to create a Verify
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verify we want to update
     *   }
     * })
    **/
    upsert<T extends VerifyUpsertArgs>(
      args: SelectSubset<T, VerifyUpsertArgs>
    ): CheckSelect<T, Prisma__VerifyClient<Verify>, Prisma__VerifyClient<VerifyGetPayload<T>>>

    /**
     * Count the number of Verifies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyCountArgs} args - Arguments to filter Verifies to count.
     * @example
     * // Count the number of Verifies
     * const count = await prisma.verify.count({
     *   where: {
     *     // ... the filter for the Verifies we want to count
     *   }
     * })
    **/
    count<T extends VerifyCountArgs>(
      args?: Subset<T, VerifyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerifyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verify.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerifyAggregateArgs>(args: Subset<T, VerifyAggregateArgs>): PrismaPromise<GetVerifyAggregateType<T>>

    /**
     * Group by Verify.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerifyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerifyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerifyGroupByArgs['orderBy'] }
        : { orderBy?: VerifyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerifyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerifyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verify.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerifyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Verify findUnique
   */
  export type VerifyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Verify
     * 
    **/
    select?: VerifySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerifyInclude | null
    /**
     * Throw an Error if a Verify can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Verify to fetch.
     * 
    **/
    where: VerifyWhereUniqueInput
  }


  /**
   * Verify findFirst
   */
  export type VerifyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Verify
     * 
    **/
    select?: VerifySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerifyInclude | null
    /**
     * Throw an Error if a Verify can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Verify to fetch.
     * 
    **/
    where?: VerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifies to fetch.
     * 
    **/
    orderBy?: Enumerable<VerifyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifies.
     * 
    **/
    cursor?: VerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifies.
     * 
    **/
    distinct?: Enumerable<VerifyScalarFieldEnum>
  }


  /**
   * Verify findMany
   */
  export type VerifyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Verify
     * 
    **/
    select?: VerifySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerifyInclude | null
    /**
     * Filter, which Verifies to fetch.
     * 
    **/
    where?: VerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifies to fetch.
     * 
    **/
    orderBy?: Enumerable<VerifyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifies.
     * 
    **/
    cursor?: VerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VerifyScalarFieldEnum>
  }


  /**
   * Verify create
   */
  export type VerifyCreateArgs = {
    /**
     * Select specific fields to fetch from the Verify
     * 
    **/
    select?: VerifySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerifyInclude | null
    /**
     * The data needed to create a Verify.
     * 
    **/
    data: XOR<VerifyCreateInput, VerifyUncheckedCreateInput>
  }


  /**
   * Verify createMany
   */
  export type VerifyCreateManyArgs = {
    /**
     * The data used to create many Verifies.
     * 
    **/
    data: Enumerable<VerifyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Verify update
   */
  export type VerifyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Verify
     * 
    **/
    select?: VerifySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerifyInclude | null
    /**
     * The data needed to update a Verify.
     * 
    **/
    data: XOR<VerifyUpdateInput, VerifyUncheckedUpdateInput>
    /**
     * Choose, which Verify to update.
     * 
    **/
    where: VerifyWhereUniqueInput
  }


  /**
   * Verify updateMany
   */
  export type VerifyUpdateManyArgs = {
    /**
     * The data used to update Verifies.
     * 
    **/
    data: XOR<VerifyUpdateManyMutationInput, VerifyUncheckedUpdateManyInput>
    /**
     * Filter which Verifies to update
     * 
    **/
    where?: VerifyWhereInput
  }


  /**
   * Verify upsert
   */
  export type VerifyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Verify
     * 
    **/
    select?: VerifySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerifyInclude | null
    /**
     * The filter to search for the Verify to update in case it exists.
     * 
    **/
    where: VerifyWhereUniqueInput
    /**
     * In case the Verify found by the `where` argument doesn't exist, create a new Verify with this data.
     * 
    **/
    create: XOR<VerifyCreateInput, VerifyUncheckedCreateInput>
    /**
     * In case the Verify was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VerifyUpdateInput, VerifyUncheckedUpdateInput>
  }


  /**
   * Verify delete
   */
  export type VerifyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Verify
     * 
    **/
    select?: VerifySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerifyInclude | null
    /**
     * Filter which Verify to delete.
     * 
    **/
    where: VerifyWhereUniqueInput
  }


  /**
   * Verify deleteMany
   */
  export type VerifyDeleteManyArgs = {
    /**
     * Filter which Verifies to delete
     * 
    **/
    where?: VerifyWhereInput
  }


  /**
   * Verify without action
   */
  export type VerifyArgs = {
    /**
     * Select specific fields to fetch from the Verify
     * 
    **/
    select?: VerifySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VerifyInclude | null
  }



  /**
   * Model Login
   */


  export type AggregateLogin = {
    _count: LoginCountAggregateOutputType | null
    _min: LoginMinAggregateOutputType | null
    _max: LoginMaxAggregateOutputType | null
  }

  export type LoginMinAggregateOutputType = {
    id: string | null
    qrKey: string | null
    jwt: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LoginMaxAggregateOutputType = {
    id: string | null
    qrKey: string | null
    jwt: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LoginCountAggregateOutputType = {
    id: number
    qrKey: number
    jwt: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LoginMinAggregateInputType = {
    id?: true
    qrKey?: true
    jwt?: true
    userId?: true
    createdAt?: true
  }

  export type LoginMaxAggregateInputType = {
    id?: true
    qrKey?: true
    jwt?: true
    userId?: true
    createdAt?: true
  }

  export type LoginCountAggregateInputType = {
    id?: true
    qrKey?: true
    jwt?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LoginAggregateArgs = {
    /**
     * Filter which Login to aggregate.
     * 
    **/
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     * 
    **/
    orderBy?: Enumerable<LoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logins
    **/
    _count?: true | LoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginMaxAggregateInputType
  }

  export type GetLoginAggregateType<T extends LoginAggregateArgs> = {
        [P in keyof T & keyof AggregateLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogin[P]>
      : GetScalarType<T[P], AggregateLogin[P]>
  }




  export type LoginGroupByArgs = {
    where?: LoginWhereInput
    orderBy?: Enumerable<LoginOrderByWithAggregationInput>
    by: Array<LoginScalarFieldEnum>
    having?: LoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginCountAggregateInputType | true
    _min?: LoginMinAggregateInputType
    _max?: LoginMaxAggregateInputType
  }


  export type LoginGroupByOutputType = {
    id: string
    qrKey: string | null
    jwt: string | null
    userId: string | null
    createdAt: Date
    _count: LoginCountAggregateOutputType | null
    _min: LoginMinAggregateOutputType | null
    _max: LoginMaxAggregateOutputType | null
  }

  type GetLoginGroupByPayload<T extends LoginGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginGroupByOutputType[P]>
            : GetScalarType<T[P], LoginGroupByOutputType[P]>
        }
      >
    >


  export type LoginSelect = {
    id?: boolean
    qrKey?: boolean
    jwt?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs
  }

  export type LoginInclude = {
    user?: boolean | UserArgs
  }

  export type LoginGetPayload<
    S extends boolean | null | undefined | LoginArgs,
    U = keyof S
      > = S extends true
        ? Login
    : S extends undefined
    ? never
    : S extends LoginArgs | LoginFindManyArgs
    ?'include' extends U
    ? Login  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Login ? Login[P] : never
  } 
    : Login
  : Login


  type LoginCountArgs = Merge<
    Omit<LoginFindManyArgs, 'select' | 'include'> & {
      select?: LoginCountAggregateInputType | true
    }
  >

  export interface LoginDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Login that matches the filter.
     * @param {LoginFindUniqueArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoginFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoginFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Login'> extends True ? CheckSelect<T, Prisma__LoginClient<Login>, Prisma__LoginClient<LoginGetPayload<T>>> : CheckSelect<T, Prisma__LoginClient<Login | null >, Prisma__LoginClient<LoginGetPayload<T> | null >>

    /**
     * Find the first Login that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginFindFirstArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoginFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoginFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Login'> extends True ? CheckSelect<T, Prisma__LoginClient<Login>, Prisma__LoginClient<LoginGetPayload<T>>> : CheckSelect<T, Prisma__LoginClient<Login | null >, Prisma__LoginClient<LoginGetPayload<T> | null >>

    /**
     * Find zero or more Logins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logins
     * const logins = await prisma.login.findMany()
     * 
     * // Get first 10 Logins
     * const logins = await prisma.login.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginWithIdOnly = await prisma.login.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoginFindManyArgs>(
      args?: SelectSubset<T, LoginFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Login>>, PrismaPromise<Array<LoginGetPayload<T>>>>

    /**
     * Create a Login.
     * @param {LoginCreateArgs} args - Arguments to create a Login.
     * @example
     * // Create one Login
     * const Login = await prisma.login.create({
     *   data: {
     *     // ... data to create a Login
     *   }
     * })
     * 
    **/
    create<T extends LoginCreateArgs>(
      args: SelectSubset<T, LoginCreateArgs>
    ): CheckSelect<T, Prisma__LoginClient<Login>, Prisma__LoginClient<LoginGetPayload<T>>>

    /**
     * Create many Logins.
     *     @param {LoginCreateManyArgs} args - Arguments to create many Logins.
     *     @example
     *     // Create many Logins
     *     const login = await prisma.login.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoginCreateManyArgs>(
      args?: SelectSubset<T, LoginCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Login.
     * @param {LoginDeleteArgs} args - Arguments to delete one Login.
     * @example
     * // Delete one Login
     * const Login = await prisma.login.delete({
     *   where: {
     *     // ... filter to delete one Login
     *   }
     * })
     * 
    **/
    delete<T extends LoginDeleteArgs>(
      args: SelectSubset<T, LoginDeleteArgs>
    ): CheckSelect<T, Prisma__LoginClient<Login>, Prisma__LoginClient<LoginGetPayload<T>>>

    /**
     * Update one Login.
     * @param {LoginUpdateArgs} args - Arguments to update one Login.
     * @example
     * // Update one Login
     * const login = await prisma.login.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoginUpdateArgs>(
      args: SelectSubset<T, LoginUpdateArgs>
    ): CheckSelect<T, Prisma__LoginClient<Login>, Prisma__LoginClient<LoginGetPayload<T>>>

    /**
     * Delete zero or more Logins.
     * @param {LoginDeleteManyArgs} args - Arguments to filter Logins to delete.
     * @example
     * // Delete a few Logins
     * const { count } = await prisma.login.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoginDeleteManyArgs>(
      args?: SelectSubset<T, LoginDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logins
     * const login = await prisma.login.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoginUpdateManyArgs>(
      args: SelectSubset<T, LoginUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Login.
     * @param {LoginUpsertArgs} args - Arguments to update or create a Login.
     * @example
     * // Update or create a Login
     * const login = await prisma.login.upsert({
     *   create: {
     *     // ... data to create a Login
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Login we want to update
     *   }
     * })
    **/
    upsert<T extends LoginUpsertArgs>(
      args: SelectSubset<T, LoginUpsertArgs>
    ): CheckSelect<T, Prisma__LoginClient<Login>, Prisma__LoginClient<LoginGetPayload<T>>>

    /**
     * Count the number of Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCountArgs} args - Arguments to filter Logins to count.
     * @example
     * // Count the number of Logins
     * const count = await prisma.login.count({
     *   where: {
     *     // ... the filter for the Logins we want to count
     *   }
     * })
    **/
    count<T extends LoginCountArgs>(
      args?: Subset<T, LoginCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginAggregateArgs>(args: Subset<T, LoginAggregateArgs>): PrismaPromise<GetLoginAggregateType<T>>

    /**
     * Group by Login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginGroupByArgs['orderBy'] }
        : { orderBy?: LoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Login.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoginClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Login findUnique
   */
  export type LoginFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Login
     * 
    **/
    select?: LoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoginInclude | null
    /**
     * Throw an Error if a Login can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Login to fetch.
     * 
    **/
    where: LoginWhereUniqueInput
  }


  /**
   * Login findFirst
   */
  export type LoginFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Login
     * 
    **/
    select?: LoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoginInclude | null
    /**
     * Throw an Error if a Login can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Login to fetch.
     * 
    **/
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     * 
    **/
    orderBy?: Enumerable<LoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logins.
     * 
    **/
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logins.
     * 
    **/
    distinct?: Enumerable<LoginScalarFieldEnum>
  }


  /**
   * Login findMany
   */
  export type LoginFindManyArgs = {
    /**
     * Select specific fields to fetch from the Login
     * 
    **/
    select?: LoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoginInclude | null
    /**
     * Filter, which Logins to fetch.
     * 
    **/
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     * 
    **/
    orderBy?: Enumerable<LoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logins.
     * 
    **/
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LoginScalarFieldEnum>
  }


  /**
   * Login create
   */
  export type LoginCreateArgs = {
    /**
     * Select specific fields to fetch from the Login
     * 
    **/
    select?: LoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoginInclude | null
    /**
     * The data needed to create a Login.
     * 
    **/
    data: XOR<LoginCreateInput, LoginUncheckedCreateInput>
  }


  /**
   * Login createMany
   */
  export type LoginCreateManyArgs = {
    /**
     * The data used to create many Logins.
     * 
    **/
    data: Enumerable<LoginCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Login update
   */
  export type LoginUpdateArgs = {
    /**
     * Select specific fields to fetch from the Login
     * 
    **/
    select?: LoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoginInclude | null
    /**
     * The data needed to update a Login.
     * 
    **/
    data: XOR<LoginUpdateInput, LoginUncheckedUpdateInput>
    /**
     * Choose, which Login to update.
     * 
    **/
    where: LoginWhereUniqueInput
  }


  /**
   * Login updateMany
   */
  export type LoginUpdateManyArgs = {
    /**
     * The data used to update Logins.
     * 
    **/
    data: XOR<LoginUpdateManyMutationInput, LoginUncheckedUpdateManyInput>
    /**
     * Filter which Logins to update
     * 
    **/
    where?: LoginWhereInput
  }


  /**
   * Login upsert
   */
  export type LoginUpsertArgs = {
    /**
     * Select specific fields to fetch from the Login
     * 
    **/
    select?: LoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoginInclude | null
    /**
     * The filter to search for the Login to update in case it exists.
     * 
    **/
    where: LoginWhereUniqueInput
    /**
     * In case the Login found by the `where` argument doesn't exist, create a new Login with this data.
     * 
    **/
    create: XOR<LoginCreateInput, LoginUncheckedCreateInput>
    /**
     * In case the Login was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LoginUpdateInput, LoginUncheckedUpdateInput>
  }


  /**
   * Login delete
   */
  export type LoginDeleteArgs = {
    /**
     * Select specific fields to fetch from the Login
     * 
    **/
    select?: LoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoginInclude | null
    /**
     * Filter which Login to delete.
     * 
    **/
    where: LoginWhereUniqueInput
  }


  /**
   * Login deleteMany
   */
  export type LoginDeleteManyArgs = {
    /**
     * Filter which Logins to delete
     * 
    **/
    where?: LoginWhereInput
  }


  /**
   * Login without action
   */
  export type LoginArgs = {
    /**
     * Select specific fields to fetch from the Login
     * 
    **/
    select?: LoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LoginInclude | null
  }



  /**
   * Model Visit
   */


  export type AggregateVisit = {
    _count: VisitCountAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  export type VisitMinAggregateOutputType = {
    id: string | null
    account: string | null
    createdAt: Date | null
    visitedBy: string | null
    visitedByReference: string | null
    whenVisitTookPlace: Date | null
  }

  export type VisitMaxAggregateOutputType = {
    id: string | null
    account: string | null
    createdAt: Date | null
    visitedBy: string | null
    visitedByReference: string | null
    whenVisitTookPlace: Date | null
  }

  export type VisitCountAggregateOutputType = {
    id: number
    account: number
    createdAt: number
    visitedBy: number
    visitedByReference: number
    whenVisitTookPlace: number
    _all: number
  }


  export type VisitMinAggregateInputType = {
    id?: true
    account?: true
    createdAt?: true
    visitedBy?: true
    visitedByReference?: true
    whenVisitTookPlace?: true
  }

  export type VisitMaxAggregateInputType = {
    id?: true
    account?: true
    createdAt?: true
    visitedBy?: true
    visitedByReference?: true
    whenVisitTookPlace?: true
  }

  export type VisitCountAggregateInputType = {
    id?: true
    account?: true
    createdAt?: true
    visitedBy?: true
    visitedByReference?: true
    whenVisitTookPlace?: true
    _all?: true
  }

  export type VisitAggregateArgs = {
    /**
     * Filter which Visit to aggregate.
     * 
    **/
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     * 
    **/
    orderBy?: Enumerable<VisitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visits
    **/
    _count?: true | VisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitMaxAggregateInputType
  }

  export type GetVisitAggregateType<T extends VisitAggregateArgs> = {
        [P in keyof T & keyof AggregateVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisit[P]>
      : GetScalarType<T[P], AggregateVisit[P]>
  }




  export type VisitGroupByArgs = {
    where?: VisitWhereInput
    orderBy?: Enumerable<VisitOrderByWithAggregationInput>
    by: Array<VisitScalarFieldEnum>
    having?: VisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitCountAggregateInputType | true
    _min?: VisitMinAggregateInputType
    _max?: VisitMaxAggregateInputType
  }


  export type VisitGroupByOutputType = {
    id: string
    account: string
    createdAt: Date | null
    visitedBy: string | null
    visitedByReference: string | null
    whenVisitTookPlace: Date | null
    _count: VisitCountAggregateOutputType | null
    _min: VisitMinAggregateOutputType | null
    _max: VisitMaxAggregateOutputType | null
  }

  type GetVisitGroupByPayload<T extends VisitGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitGroupByOutputType[P]>
            : GetScalarType<T[P], VisitGroupByOutputType[P]>
        }
      >
    >


  export type VisitSelect = {
    id?: boolean
    account?: boolean
    createdAt?: boolean
    visitedBy?: boolean
    visitedByReference?: boolean
    whenVisitTookPlace?: boolean
    wallet?: boolean | WalletArgs
    visited?: boolean | UserArgs
  }

  export type VisitInclude = {
    wallet?: boolean | WalletArgs
    visited?: boolean | UserArgs
  }

  export type VisitGetPayload<
    S extends boolean | null | undefined | VisitArgs,
    U = keyof S
      > = S extends true
        ? Visit
    : S extends undefined
    ? never
    : S extends VisitArgs | VisitFindManyArgs
    ?'include' extends U
    ? Visit  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :
        P extends 'visited' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :
        P extends 'visited' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Visit ? Visit[P] : never
  } 
    : Visit
  : Visit


  type VisitCountArgs = Merge<
    Omit<VisitFindManyArgs, 'select' | 'include'> & {
      select?: VisitCountAggregateInputType | true
    }
  >

  export interface VisitDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Visit that matches the filter.
     * @param {VisitFindUniqueArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VisitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VisitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Visit'> extends True ? CheckSelect<T, Prisma__VisitClient<Visit>, Prisma__VisitClient<VisitGetPayload<T>>> : CheckSelect<T, Prisma__VisitClient<Visit | null >, Prisma__VisitClient<VisitGetPayload<T> | null >>

    /**
     * Find the first Visit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindFirstArgs} args - Arguments to find a Visit
     * @example
     * // Get one Visit
     * const visit = await prisma.visit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VisitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VisitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Visit'> extends True ? CheckSelect<T, Prisma__VisitClient<Visit>, Prisma__VisitClient<VisitGetPayload<T>>> : CheckSelect<T, Prisma__VisitClient<Visit | null >, Prisma__VisitClient<VisitGetPayload<T> | null >>

    /**
     * Find zero or more Visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visits
     * const visits = await prisma.visit.findMany()
     * 
     * // Get first 10 Visits
     * const visits = await prisma.visit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitWithIdOnly = await prisma.visit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VisitFindManyArgs>(
      args?: SelectSubset<T, VisitFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Visit>>, PrismaPromise<Array<VisitGetPayload<T>>>>

    /**
     * Create a Visit.
     * @param {VisitCreateArgs} args - Arguments to create a Visit.
     * @example
     * // Create one Visit
     * const Visit = await prisma.visit.create({
     *   data: {
     *     // ... data to create a Visit
     *   }
     * })
     * 
    **/
    create<T extends VisitCreateArgs>(
      args: SelectSubset<T, VisitCreateArgs>
    ): CheckSelect<T, Prisma__VisitClient<Visit>, Prisma__VisitClient<VisitGetPayload<T>>>

    /**
     * Create many Visits.
     *     @param {VisitCreateManyArgs} args - Arguments to create many Visits.
     *     @example
     *     // Create many Visits
     *     const visit = await prisma.visit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VisitCreateManyArgs>(
      args?: SelectSubset<T, VisitCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Visit.
     * @param {VisitDeleteArgs} args - Arguments to delete one Visit.
     * @example
     * // Delete one Visit
     * const Visit = await prisma.visit.delete({
     *   where: {
     *     // ... filter to delete one Visit
     *   }
     * })
     * 
    **/
    delete<T extends VisitDeleteArgs>(
      args: SelectSubset<T, VisitDeleteArgs>
    ): CheckSelect<T, Prisma__VisitClient<Visit>, Prisma__VisitClient<VisitGetPayload<T>>>

    /**
     * Update one Visit.
     * @param {VisitUpdateArgs} args - Arguments to update one Visit.
     * @example
     * // Update one Visit
     * const visit = await prisma.visit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VisitUpdateArgs>(
      args: SelectSubset<T, VisitUpdateArgs>
    ): CheckSelect<T, Prisma__VisitClient<Visit>, Prisma__VisitClient<VisitGetPayload<T>>>

    /**
     * Delete zero or more Visits.
     * @param {VisitDeleteManyArgs} args - Arguments to filter Visits to delete.
     * @example
     * // Delete a few Visits
     * const { count } = await prisma.visit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VisitDeleteManyArgs>(
      args?: SelectSubset<T, VisitDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visits
     * const visit = await prisma.visit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VisitUpdateManyArgs>(
      args: SelectSubset<T, VisitUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Visit.
     * @param {VisitUpsertArgs} args - Arguments to update or create a Visit.
     * @example
     * // Update or create a Visit
     * const visit = await prisma.visit.upsert({
     *   create: {
     *     // ... data to create a Visit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visit we want to update
     *   }
     * })
    **/
    upsert<T extends VisitUpsertArgs>(
      args: SelectSubset<T, VisitUpsertArgs>
    ): CheckSelect<T, Prisma__VisitClient<Visit>, Prisma__VisitClient<VisitGetPayload<T>>>

    /**
     * Count the number of Visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCountArgs} args - Arguments to filter Visits to count.
     * @example
     * // Count the number of Visits
     * const count = await prisma.visit.count({
     *   where: {
     *     // ... the filter for the Visits we want to count
     *   }
     * })
    **/
    count<T extends VisitCountArgs>(
      args?: Subset<T, VisitCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitAggregateArgs>(args: Subset<T, VisitAggregateArgs>): PrismaPromise<GetVisitAggregateType<T>>

    /**
     * Group by Visit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitGroupByArgs['orderBy'] }
        : { orderBy?: VisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VisitClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    visited<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Visit findUnique
   */
  export type VisitFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Visit
     * 
    **/
    select?: VisitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VisitInclude | null
    /**
     * Throw an Error if a Visit can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Visit to fetch.
     * 
    **/
    where: VisitWhereUniqueInput
  }


  /**
   * Visit findFirst
   */
  export type VisitFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Visit
     * 
    **/
    select?: VisitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VisitInclude | null
    /**
     * Throw an Error if a Visit can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Visit to fetch.
     * 
    **/
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     * 
    **/
    orderBy?: Enumerable<VisitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visits.
     * 
    **/
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visits.
     * 
    **/
    distinct?: Enumerable<VisitScalarFieldEnum>
  }


  /**
   * Visit findMany
   */
  export type VisitFindManyArgs = {
    /**
     * Select specific fields to fetch from the Visit
     * 
    **/
    select?: VisitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VisitInclude | null
    /**
     * Filter, which Visits to fetch.
     * 
    **/
    where?: VisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visits to fetch.
     * 
    **/
    orderBy?: Enumerable<VisitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visits.
     * 
    **/
    cursor?: VisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visits.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VisitScalarFieldEnum>
  }


  /**
   * Visit create
   */
  export type VisitCreateArgs = {
    /**
     * Select specific fields to fetch from the Visit
     * 
    **/
    select?: VisitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VisitInclude | null
    /**
     * The data needed to create a Visit.
     * 
    **/
    data: XOR<VisitCreateInput, VisitUncheckedCreateInput>
  }


  /**
   * Visit createMany
   */
  export type VisitCreateManyArgs = {
    /**
     * The data used to create many Visits.
     * 
    **/
    data: Enumerable<VisitCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Visit update
   */
  export type VisitUpdateArgs = {
    /**
     * Select specific fields to fetch from the Visit
     * 
    **/
    select?: VisitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VisitInclude | null
    /**
     * The data needed to update a Visit.
     * 
    **/
    data: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
    /**
     * Choose, which Visit to update.
     * 
    **/
    where: VisitWhereUniqueInput
  }


  /**
   * Visit updateMany
   */
  export type VisitUpdateManyArgs = {
    /**
     * The data used to update Visits.
     * 
    **/
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyInput>
    /**
     * Filter which Visits to update
     * 
    **/
    where?: VisitWhereInput
  }


  /**
   * Visit upsert
   */
  export type VisitUpsertArgs = {
    /**
     * Select specific fields to fetch from the Visit
     * 
    **/
    select?: VisitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VisitInclude | null
    /**
     * The filter to search for the Visit to update in case it exists.
     * 
    **/
    where: VisitWhereUniqueInput
    /**
     * In case the Visit found by the `where` argument doesn't exist, create a new Visit with this data.
     * 
    **/
    create: XOR<VisitCreateInput, VisitUncheckedCreateInput>
    /**
     * In case the Visit was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VisitUpdateInput, VisitUncheckedUpdateInput>
  }


  /**
   * Visit delete
   */
  export type VisitDeleteArgs = {
    /**
     * Select specific fields to fetch from the Visit
     * 
    **/
    select?: VisitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VisitInclude | null
    /**
     * Filter which Visit to delete.
     * 
    **/
    where: VisitWhereUniqueInput
  }


  /**
   * Visit deleteMany
   */
  export type VisitDeleteManyArgs = {
    /**
     * Filter which Visits to delete
     * 
    **/
    where?: VisitWhereInput
  }


  /**
   * Visit without action
   */
  export type VisitArgs = {
    /**
     * Select specific fields to fetch from the Visit
     * 
    **/
    select?: VisitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VisitInclude | null
  }



  /**
   * Model ReferenceNumber
   */


  export type AggregateReferenceNumber = {
    _count: ReferenceNumberCountAggregateOutputType | null
    _avg: ReferenceNumberAvgAggregateOutputType | null
    _sum: ReferenceNumberSumAggregateOutputType | null
    _min: ReferenceNumberMinAggregateOutputType | null
    _max: ReferenceNumberMaxAggregateOutputType | null
  }

  export type ReferenceNumberAvgAggregateOutputType = {
    lastReference: number | null
  }

  export type ReferenceNumberSumAggregateOutputType = {
    lastReference: number | null
  }

  export type ReferenceNumberMinAggregateOutputType = {
    id: string | null
    prefix: string | null
    lastReference: number | null
  }

  export type ReferenceNumberMaxAggregateOutputType = {
    id: string | null
    prefix: string | null
    lastReference: number | null
  }

  export type ReferenceNumberCountAggregateOutputType = {
    id: number
    prefix: number
    lastReference: number
    _all: number
  }


  export type ReferenceNumberAvgAggregateInputType = {
    lastReference?: true
  }

  export type ReferenceNumberSumAggregateInputType = {
    lastReference?: true
  }

  export type ReferenceNumberMinAggregateInputType = {
    id?: true
    prefix?: true
    lastReference?: true
  }

  export type ReferenceNumberMaxAggregateInputType = {
    id?: true
    prefix?: true
    lastReference?: true
  }

  export type ReferenceNumberCountAggregateInputType = {
    id?: true
    prefix?: true
    lastReference?: true
    _all?: true
  }

  export type ReferenceNumberAggregateArgs = {
    /**
     * Filter which ReferenceNumber to aggregate.
     * 
    **/
    where?: ReferenceNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceNumbers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReferenceNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceNumbers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceNumbers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferenceNumbers
    **/
    _count?: true | ReferenceNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferenceNumberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferenceNumberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceNumberMaxAggregateInputType
  }

  export type GetReferenceNumberAggregateType<T extends ReferenceNumberAggregateArgs> = {
        [P in keyof T & keyof AggregateReferenceNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferenceNumber[P]>
      : GetScalarType<T[P], AggregateReferenceNumber[P]>
  }




  export type ReferenceNumberGroupByArgs = {
    where?: ReferenceNumberWhereInput
    orderBy?: Enumerable<ReferenceNumberOrderByWithAggregationInput>
    by: Array<ReferenceNumberScalarFieldEnum>
    having?: ReferenceNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceNumberCountAggregateInputType | true
    _avg?: ReferenceNumberAvgAggregateInputType
    _sum?: ReferenceNumberSumAggregateInputType
    _min?: ReferenceNumberMinAggregateInputType
    _max?: ReferenceNumberMaxAggregateInputType
  }


  export type ReferenceNumberGroupByOutputType = {
    id: string
    prefix: string
    lastReference: number | null
    _count: ReferenceNumberCountAggregateOutputType | null
    _avg: ReferenceNumberAvgAggregateOutputType | null
    _sum: ReferenceNumberSumAggregateOutputType | null
    _min: ReferenceNumberMinAggregateOutputType | null
    _max: ReferenceNumberMaxAggregateOutputType | null
  }

  type GetReferenceNumberGroupByPayload<T extends ReferenceNumberGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReferenceNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceNumberGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceNumberGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceNumberSelect = {
    id?: boolean
    prefix?: boolean
    lastReference?: boolean
  }

  export type ReferenceNumberGetPayload<
    S extends boolean | null | undefined | ReferenceNumberArgs,
    U = keyof S
      > = S extends true
        ? ReferenceNumber
    : S extends undefined
    ? never
    : S extends ReferenceNumberArgs | ReferenceNumberFindManyArgs
    ?'include' extends U
    ? ReferenceNumber 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ReferenceNumber ? ReferenceNumber[P] : never
  } 
    : ReferenceNumber
  : ReferenceNumber


  type ReferenceNumberCountArgs = Merge<
    Omit<ReferenceNumberFindManyArgs, 'select' | 'include'> & {
      select?: ReferenceNumberCountAggregateInputType | true
    }
  >

  export interface ReferenceNumberDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ReferenceNumber that matches the filter.
     * @param {ReferenceNumberFindUniqueArgs} args - Arguments to find a ReferenceNumber
     * @example
     * // Get one ReferenceNumber
     * const referenceNumber = await prisma.referenceNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReferenceNumberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReferenceNumberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReferenceNumber'> extends True ? CheckSelect<T, Prisma__ReferenceNumberClient<ReferenceNumber>, Prisma__ReferenceNumberClient<ReferenceNumberGetPayload<T>>> : CheckSelect<T, Prisma__ReferenceNumberClient<ReferenceNumber | null >, Prisma__ReferenceNumberClient<ReferenceNumberGetPayload<T> | null >>

    /**
     * Find the first ReferenceNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceNumberFindFirstArgs} args - Arguments to find a ReferenceNumber
     * @example
     * // Get one ReferenceNumber
     * const referenceNumber = await prisma.referenceNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReferenceNumberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReferenceNumberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReferenceNumber'> extends True ? CheckSelect<T, Prisma__ReferenceNumberClient<ReferenceNumber>, Prisma__ReferenceNumberClient<ReferenceNumberGetPayload<T>>> : CheckSelect<T, Prisma__ReferenceNumberClient<ReferenceNumber | null >, Prisma__ReferenceNumberClient<ReferenceNumberGetPayload<T> | null >>

    /**
     * Find zero or more ReferenceNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceNumberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferenceNumbers
     * const referenceNumbers = await prisma.referenceNumber.findMany()
     * 
     * // Get first 10 ReferenceNumbers
     * const referenceNumbers = await prisma.referenceNumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referenceNumberWithIdOnly = await prisma.referenceNumber.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReferenceNumberFindManyArgs>(
      args?: SelectSubset<T, ReferenceNumberFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ReferenceNumber>>, PrismaPromise<Array<ReferenceNumberGetPayload<T>>>>

    /**
     * Create a ReferenceNumber.
     * @param {ReferenceNumberCreateArgs} args - Arguments to create a ReferenceNumber.
     * @example
     * // Create one ReferenceNumber
     * const ReferenceNumber = await prisma.referenceNumber.create({
     *   data: {
     *     // ... data to create a ReferenceNumber
     *   }
     * })
     * 
    **/
    create<T extends ReferenceNumberCreateArgs>(
      args: SelectSubset<T, ReferenceNumberCreateArgs>
    ): CheckSelect<T, Prisma__ReferenceNumberClient<ReferenceNumber>, Prisma__ReferenceNumberClient<ReferenceNumberGetPayload<T>>>

    /**
     * Create many ReferenceNumbers.
     *     @param {ReferenceNumberCreateManyArgs} args - Arguments to create many ReferenceNumbers.
     *     @example
     *     // Create many ReferenceNumbers
     *     const referenceNumber = await prisma.referenceNumber.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReferenceNumberCreateManyArgs>(
      args?: SelectSubset<T, ReferenceNumberCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ReferenceNumber.
     * @param {ReferenceNumberDeleteArgs} args - Arguments to delete one ReferenceNumber.
     * @example
     * // Delete one ReferenceNumber
     * const ReferenceNumber = await prisma.referenceNumber.delete({
     *   where: {
     *     // ... filter to delete one ReferenceNumber
     *   }
     * })
     * 
    **/
    delete<T extends ReferenceNumberDeleteArgs>(
      args: SelectSubset<T, ReferenceNumberDeleteArgs>
    ): CheckSelect<T, Prisma__ReferenceNumberClient<ReferenceNumber>, Prisma__ReferenceNumberClient<ReferenceNumberGetPayload<T>>>

    /**
     * Update one ReferenceNumber.
     * @param {ReferenceNumberUpdateArgs} args - Arguments to update one ReferenceNumber.
     * @example
     * // Update one ReferenceNumber
     * const referenceNumber = await prisma.referenceNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReferenceNumberUpdateArgs>(
      args: SelectSubset<T, ReferenceNumberUpdateArgs>
    ): CheckSelect<T, Prisma__ReferenceNumberClient<ReferenceNumber>, Prisma__ReferenceNumberClient<ReferenceNumberGetPayload<T>>>

    /**
     * Delete zero or more ReferenceNumbers.
     * @param {ReferenceNumberDeleteManyArgs} args - Arguments to filter ReferenceNumbers to delete.
     * @example
     * // Delete a few ReferenceNumbers
     * const { count } = await prisma.referenceNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReferenceNumberDeleteManyArgs>(
      args?: SelectSubset<T, ReferenceNumberDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferenceNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferenceNumbers
     * const referenceNumber = await prisma.referenceNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReferenceNumberUpdateManyArgs>(
      args: SelectSubset<T, ReferenceNumberUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferenceNumber.
     * @param {ReferenceNumberUpsertArgs} args - Arguments to update or create a ReferenceNumber.
     * @example
     * // Update or create a ReferenceNumber
     * const referenceNumber = await prisma.referenceNumber.upsert({
     *   create: {
     *     // ... data to create a ReferenceNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferenceNumber we want to update
     *   }
     * })
    **/
    upsert<T extends ReferenceNumberUpsertArgs>(
      args: SelectSubset<T, ReferenceNumberUpsertArgs>
    ): CheckSelect<T, Prisma__ReferenceNumberClient<ReferenceNumber>, Prisma__ReferenceNumberClient<ReferenceNumberGetPayload<T>>>

    /**
     * Count the number of ReferenceNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceNumberCountArgs} args - Arguments to filter ReferenceNumbers to count.
     * @example
     * // Count the number of ReferenceNumbers
     * const count = await prisma.referenceNumber.count({
     *   where: {
     *     // ... the filter for the ReferenceNumbers we want to count
     *   }
     * })
    **/
    count<T extends ReferenceNumberCountArgs>(
      args?: Subset<T, ReferenceNumberCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferenceNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceNumberAggregateArgs>(args: Subset<T, ReferenceNumberAggregateArgs>): PrismaPromise<GetReferenceNumberAggregateType<T>>

    /**
     * Group by ReferenceNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceNumberGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceNumberGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferenceNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReferenceNumberClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ReferenceNumber findUnique
   */
  export type ReferenceNumberFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ReferenceNumber
     * 
    **/
    select?: ReferenceNumberSelect | null
    /**
     * Throw an Error if a ReferenceNumber can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReferenceNumber to fetch.
     * 
    **/
    where: ReferenceNumberWhereUniqueInput
  }


  /**
   * ReferenceNumber findFirst
   */
  export type ReferenceNumberFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ReferenceNumber
     * 
    **/
    select?: ReferenceNumberSelect | null
    /**
     * Throw an Error if a ReferenceNumber can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ReferenceNumber to fetch.
     * 
    **/
    where?: ReferenceNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceNumbers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferenceNumbers.
     * 
    **/
    cursor?: ReferenceNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceNumbers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceNumbers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferenceNumbers.
     * 
    **/
    distinct?: Enumerable<ReferenceNumberScalarFieldEnum>
  }


  /**
   * ReferenceNumber findMany
   */
  export type ReferenceNumberFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReferenceNumber
     * 
    **/
    select?: ReferenceNumberSelect | null
    /**
     * Filter, which ReferenceNumbers to fetch.
     * 
    **/
    where?: ReferenceNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferenceNumbers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferenceNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferenceNumbers.
     * 
    **/
    cursor?: ReferenceNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferenceNumbers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferenceNumbers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReferenceNumberScalarFieldEnum>
  }


  /**
   * ReferenceNumber create
   */
  export type ReferenceNumberCreateArgs = {
    /**
     * Select specific fields to fetch from the ReferenceNumber
     * 
    **/
    select?: ReferenceNumberSelect | null
    /**
     * The data needed to create a ReferenceNumber.
     * 
    **/
    data: XOR<ReferenceNumberCreateInput, ReferenceNumberUncheckedCreateInput>
  }


  /**
   * ReferenceNumber createMany
   */
  export type ReferenceNumberCreateManyArgs = {
    /**
     * The data used to create many ReferenceNumbers.
     * 
    **/
    data: Enumerable<ReferenceNumberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReferenceNumber update
   */
  export type ReferenceNumberUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReferenceNumber
     * 
    **/
    select?: ReferenceNumberSelect | null
    /**
     * The data needed to update a ReferenceNumber.
     * 
    **/
    data: XOR<ReferenceNumberUpdateInput, ReferenceNumberUncheckedUpdateInput>
    /**
     * Choose, which ReferenceNumber to update.
     * 
    **/
    where: ReferenceNumberWhereUniqueInput
  }


  /**
   * ReferenceNumber updateMany
   */
  export type ReferenceNumberUpdateManyArgs = {
    /**
     * The data used to update ReferenceNumbers.
     * 
    **/
    data: XOR<ReferenceNumberUpdateManyMutationInput, ReferenceNumberUncheckedUpdateManyInput>
    /**
     * Filter which ReferenceNumbers to update
     * 
    **/
    where?: ReferenceNumberWhereInput
  }


  /**
   * ReferenceNumber upsert
   */
  export type ReferenceNumberUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReferenceNumber
     * 
    **/
    select?: ReferenceNumberSelect | null
    /**
     * The filter to search for the ReferenceNumber to update in case it exists.
     * 
    **/
    where: ReferenceNumberWhereUniqueInput
    /**
     * In case the ReferenceNumber found by the `where` argument doesn't exist, create a new ReferenceNumber with this data.
     * 
    **/
    create: XOR<ReferenceNumberCreateInput, ReferenceNumberUncheckedCreateInput>
    /**
     * In case the ReferenceNumber was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReferenceNumberUpdateInput, ReferenceNumberUncheckedUpdateInput>
  }


  /**
   * ReferenceNumber delete
   */
  export type ReferenceNumberDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReferenceNumber
     * 
    **/
    select?: ReferenceNumberSelect | null
    /**
     * Filter which ReferenceNumber to delete.
     * 
    **/
    where: ReferenceNumberWhereUniqueInput
  }


  /**
   * ReferenceNumber deleteMany
   */
  export type ReferenceNumberDeleteManyArgs = {
    /**
     * Filter which ReferenceNumbers to delete
     * 
    **/
    where?: ReferenceNumberWhereInput
  }


  /**
   * ReferenceNumber without action
   */
  export type ReferenceNumberArgs = {
    /**
     * Select specific fields to fetch from the ReferenceNumber
     * 
    **/
    select?: ReferenceNumberSelect | null
  }



  /**
   * Model Job
   */


  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    version: number | null
  }

  export type JobSumAggregateOutputType = {
    version: number | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    status: JobStatus | null
    version: number | null
    createdAt: Date | null
    name: string | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    status: JobStatus | null
    version: number | null
    createdAt: Date | null
    name: string | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    status: number
    version: number
    createdAt: number
    name: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    version?: true
  }

  export type JobSumAggregateInputType = {
    version?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    status?: true
    version?: true
    createdAt?: true
    name?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    status?: true
    version?: true
    createdAt?: true
    name?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    status?: true
    version?: true
    createdAt?: true
    name?: true
    _all?: true
  }

  export type JobAggregateArgs = {
    /**
     * Filter which Job to aggregate.
     * 
    **/
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs = {
    where?: JobWhereInput
    orderBy?: Enumerable<JobOrderByWithAggregationInput>
    by: Array<JobScalarFieldEnum>
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }


  export type JobGroupByOutputType = {
    id: string
    status: JobStatus
    version: number
    createdAt: Date
    name: string
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect = {
    id?: boolean
    status?: boolean
    version?: boolean
    createdAt?: boolean
    name?: boolean
  }

  export type JobGetPayload<
    S extends boolean | null | undefined | JobArgs,
    U = keyof S
      > = S extends true
        ? Job
    : S extends undefined
    ? never
    : S extends JobArgs | JobFindManyArgs
    ?'include' extends U
    ? Job 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Job ? Job[P] : never
  } 
    : Job
  : Job


  type JobCountArgs = Merge<
    Omit<JobFindManyArgs, 'select' | 'include'> & {
      select?: JobCountAggregateInputType | true
    }
  >

  export interface JobDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Job'> extends True ? CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>> : CheckSelect<T, Prisma__JobClient<Job | null >, Prisma__JobClient<JobGetPayload<T> | null >>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Job'> extends True ? CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>> : CheckSelect<T, Prisma__JobClient<Job | null >, Prisma__JobClient<JobGetPayload<T> | null >>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JobFindManyArgs>(
      args?: SelectSubset<T, JobFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Job>>, PrismaPromise<Array<JobGetPayload<T>>>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
    **/
    create<T extends JobCreateArgs>(
      args: SelectSubset<T, JobCreateArgs>
    ): CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>>

    /**
     * Create many Jobs.
     *     @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     *     @example
     *     // Create many Jobs
     *     const job = await prisma.job.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobCreateManyArgs>(
      args?: SelectSubset<T, JobCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
    **/
    delete<T extends JobDeleteArgs>(
      args: SelectSubset<T, JobDeleteArgs>
    ): CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobUpdateArgs>(
      args: SelectSubset<T, JobUpdateArgs>
    ): CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobDeleteManyArgs>(
      args?: SelectSubset<T, JobDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobUpdateManyArgs>(
      args: SelectSubset<T, JobUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
    **/
    upsert<T extends JobUpsertArgs>(
      args: SelectSubset<T, JobUpsertArgs>
    ): CheckSelect<T, Prisma__JobClient<Job>, Prisma__JobClient<JobGetPayload<T>>>

    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Throw an Error if a Job can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Job to fetch.
     * 
    **/
    where: JobWhereUniqueInput
  }


  /**
   * Job findFirst
   */
  export type JobFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Throw an Error if a Job can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Job to fetch.
     * 
    **/
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     * 
    **/
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     * 
    **/
    distinct?: Enumerable<JobScalarFieldEnum>
  }


  /**
   * Job findMany
   */
  export type JobFindManyArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Filter, which Jobs to fetch.
     * 
    **/
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     * 
    **/
    orderBy?: Enumerable<JobOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     * 
    **/
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobScalarFieldEnum>
  }


  /**
   * Job create
   */
  export type JobCreateArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * The data needed to create a Job.
     * 
    **/
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }


  /**
   * Job createMany
   */
  export type JobCreateManyArgs = {
    /**
     * The data used to create many Jobs.
     * 
    **/
    data: Enumerable<JobCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Job update
   */
  export type JobUpdateArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * The data needed to update a Job.
     * 
    **/
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     * 
    **/
    where: JobWhereUniqueInput
  }


  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs = {
    /**
     * The data used to update Jobs.
     * 
    **/
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     * 
    **/
    where?: JobWhereInput
  }


  /**
   * Job upsert
   */
  export type JobUpsertArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * The filter to search for the Job to update in case it exists.
     * 
    **/
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     * 
    **/
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }


  /**
   * Job delete
   */
  export type JobDeleteArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
    /**
     * Filter which Job to delete.
     * 
    **/
    where: JobWhereUniqueInput
  }


  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs = {
    /**
     * Filter which Jobs to delete
     * 
    **/
    where?: JobWhereInput
  }


  /**
   * Job without action
   */
  export type JobArgs = {
    /**
     * Select specific fields to fetch from the Job
     * 
    **/
    select?: JobSelect | null
  }



  /**
   * Model CreditConfiguration
   */


  export type AggregateCreditConfiguration = {
    _count: CreditConfigurationCountAggregateOutputType | null
    _avg: CreditConfigurationAvgAggregateOutputType | null
    _sum: CreditConfigurationSumAggregateOutputType | null
    _min: CreditConfigurationMinAggregateOutputType | null
    _max: CreditConfigurationMaxAggregateOutputType | null
  }

  export type CreditConfigurationAvgAggregateOutputType = {
    depositPercentage: number | null
    duration: number | null
    seviFeesPercentage: number | null
    daysToStartAfterDelivery: number | null
    lateInstallmentFeesPercentage: number | null
    affiliatePercentage: number | null
    creditLateFeesPercentage: number | null
    creditLateDays: number | null
    numberOfAllowedCredits: number | null
    fundFeesPercentage: number | null
  }

  export type CreditConfigurationSumAggregateOutputType = {
    depositPercentage: number | null
    duration: number | null
    seviFeesPercentage: number | null
    daysToStartAfterDelivery: number | null
    lateInstallmentFeesPercentage: number | null
    affiliatePercentage: number | null
    creditLateFeesPercentage: number | null
    creditLateDays: number | null
    numberOfAllowedCredits: number | null
    fundFeesPercentage: number | null
  }

  export type CreditConfigurationMinAggregateOutputType = {
    id: string | null
    name: string | null
    shouldPayDeposit: boolean | null
    depositPercentage: number | null
    duration: number | null
    slices: SlicesEnum | null
    seviFeesPercentage: number | null
    daysToStartAfterDelivery: number | null
    lateInstallmentFeesPercentage: number | null
    affiliatePercentage: number | null
    creditLateFeesPercentage: number | null
    creditLateDays: number | null
    createdAt: Date | null
    status: CreditConfigurationStatus | null
    numberOfAllowedCredits: number | null
    fundFeesPercentage: number | null
    fundId: string | null
  }

  export type CreditConfigurationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shouldPayDeposit: boolean | null
    depositPercentage: number | null
    duration: number | null
    slices: SlicesEnum | null
    seviFeesPercentage: number | null
    daysToStartAfterDelivery: number | null
    lateInstallmentFeesPercentage: number | null
    affiliatePercentage: number | null
    creditLateFeesPercentage: number | null
    creditLateDays: number | null
    createdAt: Date | null
    status: CreditConfigurationStatus | null
    numberOfAllowedCredits: number | null
    fundFeesPercentage: number | null
    fundId: string | null
  }

  export type CreditConfigurationCountAggregateOutputType = {
    id: number
    name: number
    shouldPayDeposit: number
    depositPercentage: number
    duration: number
    slices: number
    seviFeesPercentage: number
    daysToStartAfterDelivery: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt: number
    status: number
    numberOfAllowedCredits: number
    fundFeesPercentage: number
    fundId: number
    _all: number
  }


  export type CreditConfigurationAvgAggregateInputType = {
    depositPercentage?: true
    duration?: true
    seviFeesPercentage?: true
    daysToStartAfterDelivery?: true
    lateInstallmentFeesPercentage?: true
    affiliatePercentage?: true
    creditLateFeesPercentage?: true
    creditLateDays?: true
    numberOfAllowedCredits?: true
    fundFeesPercentage?: true
  }

  export type CreditConfigurationSumAggregateInputType = {
    depositPercentage?: true
    duration?: true
    seviFeesPercentage?: true
    daysToStartAfterDelivery?: true
    lateInstallmentFeesPercentage?: true
    affiliatePercentage?: true
    creditLateFeesPercentage?: true
    creditLateDays?: true
    numberOfAllowedCredits?: true
    fundFeesPercentage?: true
  }

  export type CreditConfigurationMinAggregateInputType = {
    id?: true
    name?: true
    shouldPayDeposit?: true
    depositPercentage?: true
    duration?: true
    slices?: true
    seviFeesPercentage?: true
    daysToStartAfterDelivery?: true
    lateInstallmentFeesPercentage?: true
    affiliatePercentage?: true
    creditLateFeesPercentage?: true
    creditLateDays?: true
    createdAt?: true
    status?: true
    numberOfAllowedCredits?: true
    fundFeesPercentage?: true
    fundId?: true
  }

  export type CreditConfigurationMaxAggregateInputType = {
    id?: true
    name?: true
    shouldPayDeposit?: true
    depositPercentage?: true
    duration?: true
    slices?: true
    seviFeesPercentage?: true
    daysToStartAfterDelivery?: true
    lateInstallmentFeesPercentage?: true
    affiliatePercentage?: true
    creditLateFeesPercentage?: true
    creditLateDays?: true
    createdAt?: true
    status?: true
    numberOfAllowedCredits?: true
    fundFeesPercentage?: true
    fundId?: true
  }

  export type CreditConfigurationCountAggregateInputType = {
    id?: true
    name?: true
    shouldPayDeposit?: true
    depositPercentage?: true
    duration?: true
    slices?: true
    seviFeesPercentage?: true
    daysToStartAfterDelivery?: true
    lateInstallmentFeesPercentage?: true
    affiliatePercentage?: true
    creditLateFeesPercentage?: true
    creditLateDays?: true
    createdAt?: true
    status?: true
    numberOfAllowedCredits?: true
    fundFeesPercentage?: true
    fundId?: true
    _all?: true
  }

  export type CreditConfigurationAggregateArgs = {
    /**
     * Filter which CreditConfiguration to aggregate.
     * 
    **/
    where?: CreditConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreditConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditConfigurations
    **/
    _count?: true | CreditConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditConfigurationMaxAggregateInputType
  }

  export type GetCreditConfigurationAggregateType<T extends CreditConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditConfiguration[P]>
      : GetScalarType<T[P], AggregateCreditConfiguration[P]>
  }




  export type CreditConfigurationGroupByArgs = {
    where?: CreditConfigurationWhereInput
    orderBy?: Enumerable<CreditConfigurationOrderByWithAggregationInput>
    by: Array<CreditConfigurationScalarFieldEnum>
    having?: CreditConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditConfigurationCountAggregateInputType | true
    _avg?: CreditConfigurationAvgAggregateInputType
    _sum?: CreditConfigurationSumAggregateInputType
    _min?: CreditConfigurationMinAggregateInputType
    _max?: CreditConfigurationMaxAggregateInputType
  }


  export type CreditConfigurationGroupByOutputType = {
    id: string
    name: string
    shouldPayDeposit: boolean | null
    depositPercentage: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt: Date | null
    status: CreditConfigurationStatus
    numberOfAllowedCredits: number
    fundFeesPercentage: number | null
    fundId: string
    _count: CreditConfigurationCountAggregateOutputType | null
    _avg: CreditConfigurationAvgAggregateOutputType | null
    _sum: CreditConfigurationSumAggregateOutputType | null
    _min: CreditConfigurationMinAggregateOutputType | null
    _max: CreditConfigurationMaxAggregateOutputType | null
  }

  type GetCreditConfigurationGroupByPayload<T extends CreditConfigurationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CreditConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], CreditConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type CreditConfigurationSelect = {
    id?: boolean
    name?: boolean
    shouldPayDeposit?: boolean
    depositPercentage?: boolean
    duration?: boolean
    slices?: boolean
    seviFeesPercentage?: boolean
    daysToStartAfterDelivery?: boolean
    lateInstallmentFeesPercentage?: boolean
    affiliatePercentage?: boolean
    creditLateFeesPercentage?: boolean
    creditLateDays?: boolean
    createdAt?: boolean
    status?: boolean
    numberOfAllowedCredits?: boolean
    fundFeesPercentage?: boolean
    fundId?: boolean
    wallet?: boolean | WalletArgs
    credit?: boolean | CreditFindManyArgs
    attachedWallets?: boolean | CreditConfigurationsWalletsFindManyArgs
    Installment?: boolean | InstallmentFindManyArgs
    creditRequests?: boolean | CreditRequestArgs
    _count?: boolean | CreditConfigurationCountOutputTypeArgs
  }

  export type CreditConfigurationInclude = {
    wallet?: boolean | WalletArgs
    credit?: boolean | CreditFindManyArgs
    attachedWallets?: boolean | CreditConfigurationsWalletsFindManyArgs
    Installment?: boolean | InstallmentFindManyArgs
    creditRequests?: boolean | CreditRequestArgs
    _count?: boolean | CreditConfigurationCountOutputTypeArgs
  }

  export type CreditConfigurationGetPayload<
    S extends boolean | null | undefined | CreditConfigurationArgs,
    U = keyof S
      > = S extends true
        ? CreditConfiguration
    : S extends undefined
    ? never
    : S extends CreditConfigurationArgs | CreditConfigurationFindManyArgs
    ?'include' extends U
    ? CreditConfiguration  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :
        P extends 'credit' ? Array < CreditGetPayload<S['include'][P]>>  :
        P extends 'attachedWallets' ? Array < CreditConfigurationsWalletsGetPayload<S['include'][P]>>  :
        P extends 'Installment' ? Array < InstallmentGetPayload<S['include'][P]>>  :
        P extends 'creditRequests' ? CreditRequestGetPayload<S['include'][P]> | null :
        P extends '_count' ? CreditConfigurationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :
        P extends 'credit' ? Array < CreditGetPayload<S['select'][P]>>  :
        P extends 'attachedWallets' ? Array < CreditConfigurationsWalletsGetPayload<S['select'][P]>>  :
        P extends 'Installment' ? Array < InstallmentGetPayload<S['select'][P]>>  :
        P extends 'creditRequests' ? CreditRequestGetPayload<S['select'][P]> | null :
        P extends '_count' ? CreditConfigurationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CreditConfiguration ? CreditConfiguration[P] : never
  } 
    : CreditConfiguration
  : CreditConfiguration


  type CreditConfigurationCountArgs = Merge<
    Omit<CreditConfigurationFindManyArgs, 'select' | 'include'> & {
      select?: CreditConfigurationCountAggregateInputType | true
    }
  >

  export interface CreditConfigurationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CreditConfiguration that matches the filter.
     * @param {CreditConfigurationFindUniqueArgs} args - Arguments to find a CreditConfiguration
     * @example
     * // Get one CreditConfiguration
     * const creditConfiguration = await prisma.creditConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreditConfigurationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreditConfigurationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CreditConfiguration'> extends True ? CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration>, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T>>> : CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration | null >, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T> | null >>

    /**
     * Find the first CreditConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationFindFirstArgs} args - Arguments to find a CreditConfiguration
     * @example
     * // Get one CreditConfiguration
     * const creditConfiguration = await prisma.creditConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreditConfigurationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreditConfigurationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CreditConfiguration'> extends True ? CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration>, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T>>> : CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration | null >, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T> | null >>

    /**
     * Find zero or more CreditConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditConfigurations
     * const creditConfigurations = await prisma.creditConfiguration.findMany()
     * 
     * // Get first 10 CreditConfigurations
     * const creditConfigurations = await prisma.creditConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditConfigurationWithIdOnly = await prisma.creditConfiguration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreditConfigurationFindManyArgs>(
      args?: SelectSubset<T, CreditConfigurationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CreditConfiguration>>, PrismaPromise<Array<CreditConfigurationGetPayload<T>>>>

    /**
     * Create a CreditConfiguration.
     * @param {CreditConfigurationCreateArgs} args - Arguments to create a CreditConfiguration.
     * @example
     * // Create one CreditConfiguration
     * const CreditConfiguration = await prisma.creditConfiguration.create({
     *   data: {
     *     // ... data to create a CreditConfiguration
     *   }
     * })
     * 
    **/
    create<T extends CreditConfigurationCreateArgs>(
      args: SelectSubset<T, CreditConfigurationCreateArgs>
    ): CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration>, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T>>>

    /**
     * Create many CreditConfigurations.
     *     @param {CreditConfigurationCreateManyArgs} args - Arguments to create many CreditConfigurations.
     *     @example
     *     // Create many CreditConfigurations
     *     const creditConfiguration = await prisma.creditConfiguration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreditConfigurationCreateManyArgs>(
      args?: SelectSubset<T, CreditConfigurationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CreditConfiguration.
     * @param {CreditConfigurationDeleteArgs} args - Arguments to delete one CreditConfiguration.
     * @example
     * // Delete one CreditConfiguration
     * const CreditConfiguration = await prisma.creditConfiguration.delete({
     *   where: {
     *     // ... filter to delete one CreditConfiguration
     *   }
     * })
     * 
    **/
    delete<T extends CreditConfigurationDeleteArgs>(
      args: SelectSubset<T, CreditConfigurationDeleteArgs>
    ): CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration>, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T>>>

    /**
     * Update one CreditConfiguration.
     * @param {CreditConfigurationUpdateArgs} args - Arguments to update one CreditConfiguration.
     * @example
     * // Update one CreditConfiguration
     * const creditConfiguration = await prisma.creditConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreditConfigurationUpdateArgs>(
      args: SelectSubset<T, CreditConfigurationUpdateArgs>
    ): CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration>, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T>>>

    /**
     * Delete zero or more CreditConfigurations.
     * @param {CreditConfigurationDeleteManyArgs} args - Arguments to filter CreditConfigurations to delete.
     * @example
     * // Delete a few CreditConfigurations
     * const { count } = await prisma.creditConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreditConfigurationDeleteManyArgs>(
      args?: SelectSubset<T, CreditConfigurationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditConfigurations
     * const creditConfiguration = await prisma.creditConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreditConfigurationUpdateManyArgs>(
      args: SelectSubset<T, CreditConfigurationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditConfiguration.
     * @param {CreditConfigurationUpsertArgs} args - Arguments to update or create a CreditConfiguration.
     * @example
     * // Update or create a CreditConfiguration
     * const creditConfiguration = await prisma.creditConfiguration.upsert({
     *   create: {
     *     // ... data to create a CreditConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditConfiguration we want to update
     *   }
     * })
    **/
    upsert<T extends CreditConfigurationUpsertArgs>(
      args: SelectSubset<T, CreditConfigurationUpsertArgs>
    ): CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration>, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T>>>

    /**
     * Count the number of CreditConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationCountArgs} args - Arguments to filter CreditConfigurations to count.
     * @example
     * // Count the number of CreditConfigurations
     * const count = await prisma.creditConfiguration.count({
     *   where: {
     *     // ... the filter for the CreditConfigurations we want to count
     *   }
     * })
    **/
    count<T extends CreditConfigurationCountArgs>(
      args?: Subset<T, CreditConfigurationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditConfigurationAggregateArgs>(args: Subset<T, CreditConfigurationAggregateArgs>): PrismaPromise<GetCreditConfigurationAggregateType<T>>

    /**
     * Group by CreditConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: CreditConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditConfigurationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreditConfigurationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    credit<T extends CreditFindManyArgs = {}>(args?: Subset<T, CreditFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Credit>>, PrismaPromise<Array<CreditGetPayload<T>>>>;

    attachedWallets<T extends CreditConfigurationsWalletsFindManyArgs = {}>(args?: Subset<T, CreditConfigurationsWalletsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CreditConfigurationsWallets>>, PrismaPromise<Array<CreditConfigurationsWalletsGetPayload<T>>>>;

    Installment<T extends InstallmentFindManyArgs = {}>(args?: Subset<T, InstallmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Installment>>, PrismaPromise<Array<InstallmentGetPayload<T>>>>;

    creditRequests<T extends CreditRequestArgs = {}>(args?: Subset<T, CreditRequestArgs>): CheckSelect<T, Prisma__CreditRequestClient<CreditRequest | null >, Prisma__CreditRequestClient<CreditRequestGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CreditConfiguration findUnique
   */
  export type CreditConfigurationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CreditConfiguration
     * 
    **/
    select?: CreditConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationInclude | null
    /**
     * Throw an Error if a CreditConfiguration can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreditConfiguration to fetch.
     * 
    **/
    where: CreditConfigurationWhereUniqueInput
  }


  /**
   * CreditConfiguration findFirst
   */
  export type CreditConfigurationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CreditConfiguration
     * 
    **/
    select?: CreditConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationInclude | null
    /**
     * Throw an Error if a CreditConfiguration can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreditConfiguration to fetch.
     * 
    **/
    where?: CreditConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditConfigurations.
     * 
    **/
    cursor?: CreditConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditConfigurations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditConfigurations.
     * 
    **/
    distinct?: Enumerable<CreditConfigurationScalarFieldEnum>
  }


  /**
   * CreditConfiguration findMany
   */
  export type CreditConfigurationFindManyArgs = {
    /**
     * Select specific fields to fetch from the CreditConfiguration
     * 
    **/
    select?: CreditConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationInclude | null
    /**
     * Filter, which CreditConfigurations to fetch.
     * 
    **/
    where?: CreditConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditConfigurations to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditConfigurationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditConfigurations.
     * 
    **/
    cursor?: CreditConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditConfigurations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditConfigurations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreditConfigurationScalarFieldEnum>
  }


  /**
   * CreditConfiguration create
   */
  export type CreditConfigurationCreateArgs = {
    /**
     * Select specific fields to fetch from the CreditConfiguration
     * 
    **/
    select?: CreditConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationInclude | null
    /**
     * The data needed to create a CreditConfiguration.
     * 
    **/
    data: XOR<CreditConfigurationCreateInput, CreditConfigurationUncheckedCreateInput>
  }


  /**
   * CreditConfiguration createMany
   */
  export type CreditConfigurationCreateManyArgs = {
    /**
     * The data used to create many CreditConfigurations.
     * 
    **/
    data: Enumerable<CreditConfigurationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CreditConfiguration update
   */
  export type CreditConfigurationUpdateArgs = {
    /**
     * Select specific fields to fetch from the CreditConfiguration
     * 
    **/
    select?: CreditConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationInclude | null
    /**
     * The data needed to update a CreditConfiguration.
     * 
    **/
    data: XOR<CreditConfigurationUpdateInput, CreditConfigurationUncheckedUpdateInput>
    /**
     * Choose, which CreditConfiguration to update.
     * 
    **/
    where: CreditConfigurationWhereUniqueInput
  }


  /**
   * CreditConfiguration updateMany
   */
  export type CreditConfigurationUpdateManyArgs = {
    /**
     * The data used to update CreditConfigurations.
     * 
    **/
    data: XOR<CreditConfigurationUpdateManyMutationInput, CreditConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which CreditConfigurations to update
     * 
    **/
    where?: CreditConfigurationWhereInput
  }


  /**
   * CreditConfiguration upsert
   */
  export type CreditConfigurationUpsertArgs = {
    /**
     * Select specific fields to fetch from the CreditConfiguration
     * 
    **/
    select?: CreditConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationInclude | null
    /**
     * The filter to search for the CreditConfiguration to update in case it exists.
     * 
    **/
    where: CreditConfigurationWhereUniqueInput
    /**
     * In case the CreditConfiguration found by the `where` argument doesn't exist, create a new CreditConfiguration with this data.
     * 
    **/
    create: XOR<CreditConfigurationCreateInput, CreditConfigurationUncheckedCreateInput>
    /**
     * In case the CreditConfiguration was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreditConfigurationUpdateInput, CreditConfigurationUncheckedUpdateInput>
  }


  /**
   * CreditConfiguration delete
   */
  export type CreditConfigurationDeleteArgs = {
    /**
     * Select specific fields to fetch from the CreditConfiguration
     * 
    **/
    select?: CreditConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationInclude | null
    /**
     * Filter which CreditConfiguration to delete.
     * 
    **/
    where: CreditConfigurationWhereUniqueInput
  }


  /**
   * CreditConfiguration deleteMany
   */
  export type CreditConfigurationDeleteManyArgs = {
    /**
     * Filter which CreditConfigurations to delete
     * 
    **/
    where?: CreditConfigurationWhereInput
  }


  /**
   * CreditConfiguration without action
   */
  export type CreditConfigurationArgs = {
    /**
     * Select specific fields to fetch from the CreditConfiguration
     * 
    **/
    select?: CreditConfigurationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationInclude | null
  }



  /**
   * Model CreditConfigurationsWallets
   */


  export type AggregateCreditConfigurationsWallets = {
    _count: CreditConfigurationsWalletsCountAggregateOutputType | null
    _avg: CreditConfigurationsWalletsAvgAggregateOutputType | null
    _sum: CreditConfigurationsWalletsSumAggregateOutputType | null
    _min: CreditConfigurationsWalletsMinAggregateOutputType | null
    _max: CreditConfigurationsWalletsMaxAggregateOutputType | null
  }

  export type CreditConfigurationsWalletsAvgAggregateOutputType = {
    upfrontPercentage: number | null
    fundFeesPercentage: number | null
    maxOrderAmount: number | null
    maxOutstandingCredit: number | null
    shareFeesPercentage: number | null
    postDeliveryPercentage: number | null
  }

  export type CreditConfigurationsWalletsSumAggregateOutputType = {
    upfrontPercentage: number | null
    fundFeesPercentage: number | null
    maxOrderAmount: number | null
    maxOutstandingCredit: number | null
    shareFeesPercentage: number | null
    postDeliveryPercentage: number | null
  }

  export type CreditConfigurationsWalletsMinAggregateOutputType = {
    configurationId: string | null
    walletId: string | null
    upfrontPercentage: number | null
    fundFeesPercentage: number | null
    maxOrderAmount: number | null
    maxOutstandingCredit: number | null
    shareFeesPercentage: number | null
    postDeliveryPercentage: number | null
  }

  export type CreditConfigurationsWalletsMaxAggregateOutputType = {
    configurationId: string | null
    walletId: string | null
    upfrontPercentage: number | null
    fundFeesPercentage: number | null
    maxOrderAmount: number | null
    maxOutstandingCredit: number | null
    shareFeesPercentage: number | null
    postDeliveryPercentage: number | null
  }

  export type CreditConfigurationsWalletsCountAggregateOutputType = {
    configurationId: number
    walletId: number
    upfrontPercentage: number
    fundFeesPercentage: number
    maxOrderAmount: number
    maxOutstandingCredit: number
    shareFeesPercentage: number
    postDeliveryPercentage: number
    _all: number
  }


  export type CreditConfigurationsWalletsAvgAggregateInputType = {
    upfrontPercentage?: true
    fundFeesPercentage?: true
    maxOrderAmount?: true
    maxOutstandingCredit?: true
    shareFeesPercentage?: true
    postDeliveryPercentage?: true
  }

  export type CreditConfigurationsWalletsSumAggregateInputType = {
    upfrontPercentage?: true
    fundFeesPercentage?: true
    maxOrderAmount?: true
    maxOutstandingCredit?: true
    shareFeesPercentage?: true
    postDeliveryPercentage?: true
  }

  export type CreditConfigurationsWalletsMinAggregateInputType = {
    configurationId?: true
    walletId?: true
    upfrontPercentage?: true
    fundFeesPercentage?: true
    maxOrderAmount?: true
    maxOutstandingCredit?: true
    shareFeesPercentage?: true
    postDeliveryPercentage?: true
  }

  export type CreditConfigurationsWalletsMaxAggregateInputType = {
    configurationId?: true
    walletId?: true
    upfrontPercentage?: true
    fundFeesPercentage?: true
    maxOrderAmount?: true
    maxOutstandingCredit?: true
    shareFeesPercentage?: true
    postDeliveryPercentage?: true
  }

  export type CreditConfigurationsWalletsCountAggregateInputType = {
    configurationId?: true
    walletId?: true
    upfrontPercentage?: true
    fundFeesPercentage?: true
    maxOrderAmount?: true
    maxOutstandingCredit?: true
    shareFeesPercentage?: true
    postDeliveryPercentage?: true
    _all?: true
  }

  export type CreditConfigurationsWalletsAggregateArgs = {
    /**
     * Filter which CreditConfigurationsWallets to aggregate.
     * 
    **/
    where?: CreditConfigurationsWalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditConfigurationsWallets to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditConfigurationsWalletsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreditConfigurationsWalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditConfigurationsWallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditConfigurationsWallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditConfigurationsWallets
    **/
    _count?: true | CreditConfigurationsWalletsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditConfigurationsWalletsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditConfigurationsWalletsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditConfigurationsWalletsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditConfigurationsWalletsMaxAggregateInputType
  }

  export type GetCreditConfigurationsWalletsAggregateType<T extends CreditConfigurationsWalletsAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditConfigurationsWallets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditConfigurationsWallets[P]>
      : GetScalarType<T[P], AggregateCreditConfigurationsWallets[P]>
  }




  export type CreditConfigurationsWalletsGroupByArgs = {
    where?: CreditConfigurationsWalletsWhereInput
    orderBy?: Enumerable<CreditConfigurationsWalletsOrderByWithAggregationInput>
    by: Array<CreditConfigurationsWalletsScalarFieldEnum>
    having?: CreditConfigurationsWalletsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditConfigurationsWalletsCountAggregateInputType | true
    _avg?: CreditConfigurationsWalletsAvgAggregateInputType
    _sum?: CreditConfigurationsWalletsSumAggregateInputType
    _min?: CreditConfigurationsWalletsMinAggregateInputType
    _max?: CreditConfigurationsWalletsMaxAggregateInputType
  }


  export type CreditConfigurationsWalletsGroupByOutputType = {
    configurationId: string
    walletId: string
    upfrontPercentage: number
    fundFeesPercentage: number
    maxOrderAmount: number
    maxOutstandingCredit: number
    shareFeesPercentage: number
    postDeliveryPercentage: number
    _count: CreditConfigurationsWalletsCountAggregateOutputType | null
    _avg: CreditConfigurationsWalletsAvgAggregateOutputType | null
    _sum: CreditConfigurationsWalletsSumAggregateOutputType | null
    _min: CreditConfigurationsWalletsMinAggregateOutputType | null
    _max: CreditConfigurationsWalletsMaxAggregateOutputType | null
  }

  type GetCreditConfigurationsWalletsGroupByPayload<T extends CreditConfigurationsWalletsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CreditConfigurationsWalletsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditConfigurationsWalletsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditConfigurationsWalletsGroupByOutputType[P]>
            : GetScalarType<T[P], CreditConfigurationsWalletsGroupByOutputType[P]>
        }
      >
    >


  export type CreditConfigurationsWalletsSelect = {
    configurationId?: boolean
    walletId?: boolean
    upfrontPercentage?: boolean
    fundFeesPercentage?: boolean
    maxOrderAmount?: boolean
    maxOutstandingCredit?: boolean
    shareFeesPercentage?: boolean
    postDeliveryPercentage?: boolean
    configuration?: boolean | CreditConfigurationArgs
  }

  export type CreditConfigurationsWalletsInclude = {
    configuration?: boolean | CreditConfigurationArgs
  }

  export type CreditConfigurationsWalletsGetPayload<
    S extends boolean | null | undefined | CreditConfigurationsWalletsArgs,
    U = keyof S
      > = S extends true
        ? CreditConfigurationsWallets
    : S extends undefined
    ? never
    : S extends CreditConfigurationsWalletsArgs | CreditConfigurationsWalletsFindManyArgs
    ?'include' extends U
    ? CreditConfigurationsWallets  & {
    [P in TrueKeys<S['include']>]:
        P extends 'configuration' ? CreditConfigurationGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'configuration' ? CreditConfigurationGetPayload<S['select'][P]> :  P extends keyof CreditConfigurationsWallets ? CreditConfigurationsWallets[P] : never
  } 
    : CreditConfigurationsWallets
  : CreditConfigurationsWallets


  type CreditConfigurationsWalletsCountArgs = Merge<
    Omit<CreditConfigurationsWalletsFindManyArgs, 'select' | 'include'> & {
      select?: CreditConfigurationsWalletsCountAggregateInputType | true
    }
  >

  export interface CreditConfigurationsWalletsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CreditConfigurationsWallets that matches the filter.
     * @param {CreditConfigurationsWalletsFindUniqueArgs} args - Arguments to find a CreditConfigurationsWallets
     * @example
     * // Get one CreditConfigurationsWallets
     * const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreditConfigurationsWalletsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreditConfigurationsWalletsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CreditConfigurationsWallets'> extends True ? CheckSelect<T, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWallets>, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWalletsGetPayload<T>>> : CheckSelect<T, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWallets | null >, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWalletsGetPayload<T> | null >>

    /**
     * Find the first CreditConfigurationsWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationsWalletsFindFirstArgs} args - Arguments to find a CreditConfigurationsWallets
     * @example
     * // Get one CreditConfigurationsWallets
     * const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreditConfigurationsWalletsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreditConfigurationsWalletsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CreditConfigurationsWallets'> extends True ? CheckSelect<T, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWallets>, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWalletsGetPayload<T>>> : CheckSelect<T, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWallets | null >, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWalletsGetPayload<T> | null >>

    /**
     * Find zero or more CreditConfigurationsWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationsWalletsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditConfigurationsWallets
     * const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.findMany()
     * 
     * // Get first 10 CreditConfigurationsWallets
     * const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.findMany({ take: 10 })
     * 
     * // Only select the `configurationId`
     * const creditConfigurationsWalletsWithConfigurationIdOnly = await prisma.creditConfigurationsWallets.findMany({ select: { configurationId: true } })
     * 
    **/
    findMany<T extends CreditConfigurationsWalletsFindManyArgs>(
      args?: SelectSubset<T, CreditConfigurationsWalletsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CreditConfigurationsWallets>>, PrismaPromise<Array<CreditConfigurationsWalletsGetPayload<T>>>>

    /**
     * Create a CreditConfigurationsWallets.
     * @param {CreditConfigurationsWalletsCreateArgs} args - Arguments to create a CreditConfigurationsWallets.
     * @example
     * // Create one CreditConfigurationsWallets
     * const CreditConfigurationsWallets = await prisma.creditConfigurationsWallets.create({
     *   data: {
     *     // ... data to create a CreditConfigurationsWallets
     *   }
     * })
     * 
    **/
    create<T extends CreditConfigurationsWalletsCreateArgs>(
      args: SelectSubset<T, CreditConfigurationsWalletsCreateArgs>
    ): CheckSelect<T, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWallets>, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWalletsGetPayload<T>>>

    /**
     * Create many CreditConfigurationsWallets.
     *     @param {CreditConfigurationsWalletsCreateManyArgs} args - Arguments to create many CreditConfigurationsWallets.
     *     @example
     *     // Create many CreditConfigurationsWallets
     *     const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreditConfigurationsWalletsCreateManyArgs>(
      args?: SelectSubset<T, CreditConfigurationsWalletsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CreditConfigurationsWallets.
     * @param {CreditConfigurationsWalletsDeleteArgs} args - Arguments to delete one CreditConfigurationsWallets.
     * @example
     * // Delete one CreditConfigurationsWallets
     * const CreditConfigurationsWallets = await prisma.creditConfigurationsWallets.delete({
     *   where: {
     *     // ... filter to delete one CreditConfigurationsWallets
     *   }
     * })
     * 
    **/
    delete<T extends CreditConfigurationsWalletsDeleteArgs>(
      args: SelectSubset<T, CreditConfigurationsWalletsDeleteArgs>
    ): CheckSelect<T, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWallets>, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWalletsGetPayload<T>>>

    /**
     * Update one CreditConfigurationsWallets.
     * @param {CreditConfigurationsWalletsUpdateArgs} args - Arguments to update one CreditConfigurationsWallets.
     * @example
     * // Update one CreditConfigurationsWallets
     * const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreditConfigurationsWalletsUpdateArgs>(
      args: SelectSubset<T, CreditConfigurationsWalletsUpdateArgs>
    ): CheckSelect<T, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWallets>, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWalletsGetPayload<T>>>

    /**
     * Delete zero or more CreditConfigurationsWallets.
     * @param {CreditConfigurationsWalletsDeleteManyArgs} args - Arguments to filter CreditConfigurationsWallets to delete.
     * @example
     * // Delete a few CreditConfigurationsWallets
     * const { count } = await prisma.creditConfigurationsWallets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreditConfigurationsWalletsDeleteManyArgs>(
      args?: SelectSubset<T, CreditConfigurationsWalletsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditConfigurationsWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationsWalletsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditConfigurationsWallets
     * const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreditConfigurationsWalletsUpdateManyArgs>(
      args: SelectSubset<T, CreditConfigurationsWalletsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditConfigurationsWallets.
     * @param {CreditConfigurationsWalletsUpsertArgs} args - Arguments to update or create a CreditConfigurationsWallets.
     * @example
     * // Update or create a CreditConfigurationsWallets
     * const creditConfigurationsWallets = await prisma.creditConfigurationsWallets.upsert({
     *   create: {
     *     // ... data to create a CreditConfigurationsWallets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditConfigurationsWallets we want to update
     *   }
     * })
    **/
    upsert<T extends CreditConfigurationsWalletsUpsertArgs>(
      args: SelectSubset<T, CreditConfigurationsWalletsUpsertArgs>
    ): CheckSelect<T, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWallets>, Prisma__CreditConfigurationsWalletsClient<CreditConfigurationsWalletsGetPayload<T>>>

    /**
     * Count the number of CreditConfigurationsWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationsWalletsCountArgs} args - Arguments to filter CreditConfigurationsWallets to count.
     * @example
     * // Count the number of CreditConfigurationsWallets
     * const count = await prisma.creditConfigurationsWallets.count({
     *   where: {
     *     // ... the filter for the CreditConfigurationsWallets we want to count
     *   }
     * })
    **/
    count<T extends CreditConfigurationsWalletsCountArgs>(
      args?: Subset<T, CreditConfigurationsWalletsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditConfigurationsWalletsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditConfigurationsWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationsWalletsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditConfigurationsWalletsAggregateArgs>(args: Subset<T, CreditConfigurationsWalletsAggregateArgs>): PrismaPromise<GetCreditConfigurationsWalletsAggregateType<T>>

    /**
     * Group by CreditConfigurationsWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditConfigurationsWalletsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditConfigurationsWalletsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditConfigurationsWalletsGroupByArgs['orderBy'] }
        : { orderBy?: CreditConfigurationsWalletsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditConfigurationsWalletsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditConfigurationsWalletsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditConfigurationsWallets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreditConfigurationsWalletsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    configuration<T extends CreditConfigurationArgs = {}>(args?: Subset<T, CreditConfigurationArgs>): CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration | null >, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CreditConfigurationsWallets findUnique
   */
  export type CreditConfigurationsWalletsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationsWallets
     * 
    **/
    select?: CreditConfigurationsWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationsWalletsInclude | null
    /**
     * Throw an Error if a CreditConfigurationsWallets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreditConfigurationsWallets to fetch.
     * 
    **/
    where: CreditConfigurationsWalletsWhereUniqueInput
  }


  /**
   * CreditConfigurationsWallets findFirst
   */
  export type CreditConfigurationsWalletsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationsWallets
     * 
    **/
    select?: CreditConfigurationsWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationsWalletsInclude | null
    /**
     * Throw an Error if a CreditConfigurationsWallets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreditConfigurationsWallets to fetch.
     * 
    **/
    where?: CreditConfigurationsWalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditConfigurationsWallets to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditConfigurationsWalletsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditConfigurationsWallets.
     * 
    **/
    cursor?: CreditConfigurationsWalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditConfigurationsWallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditConfigurationsWallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditConfigurationsWallets.
     * 
    **/
    distinct?: Enumerable<CreditConfigurationsWalletsScalarFieldEnum>
  }


  /**
   * CreditConfigurationsWallets findMany
   */
  export type CreditConfigurationsWalletsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationsWallets
     * 
    **/
    select?: CreditConfigurationsWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationsWalletsInclude | null
    /**
     * Filter, which CreditConfigurationsWallets to fetch.
     * 
    **/
    where?: CreditConfigurationsWalletsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditConfigurationsWallets to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditConfigurationsWalletsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditConfigurationsWallets.
     * 
    **/
    cursor?: CreditConfigurationsWalletsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditConfigurationsWallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditConfigurationsWallets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreditConfigurationsWalletsScalarFieldEnum>
  }


  /**
   * CreditConfigurationsWallets create
   */
  export type CreditConfigurationsWalletsCreateArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationsWallets
     * 
    **/
    select?: CreditConfigurationsWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationsWalletsInclude | null
    /**
     * The data needed to create a CreditConfigurationsWallets.
     * 
    **/
    data: XOR<CreditConfigurationsWalletsCreateInput, CreditConfigurationsWalletsUncheckedCreateInput>
  }


  /**
   * CreditConfigurationsWallets createMany
   */
  export type CreditConfigurationsWalletsCreateManyArgs = {
    /**
     * The data used to create many CreditConfigurationsWallets.
     * 
    **/
    data: Enumerable<CreditConfigurationsWalletsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CreditConfigurationsWallets update
   */
  export type CreditConfigurationsWalletsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationsWallets
     * 
    **/
    select?: CreditConfigurationsWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationsWalletsInclude | null
    /**
     * The data needed to update a CreditConfigurationsWallets.
     * 
    **/
    data: XOR<CreditConfigurationsWalletsUpdateInput, CreditConfigurationsWalletsUncheckedUpdateInput>
    /**
     * Choose, which CreditConfigurationsWallets to update.
     * 
    **/
    where: CreditConfigurationsWalletsWhereUniqueInput
  }


  /**
   * CreditConfigurationsWallets updateMany
   */
  export type CreditConfigurationsWalletsUpdateManyArgs = {
    /**
     * The data used to update CreditConfigurationsWallets.
     * 
    **/
    data: XOR<CreditConfigurationsWalletsUpdateManyMutationInput, CreditConfigurationsWalletsUncheckedUpdateManyInput>
    /**
     * Filter which CreditConfigurationsWallets to update
     * 
    **/
    where?: CreditConfigurationsWalletsWhereInput
  }


  /**
   * CreditConfigurationsWallets upsert
   */
  export type CreditConfigurationsWalletsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationsWallets
     * 
    **/
    select?: CreditConfigurationsWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationsWalletsInclude | null
    /**
     * The filter to search for the CreditConfigurationsWallets to update in case it exists.
     * 
    **/
    where: CreditConfigurationsWalletsWhereUniqueInput
    /**
     * In case the CreditConfigurationsWallets found by the `where` argument doesn't exist, create a new CreditConfigurationsWallets with this data.
     * 
    **/
    create: XOR<CreditConfigurationsWalletsCreateInput, CreditConfigurationsWalletsUncheckedCreateInput>
    /**
     * In case the CreditConfigurationsWallets was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreditConfigurationsWalletsUpdateInput, CreditConfigurationsWalletsUncheckedUpdateInput>
  }


  /**
   * CreditConfigurationsWallets delete
   */
  export type CreditConfigurationsWalletsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationsWallets
     * 
    **/
    select?: CreditConfigurationsWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationsWalletsInclude | null
    /**
     * Filter which CreditConfigurationsWallets to delete.
     * 
    **/
    where: CreditConfigurationsWalletsWhereUniqueInput
  }


  /**
   * CreditConfigurationsWallets deleteMany
   */
  export type CreditConfigurationsWalletsDeleteManyArgs = {
    /**
     * Filter which CreditConfigurationsWallets to delete
     * 
    **/
    where?: CreditConfigurationsWalletsWhereInput
  }


  /**
   * CreditConfigurationsWallets without action
   */
  export type CreditConfigurationsWalletsArgs = {
    /**
     * Select specific fields to fetch from the CreditConfigurationsWallets
     * 
    **/
    select?: CreditConfigurationsWalletsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditConfigurationsWalletsInclude | null
  }



  /**
   * Model OtherMemberKYC
   */


  export type AggregateOtherMemberKYC = {
    _count: OtherMemberKYCCountAggregateOutputType | null
    _min: OtherMemberKYCMinAggregateOutputType | null
    _max: OtherMemberKYCMaxAggregateOutputType | null
  }

  export type OtherMemberKYCMinAggregateOutputType = {
    id: string | null
    name: string | null
    documentId: string | null
    documentCountry: CountryCode | null
    documentFirstName: string | null
    documentLastName: string | null
    documentImage: string | null
    documentGender: GenderEnum | null
    documentDateOfBirth: Date | null
    documentDateOfIssue: Date | null
    documentSerialNumber: string | null
    documentCreatedAt: Date | null
    profilePictureURL: string | null
    idCardURL: string | null
    createdAt: Date | null
    createdByUserId: string | null
    userIdToKYC: string | null
    OTP: string | null
  }

  export type OtherMemberKYCMaxAggregateOutputType = {
    id: string | null
    name: string | null
    documentId: string | null
    documentCountry: CountryCode | null
    documentFirstName: string | null
    documentLastName: string | null
    documentImage: string | null
    documentGender: GenderEnum | null
    documentDateOfBirth: Date | null
    documentDateOfIssue: Date | null
    documentSerialNumber: string | null
    documentCreatedAt: Date | null
    profilePictureURL: string | null
    idCardURL: string | null
    createdAt: Date | null
    createdByUserId: string | null
    userIdToKYC: string | null
    OTP: string | null
  }

  export type OtherMemberKYCCountAggregateOutputType = {
    id: number
    name: number
    documentId: number
    documentCountry: number
    documentData: number
    documentFirstName: number
    documentLastName: number
    documentImage: number
    documentGender: number
    documentDateOfBirth: number
    documentDateOfIssue: number
    documentSerialNumber: number
    documentCreatedAt: number
    profilePictureURL: number
    idCardURL: number
    createdAt: number
    createdByUserId: number
    userIdToKYC: number
    OTP: number
    _all: number
  }


  export type OtherMemberKYCMinAggregateInputType = {
    id?: true
    name?: true
    documentId?: true
    documentCountry?: true
    documentFirstName?: true
    documentLastName?: true
    documentImage?: true
    documentGender?: true
    documentDateOfBirth?: true
    documentDateOfIssue?: true
    documentSerialNumber?: true
    documentCreatedAt?: true
    profilePictureURL?: true
    idCardURL?: true
    createdAt?: true
    createdByUserId?: true
    userIdToKYC?: true
    OTP?: true
  }

  export type OtherMemberKYCMaxAggregateInputType = {
    id?: true
    name?: true
    documentId?: true
    documentCountry?: true
    documentFirstName?: true
    documentLastName?: true
    documentImage?: true
    documentGender?: true
    documentDateOfBirth?: true
    documentDateOfIssue?: true
    documentSerialNumber?: true
    documentCreatedAt?: true
    profilePictureURL?: true
    idCardURL?: true
    createdAt?: true
    createdByUserId?: true
    userIdToKYC?: true
    OTP?: true
  }

  export type OtherMemberKYCCountAggregateInputType = {
    id?: true
    name?: true
    documentId?: true
    documentCountry?: true
    documentData?: true
    documentFirstName?: true
    documentLastName?: true
    documentImage?: true
    documentGender?: true
    documentDateOfBirth?: true
    documentDateOfIssue?: true
    documentSerialNumber?: true
    documentCreatedAt?: true
    profilePictureURL?: true
    idCardURL?: true
    createdAt?: true
    createdByUserId?: true
    userIdToKYC?: true
    OTP?: true
    _all?: true
  }

  export type OtherMemberKYCAggregateArgs = {
    /**
     * Filter which OtherMemberKYC to aggregate.
     * 
    **/
    where?: OtherMemberKYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherMemberKYCS to fetch.
     * 
    **/
    orderBy?: Enumerable<OtherMemberKYCOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OtherMemberKYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherMemberKYCS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherMemberKYCS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtherMemberKYCS
    **/
    _count?: true | OtherMemberKYCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtherMemberKYCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtherMemberKYCMaxAggregateInputType
  }

  export type GetOtherMemberKYCAggregateType<T extends OtherMemberKYCAggregateArgs> = {
        [P in keyof T & keyof AggregateOtherMemberKYC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtherMemberKYC[P]>
      : GetScalarType<T[P], AggregateOtherMemberKYC[P]>
  }




  export type OtherMemberKYCGroupByArgs = {
    where?: OtherMemberKYCWhereInput
    orderBy?: Enumerable<OtherMemberKYCOrderByWithAggregationInput>
    by: Array<OtherMemberKYCScalarFieldEnum>
    having?: OtherMemberKYCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtherMemberKYCCountAggregateInputType | true
    _min?: OtherMemberKYCMinAggregateInputType
    _max?: OtherMemberKYCMaxAggregateInputType
  }


  export type OtherMemberKYCGroupByOutputType = {
    id: string
    name: string
    documentId: string
    documentCountry: CountryCode | null
    documentData: JsonValue | null
    documentFirstName: string | null
    documentLastName: string | null
    documentImage: string | null
    documentGender: GenderEnum | null
    documentDateOfBirth: Date | null
    documentDateOfIssue: Date | null
    documentSerialNumber: string | null
    documentCreatedAt: Date | null
    profilePictureURL: string
    idCardURL: string
    createdAt: Date
    createdByUserId: string
    userIdToKYC: string
    OTP: string
    _count: OtherMemberKYCCountAggregateOutputType | null
    _min: OtherMemberKYCMinAggregateOutputType | null
    _max: OtherMemberKYCMaxAggregateOutputType | null
  }

  type GetOtherMemberKYCGroupByPayload<T extends OtherMemberKYCGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OtherMemberKYCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtherMemberKYCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtherMemberKYCGroupByOutputType[P]>
            : GetScalarType<T[P], OtherMemberKYCGroupByOutputType[P]>
        }
      >
    >


  export type OtherMemberKYCSelect = {
    id?: boolean
    name?: boolean
    documentId?: boolean
    documentCountry?: boolean
    documentData?: boolean
    documentFirstName?: boolean
    documentLastName?: boolean
    documentImage?: boolean
    documentGender?: boolean
    documentDateOfBirth?: boolean
    documentDateOfIssue?: boolean
    documentSerialNumber?: boolean
    documentCreatedAt?: boolean
    profilePictureURL?: boolean
    idCardURL?: boolean
    createdAt?: boolean
    createdByUserId?: boolean
    userIdToKYC?: boolean
    OTP?: boolean
    createdBy?: boolean | UserArgs
  }

  export type OtherMemberKYCInclude = {
    createdBy?: boolean | UserArgs
  }

  export type OtherMemberKYCGetPayload<
    S extends boolean | null | undefined | OtherMemberKYCArgs,
    U = keyof S
      > = S extends true
        ? OtherMemberKYC
    : S extends undefined
    ? never
    : S extends OtherMemberKYCArgs | OtherMemberKYCFindManyArgs
    ?'include' extends U
    ? OtherMemberKYC  & {
    [P in TrueKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<S['select'][P]> :  P extends keyof OtherMemberKYC ? OtherMemberKYC[P] : never
  } 
    : OtherMemberKYC
  : OtherMemberKYC


  type OtherMemberKYCCountArgs = Merge<
    Omit<OtherMemberKYCFindManyArgs, 'select' | 'include'> & {
      select?: OtherMemberKYCCountAggregateInputType | true
    }
  >

  export interface OtherMemberKYCDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OtherMemberKYC that matches the filter.
     * @param {OtherMemberKYCFindUniqueArgs} args - Arguments to find a OtherMemberKYC
     * @example
     * // Get one OtherMemberKYC
     * const otherMemberKYC = await prisma.otherMemberKYC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OtherMemberKYCFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OtherMemberKYCFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OtherMemberKYC'> extends True ? CheckSelect<T, Prisma__OtherMemberKYCClient<OtherMemberKYC>, Prisma__OtherMemberKYCClient<OtherMemberKYCGetPayload<T>>> : CheckSelect<T, Prisma__OtherMemberKYCClient<OtherMemberKYC | null >, Prisma__OtherMemberKYCClient<OtherMemberKYCGetPayload<T> | null >>

    /**
     * Find the first OtherMemberKYC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherMemberKYCFindFirstArgs} args - Arguments to find a OtherMemberKYC
     * @example
     * // Get one OtherMemberKYC
     * const otherMemberKYC = await prisma.otherMemberKYC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OtherMemberKYCFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OtherMemberKYCFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OtherMemberKYC'> extends True ? CheckSelect<T, Prisma__OtherMemberKYCClient<OtherMemberKYC>, Prisma__OtherMemberKYCClient<OtherMemberKYCGetPayload<T>>> : CheckSelect<T, Prisma__OtherMemberKYCClient<OtherMemberKYC | null >, Prisma__OtherMemberKYCClient<OtherMemberKYCGetPayload<T> | null >>

    /**
     * Find zero or more OtherMemberKYCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherMemberKYCFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtherMemberKYCS
     * const otherMemberKYCS = await prisma.otherMemberKYC.findMany()
     * 
     * // Get first 10 OtherMemberKYCS
     * const otherMemberKYCS = await prisma.otherMemberKYC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otherMemberKYCWithIdOnly = await prisma.otherMemberKYC.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OtherMemberKYCFindManyArgs>(
      args?: SelectSubset<T, OtherMemberKYCFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OtherMemberKYC>>, PrismaPromise<Array<OtherMemberKYCGetPayload<T>>>>

    /**
     * Create a OtherMemberKYC.
     * @param {OtherMemberKYCCreateArgs} args - Arguments to create a OtherMemberKYC.
     * @example
     * // Create one OtherMemberKYC
     * const OtherMemberKYC = await prisma.otherMemberKYC.create({
     *   data: {
     *     // ... data to create a OtherMemberKYC
     *   }
     * })
     * 
    **/
    create<T extends OtherMemberKYCCreateArgs>(
      args: SelectSubset<T, OtherMemberKYCCreateArgs>
    ): CheckSelect<T, Prisma__OtherMemberKYCClient<OtherMemberKYC>, Prisma__OtherMemberKYCClient<OtherMemberKYCGetPayload<T>>>

    /**
     * Create many OtherMemberKYCS.
     *     @param {OtherMemberKYCCreateManyArgs} args - Arguments to create many OtherMemberKYCS.
     *     @example
     *     // Create many OtherMemberKYCS
     *     const otherMemberKYC = await prisma.otherMemberKYC.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OtherMemberKYCCreateManyArgs>(
      args?: SelectSubset<T, OtherMemberKYCCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OtherMemberKYC.
     * @param {OtherMemberKYCDeleteArgs} args - Arguments to delete one OtherMemberKYC.
     * @example
     * // Delete one OtherMemberKYC
     * const OtherMemberKYC = await prisma.otherMemberKYC.delete({
     *   where: {
     *     // ... filter to delete one OtherMemberKYC
     *   }
     * })
     * 
    **/
    delete<T extends OtherMemberKYCDeleteArgs>(
      args: SelectSubset<T, OtherMemberKYCDeleteArgs>
    ): CheckSelect<T, Prisma__OtherMemberKYCClient<OtherMemberKYC>, Prisma__OtherMemberKYCClient<OtherMemberKYCGetPayload<T>>>

    /**
     * Update one OtherMemberKYC.
     * @param {OtherMemberKYCUpdateArgs} args - Arguments to update one OtherMemberKYC.
     * @example
     * // Update one OtherMemberKYC
     * const otherMemberKYC = await prisma.otherMemberKYC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OtherMemberKYCUpdateArgs>(
      args: SelectSubset<T, OtherMemberKYCUpdateArgs>
    ): CheckSelect<T, Prisma__OtherMemberKYCClient<OtherMemberKYC>, Prisma__OtherMemberKYCClient<OtherMemberKYCGetPayload<T>>>

    /**
     * Delete zero or more OtherMemberKYCS.
     * @param {OtherMemberKYCDeleteManyArgs} args - Arguments to filter OtherMemberKYCS to delete.
     * @example
     * // Delete a few OtherMemberKYCS
     * const { count } = await prisma.otherMemberKYC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OtherMemberKYCDeleteManyArgs>(
      args?: SelectSubset<T, OtherMemberKYCDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtherMemberKYCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherMemberKYCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtherMemberKYCS
     * const otherMemberKYC = await prisma.otherMemberKYC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OtherMemberKYCUpdateManyArgs>(
      args: SelectSubset<T, OtherMemberKYCUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OtherMemberKYC.
     * @param {OtherMemberKYCUpsertArgs} args - Arguments to update or create a OtherMemberKYC.
     * @example
     * // Update or create a OtherMemberKYC
     * const otherMemberKYC = await prisma.otherMemberKYC.upsert({
     *   create: {
     *     // ... data to create a OtherMemberKYC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtherMemberKYC we want to update
     *   }
     * })
    **/
    upsert<T extends OtherMemberKYCUpsertArgs>(
      args: SelectSubset<T, OtherMemberKYCUpsertArgs>
    ): CheckSelect<T, Prisma__OtherMemberKYCClient<OtherMemberKYC>, Prisma__OtherMemberKYCClient<OtherMemberKYCGetPayload<T>>>

    /**
     * Count the number of OtherMemberKYCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherMemberKYCCountArgs} args - Arguments to filter OtherMemberKYCS to count.
     * @example
     * // Count the number of OtherMemberKYCS
     * const count = await prisma.otherMemberKYC.count({
     *   where: {
     *     // ... the filter for the OtherMemberKYCS we want to count
     *   }
     * })
    **/
    count<T extends OtherMemberKYCCountArgs>(
      args?: Subset<T, OtherMemberKYCCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtherMemberKYCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtherMemberKYC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherMemberKYCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtherMemberKYCAggregateArgs>(args: Subset<T, OtherMemberKYCAggregateArgs>): PrismaPromise<GetOtherMemberKYCAggregateType<T>>

    /**
     * Group by OtherMemberKYC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtherMemberKYCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtherMemberKYCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtherMemberKYCGroupByArgs['orderBy'] }
        : { orderBy?: OtherMemberKYCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtherMemberKYCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtherMemberKYCGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtherMemberKYC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OtherMemberKYCClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    createdBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OtherMemberKYC findUnique
   */
  export type OtherMemberKYCFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OtherMemberKYC
     * 
    **/
    select?: OtherMemberKYCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OtherMemberKYCInclude | null
    /**
     * Throw an Error if a OtherMemberKYC can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OtherMemberKYC to fetch.
     * 
    **/
    where: OtherMemberKYCWhereUniqueInput
  }


  /**
   * OtherMemberKYC findFirst
   */
  export type OtherMemberKYCFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OtherMemberKYC
     * 
    **/
    select?: OtherMemberKYCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OtherMemberKYCInclude | null
    /**
     * Throw an Error if a OtherMemberKYC can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OtherMemberKYC to fetch.
     * 
    **/
    where?: OtherMemberKYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherMemberKYCS to fetch.
     * 
    **/
    orderBy?: Enumerable<OtherMemberKYCOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtherMemberKYCS.
     * 
    **/
    cursor?: OtherMemberKYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherMemberKYCS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherMemberKYCS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtherMemberKYCS.
     * 
    **/
    distinct?: Enumerable<OtherMemberKYCScalarFieldEnum>
  }


  /**
   * OtherMemberKYC findMany
   */
  export type OtherMemberKYCFindManyArgs = {
    /**
     * Select specific fields to fetch from the OtherMemberKYC
     * 
    **/
    select?: OtherMemberKYCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OtherMemberKYCInclude | null
    /**
     * Filter, which OtherMemberKYCS to fetch.
     * 
    **/
    where?: OtherMemberKYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtherMemberKYCS to fetch.
     * 
    **/
    orderBy?: Enumerable<OtherMemberKYCOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtherMemberKYCS.
     * 
    **/
    cursor?: OtherMemberKYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtherMemberKYCS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtherMemberKYCS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OtherMemberKYCScalarFieldEnum>
  }


  /**
   * OtherMemberKYC create
   */
  export type OtherMemberKYCCreateArgs = {
    /**
     * Select specific fields to fetch from the OtherMemberKYC
     * 
    **/
    select?: OtherMemberKYCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OtherMemberKYCInclude | null
    /**
     * The data needed to create a OtherMemberKYC.
     * 
    **/
    data: XOR<OtherMemberKYCCreateInput, OtherMemberKYCUncheckedCreateInput>
  }


  /**
   * OtherMemberKYC createMany
   */
  export type OtherMemberKYCCreateManyArgs = {
    /**
     * The data used to create many OtherMemberKYCS.
     * 
    **/
    data: Enumerable<OtherMemberKYCCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OtherMemberKYC update
   */
  export type OtherMemberKYCUpdateArgs = {
    /**
     * Select specific fields to fetch from the OtherMemberKYC
     * 
    **/
    select?: OtherMemberKYCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OtherMemberKYCInclude | null
    /**
     * The data needed to update a OtherMemberKYC.
     * 
    **/
    data: XOR<OtherMemberKYCUpdateInput, OtherMemberKYCUncheckedUpdateInput>
    /**
     * Choose, which OtherMemberKYC to update.
     * 
    **/
    where: OtherMemberKYCWhereUniqueInput
  }


  /**
   * OtherMemberKYC updateMany
   */
  export type OtherMemberKYCUpdateManyArgs = {
    /**
     * The data used to update OtherMemberKYCS.
     * 
    **/
    data: XOR<OtherMemberKYCUpdateManyMutationInput, OtherMemberKYCUncheckedUpdateManyInput>
    /**
     * Filter which OtherMemberKYCS to update
     * 
    **/
    where?: OtherMemberKYCWhereInput
  }


  /**
   * OtherMemberKYC upsert
   */
  export type OtherMemberKYCUpsertArgs = {
    /**
     * Select specific fields to fetch from the OtherMemberKYC
     * 
    **/
    select?: OtherMemberKYCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OtherMemberKYCInclude | null
    /**
     * The filter to search for the OtherMemberKYC to update in case it exists.
     * 
    **/
    where: OtherMemberKYCWhereUniqueInput
    /**
     * In case the OtherMemberKYC found by the `where` argument doesn't exist, create a new OtherMemberKYC with this data.
     * 
    **/
    create: XOR<OtherMemberKYCCreateInput, OtherMemberKYCUncheckedCreateInput>
    /**
     * In case the OtherMemberKYC was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OtherMemberKYCUpdateInput, OtherMemberKYCUncheckedUpdateInput>
  }


  /**
   * OtherMemberKYC delete
   */
  export type OtherMemberKYCDeleteArgs = {
    /**
     * Select specific fields to fetch from the OtherMemberKYC
     * 
    **/
    select?: OtherMemberKYCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OtherMemberKYCInclude | null
    /**
     * Filter which OtherMemberKYC to delete.
     * 
    **/
    where: OtherMemberKYCWhereUniqueInput
  }


  /**
   * OtherMemberKYC deleteMany
   */
  export type OtherMemberKYCDeleteManyArgs = {
    /**
     * Filter which OtherMemberKYCS to delete
     * 
    **/
    where?: OtherMemberKYCWhereInput
  }


  /**
   * OtherMemberKYC without action
   */
  export type OtherMemberKYCArgs = {
    /**
     * Select specific fields to fetch from the OtherMemberKYC
     * 
    **/
    select?: OtherMemberKYCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OtherMemberKYCInclude | null
  }



  /**
   * Model Settings
   */


  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    woocommerceUrl: string | null
    woocommerceConsumerKey: string | null
    woocommerceActive: boolean | null
    woocommerceConsumerSecret: string | null
    walletAccount: string | null
  }

  export type SettingsMaxAggregateOutputType = {
    woocommerceUrl: string | null
    woocommerceConsumerKey: string | null
    woocommerceActive: boolean | null
    woocommerceConsumerSecret: string | null
    walletAccount: string | null
  }

  export type SettingsCountAggregateOutputType = {
    woocommerceUrl: number
    woocommerceConsumerKey: number
    woocommerceActive: number
    woocommerceConsumerSecret: number
    walletAccount: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    woocommerceUrl?: true
    woocommerceConsumerKey?: true
    woocommerceActive?: true
    woocommerceConsumerSecret?: true
    walletAccount?: true
  }

  export type SettingsMaxAggregateInputType = {
    woocommerceUrl?: true
    woocommerceConsumerKey?: true
    woocommerceActive?: true
    woocommerceConsumerSecret?: true
    walletAccount?: true
  }

  export type SettingsCountAggregateInputType = {
    woocommerceUrl?: true
    woocommerceConsumerKey?: true
    woocommerceActive?: true
    woocommerceConsumerSecret?: true
    walletAccount?: true
    _all?: true
  }

  export type SettingsAggregateArgs = {
    /**
     * Filter which Settings to aggregate.
     * 
    **/
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<SettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs = {
    where?: SettingsWhereInput
    orderBy?: Enumerable<SettingsOrderByWithAggregationInput>
    by: Array<SettingsScalarFieldEnum>
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }


  export type SettingsGroupByOutputType = {
    woocommerceUrl: string | null
    woocommerceConsumerKey: string | null
    woocommerceActive: boolean | null
    woocommerceConsumerSecret: string | null
    walletAccount: string
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect = {
    woocommerceUrl?: boolean
    woocommerceConsumerKey?: boolean
    woocommerceActive?: boolean
    woocommerceConsumerSecret?: boolean
    walletAccount?: boolean
    wallet?: boolean | WalletArgs
  }

  export type SettingsInclude = {
    wallet?: boolean | WalletArgs
  }

  export type SettingsGetPayload<
    S extends boolean | null | undefined | SettingsArgs,
    U = keyof S
      > = S extends true
        ? Settings
    : S extends undefined
    ? never
    : S extends SettingsArgs | SettingsFindManyArgs
    ?'include' extends U
    ? Settings  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :  P extends keyof Settings ? Settings[P] : never
  } 
    : Settings
  : Settings


  type SettingsCountArgs = Merge<
    Omit<SettingsFindManyArgs, 'select' | 'include'> & {
      select?: SettingsCountAggregateInputType | true
    }
  >

  export interface SettingsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SettingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SettingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Settings'> extends True ? CheckSelect<T, Prisma__SettingsClient<Settings>, Prisma__SettingsClient<SettingsGetPayload<T>>> : CheckSelect<T, Prisma__SettingsClient<Settings | null >, Prisma__SettingsClient<SettingsGetPayload<T> | null >>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SettingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SettingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Settings'> extends True ? CheckSelect<T, Prisma__SettingsClient<Settings>, Prisma__SettingsClient<SettingsGetPayload<T>>> : CheckSelect<T, Prisma__SettingsClient<Settings | null >, Prisma__SettingsClient<SettingsGetPayload<T> | null >>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `woocommerceUrl`
     * const settingsWithWoocommerceUrlOnly = await prisma.settings.findMany({ select: { woocommerceUrl: true } })
     * 
    **/
    findMany<T extends SettingsFindManyArgs>(
      args?: SelectSubset<T, SettingsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Settings>>, PrismaPromise<Array<SettingsGetPayload<T>>>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
    **/
    create<T extends SettingsCreateArgs>(
      args: SelectSubset<T, SettingsCreateArgs>
    ): CheckSelect<T, Prisma__SettingsClient<Settings>, Prisma__SettingsClient<SettingsGetPayload<T>>>

    /**
     * Create many Settings.
     *     @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     *     @example
     *     // Create many Settings
     *     const settings = await prisma.settings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SettingsCreateManyArgs>(
      args?: SelectSubset<T, SettingsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
    **/
    delete<T extends SettingsDeleteArgs>(
      args: SelectSubset<T, SettingsDeleteArgs>
    ): CheckSelect<T, Prisma__SettingsClient<Settings>, Prisma__SettingsClient<SettingsGetPayload<T>>>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SettingsUpdateArgs>(
      args: SelectSubset<T, SettingsUpdateArgs>
    ): CheckSelect<T, Prisma__SettingsClient<Settings>, Prisma__SettingsClient<SettingsGetPayload<T>>>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SettingsDeleteManyArgs>(
      args?: SelectSubset<T, SettingsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SettingsUpdateManyArgs>(
      args: SelectSubset<T, SettingsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
    **/
    upsert<T extends SettingsUpsertArgs>(
      args: SelectSubset<T, SettingsUpsertArgs>
    ): CheckSelect<T, Prisma__SettingsClient<Settings>, Prisma__SettingsClient<SettingsGetPayload<T>>>

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SettingsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Settings
     * 
    **/
    select?: SettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettingsInclude | null
    /**
     * Throw an Error if a Settings can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Settings to fetch.
     * 
    **/
    where: SettingsWhereUniqueInput
  }


  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Settings
     * 
    **/
    select?: SettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettingsInclude | null
    /**
     * Throw an Error if a Settings can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Settings to fetch.
     * 
    **/
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<SettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     * 
    **/
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     * 
    **/
    distinct?: Enumerable<SettingsScalarFieldEnum>
  }


  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Settings
     * 
    **/
    select?: SettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettingsInclude | null
    /**
     * Filter, which Settings to fetch.
     * 
    **/
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<SettingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     * 
    **/
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SettingsScalarFieldEnum>
  }


  /**
   * Settings create
   */
  export type SettingsCreateArgs = {
    /**
     * Select specific fields to fetch from the Settings
     * 
    **/
    select?: SettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettingsInclude | null
    /**
     * The data needed to create a Settings.
     * 
    **/
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }


  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs = {
    /**
     * The data used to create many Settings.
     * 
    **/
    data: Enumerable<SettingsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Settings update
   */
  export type SettingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Settings
     * 
    **/
    select?: SettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettingsInclude | null
    /**
     * The data needed to update a Settings.
     * 
    **/
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     * 
    **/
    where: SettingsWhereUniqueInput
  }


  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs = {
    /**
     * The data used to update Settings.
     * 
    **/
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     * 
    **/
    where?: SettingsWhereInput
  }


  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Settings
     * 
    **/
    select?: SettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettingsInclude | null
    /**
     * The filter to search for the Settings to update in case it exists.
     * 
    **/
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     * 
    **/
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }


  /**
   * Settings delete
   */
  export type SettingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Settings
     * 
    **/
    select?: SettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettingsInclude | null
    /**
     * Filter which Settings to delete.
     * 
    **/
    where: SettingsWhereUniqueInput
  }


  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs = {
    /**
     * Filter which Settings to delete
     * 
    **/
    where?: SettingsWhereInput
  }


  /**
   * Settings without action
   */
  export type SettingsArgs = {
    /**
     * Select specific fields to fetch from the Settings
     * 
    **/
    select?: SettingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettingsInclude | null
  }



  /**
   * Model Settlement
   */


  export type AggregateSettlement = {
    _count: SettlementCountAggregateOutputType | null
    _min: SettlementMinAggregateOutputType | null
    _max: SettlementMaxAggregateOutputType | null
  }

  export type SettlementMinAggregateOutputType = {
    id: string | null
    type: TransactionMethodEnum | null
    account: string | null
    bankAccount: string | null
    bankAccountName: string | null
    bankBranch: string | null
    bankName: string | null
    phoneNumber: string | null
    tillNumber: string | null
    paybillNumber: string | null
    verified: boolean | null
    verifiedByUser: string | null
    createdAt: Date | null
    createdBy: string | null
    createdByAgent: boolean | null
  }

  export type SettlementMaxAggregateOutputType = {
    id: string | null
    type: TransactionMethodEnum | null
    account: string | null
    bankAccount: string | null
    bankAccountName: string | null
    bankBranch: string | null
    bankName: string | null
    phoneNumber: string | null
    tillNumber: string | null
    paybillNumber: string | null
    verified: boolean | null
    verifiedByUser: string | null
    createdAt: Date | null
    createdBy: string | null
    createdByAgent: boolean | null
  }

  export type SettlementCountAggregateOutputType = {
    id: number
    type: number
    account: number
    bankAccount: number
    bankAccountName: number
    bankBranch: number
    bankName: number
    phoneNumber: number
    tillNumber: number
    paybillNumber: number
    verified: number
    verifiedByUser: number
    createdAt: number
    createdBy: number
    createdByAgent: number
    _all: number
  }


  export type SettlementMinAggregateInputType = {
    id?: true
    type?: true
    account?: true
    bankAccount?: true
    bankAccountName?: true
    bankBranch?: true
    bankName?: true
    phoneNumber?: true
    tillNumber?: true
    paybillNumber?: true
    verified?: true
    verifiedByUser?: true
    createdAt?: true
    createdBy?: true
    createdByAgent?: true
  }

  export type SettlementMaxAggregateInputType = {
    id?: true
    type?: true
    account?: true
    bankAccount?: true
    bankAccountName?: true
    bankBranch?: true
    bankName?: true
    phoneNumber?: true
    tillNumber?: true
    paybillNumber?: true
    verified?: true
    verifiedByUser?: true
    createdAt?: true
    createdBy?: true
    createdByAgent?: true
  }

  export type SettlementCountAggregateInputType = {
    id?: true
    type?: true
    account?: true
    bankAccount?: true
    bankAccountName?: true
    bankBranch?: true
    bankName?: true
    phoneNumber?: true
    tillNumber?: true
    paybillNumber?: true
    verified?: true
    verifiedByUser?: true
    createdAt?: true
    createdBy?: true
    createdByAgent?: true
    _all?: true
  }

  export type SettlementAggregateArgs = {
    /**
     * Filter which Settlement to aggregate.
     * 
    **/
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     * 
    **/
    orderBy?: Enumerable<SettlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settlements
    **/
    _count?: true | SettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettlementMaxAggregateInputType
  }

  export type GetSettlementAggregateType<T extends SettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettlement[P]>
      : GetScalarType<T[P], AggregateSettlement[P]>
  }




  export type SettlementGroupByArgs = {
    where?: SettlementWhereInput
    orderBy?: Enumerable<SettlementOrderByWithAggregationInput>
    by: Array<SettlementScalarFieldEnum>
    having?: SettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettlementCountAggregateInputType | true
    _min?: SettlementMinAggregateInputType
    _max?: SettlementMaxAggregateInputType
  }


  export type SettlementGroupByOutputType = {
    id: string
    type: TransactionMethodEnum
    account: string
    bankAccount: string | null
    bankAccountName: string | null
    bankBranch: string | null
    bankName: string | null
    phoneNumber: string | null
    tillNumber: string | null
    paybillNumber: string | null
    verified: boolean | null
    verifiedByUser: string | null
    createdAt: Date
    createdBy: string
    createdByAgent: boolean
    _count: SettlementCountAggregateOutputType | null
    _min: SettlementMinAggregateOutputType | null
    _max: SettlementMaxAggregateOutputType | null
  }

  type GetSettlementGroupByPayload<T extends SettlementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettlementGroupByOutputType[P]>
            : GetScalarType<T[P], SettlementGroupByOutputType[P]>
        }
      >
    >


  export type SettlementSelect = {
    id?: boolean
    type?: boolean
    account?: boolean
    bankAccount?: boolean
    bankAccountName?: boolean
    bankBranch?: boolean
    bankName?: boolean
    phoneNumber?: boolean
    tillNumber?: boolean
    paybillNumber?: boolean
    verified?: boolean
    verifiedByUser?: boolean
    createdAt?: boolean
    createdBy?: boolean
    createdByAgent?: boolean
    wallet?: boolean | WalletArgs
    settlementCreator?: boolean | UserArgs
    settlementVerifier?: boolean | UserArgs
    Wallet?: boolean | WalletFindManyArgs
    _count?: boolean | SettlementCountOutputTypeArgs
  }

  export type SettlementInclude = {
    wallet?: boolean | WalletArgs
    settlementCreator?: boolean | UserArgs
    settlementVerifier?: boolean | UserArgs
    Wallet?: boolean | WalletFindManyArgs
    _count?: boolean | SettlementCountOutputTypeArgs
  }

  export type SettlementGetPayload<
    S extends boolean | null | undefined | SettlementArgs,
    U = keyof S
      > = S extends true
        ? Settlement
    : S extends undefined
    ? never
    : S extends SettlementArgs | SettlementFindManyArgs
    ?'include' extends U
    ? Settlement  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :
        P extends 'settlementCreator' ? UserGetPayload<S['include'][P]> :
        P extends 'settlementVerifier' ? UserGetPayload<S['include'][P]> | null :
        P extends 'Wallet' ? Array < WalletGetPayload<S['include'][P]>>  :
        P extends '_count' ? SettlementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :
        P extends 'settlementCreator' ? UserGetPayload<S['select'][P]> :
        P extends 'settlementVerifier' ? UserGetPayload<S['select'][P]> | null :
        P extends 'Wallet' ? Array < WalletGetPayload<S['select'][P]>>  :
        P extends '_count' ? SettlementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Settlement ? Settlement[P] : never
  } 
    : Settlement
  : Settlement


  type SettlementCountArgs = Merge<
    Omit<SettlementFindManyArgs, 'select' | 'include'> & {
      select?: SettlementCountAggregateInputType | true
    }
  >

  export interface SettlementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Settlement that matches the filter.
     * @param {SettlementFindUniqueArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SettlementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SettlementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Settlement'> extends True ? CheckSelect<T, Prisma__SettlementClient<Settlement>, Prisma__SettlementClient<SettlementGetPayload<T>>> : CheckSelect<T, Prisma__SettlementClient<Settlement | null >, Prisma__SettlementClient<SettlementGetPayload<T> | null >>

    /**
     * Find the first Settlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindFirstArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SettlementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SettlementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Settlement'> extends True ? CheckSelect<T, Prisma__SettlementClient<Settlement>, Prisma__SettlementClient<SettlementGetPayload<T>>> : CheckSelect<T, Prisma__SettlementClient<Settlement | null >, Prisma__SettlementClient<SettlementGetPayload<T> | null >>

    /**
     * Find zero or more Settlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settlements
     * const settlements = await prisma.settlement.findMany()
     * 
     * // Get first 10 Settlements
     * const settlements = await prisma.settlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settlementWithIdOnly = await prisma.settlement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SettlementFindManyArgs>(
      args?: SelectSubset<T, SettlementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Settlement>>, PrismaPromise<Array<SettlementGetPayload<T>>>>

    /**
     * Create a Settlement.
     * @param {SettlementCreateArgs} args - Arguments to create a Settlement.
     * @example
     * // Create one Settlement
     * const Settlement = await prisma.settlement.create({
     *   data: {
     *     // ... data to create a Settlement
     *   }
     * })
     * 
    **/
    create<T extends SettlementCreateArgs>(
      args: SelectSubset<T, SettlementCreateArgs>
    ): CheckSelect<T, Prisma__SettlementClient<Settlement>, Prisma__SettlementClient<SettlementGetPayload<T>>>

    /**
     * Create many Settlements.
     *     @param {SettlementCreateManyArgs} args - Arguments to create many Settlements.
     *     @example
     *     // Create many Settlements
     *     const settlement = await prisma.settlement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SettlementCreateManyArgs>(
      args?: SelectSubset<T, SettlementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Settlement.
     * @param {SettlementDeleteArgs} args - Arguments to delete one Settlement.
     * @example
     * // Delete one Settlement
     * const Settlement = await prisma.settlement.delete({
     *   where: {
     *     // ... filter to delete one Settlement
     *   }
     * })
     * 
    **/
    delete<T extends SettlementDeleteArgs>(
      args: SelectSubset<T, SettlementDeleteArgs>
    ): CheckSelect<T, Prisma__SettlementClient<Settlement>, Prisma__SettlementClient<SettlementGetPayload<T>>>

    /**
     * Update one Settlement.
     * @param {SettlementUpdateArgs} args - Arguments to update one Settlement.
     * @example
     * // Update one Settlement
     * const settlement = await prisma.settlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SettlementUpdateArgs>(
      args: SelectSubset<T, SettlementUpdateArgs>
    ): CheckSelect<T, Prisma__SettlementClient<Settlement>, Prisma__SettlementClient<SettlementGetPayload<T>>>

    /**
     * Delete zero or more Settlements.
     * @param {SettlementDeleteManyArgs} args - Arguments to filter Settlements to delete.
     * @example
     * // Delete a few Settlements
     * const { count } = await prisma.settlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SettlementDeleteManyArgs>(
      args?: SelectSubset<T, SettlementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settlements
     * const settlement = await prisma.settlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SettlementUpdateManyArgs>(
      args: SelectSubset<T, SettlementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Settlement.
     * @param {SettlementUpsertArgs} args - Arguments to update or create a Settlement.
     * @example
     * // Update or create a Settlement
     * const settlement = await prisma.settlement.upsert({
     *   create: {
     *     // ... data to create a Settlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settlement we want to update
     *   }
     * })
    **/
    upsert<T extends SettlementUpsertArgs>(
      args: SelectSubset<T, SettlementUpsertArgs>
    ): CheckSelect<T, Prisma__SettlementClient<Settlement>, Prisma__SettlementClient<SettlementGetPayload<T>>>

    /**
     * Count the number of Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementCountArgs} args - Arguments to filter Settlements to count.
     * @example
     * // Count the number of Settlements
     * const count = await prisma.settlement.count({
     *   where: {
     *     // ... the filter for the Settlements we want to count
     *   }
     * })
    **/
    count<T extends SettlementCountArgs>(
      args?: Subset<T, SettlementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettlementAggregateArgs>(args: Subset<T, SettlementAggregateArgs>): PrismaPromise<GetSettlementAggregateType<T>>

    /**
     * Group by Settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettlementGroupByArgs['orderBy'] }
        : { orderBy?: SettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettlementGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SettlementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    settlementCreator<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    settlementVerifier<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    Wallet<T extends WalletFindManyArgs = {}>(args?: Subset<T, WalletFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Wallet>>, PrismaPromise<Array<WalletGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Settlement findUnique
   */
  export type SettlementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Settlement
     * 
    **/
    select?: SettlementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettlementInclude | null
    /**
     * Throw an Error if a Settlement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Settlement to fetch.
     * 
    **/
    where: SettlementWhereUniqueInput
  }


  /**
   * Settlement findFirst
   */
  export type SettlementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Settlement
     * 
    **/
    select?: SettlementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettlementInclude | null
    /**
     * Throw an Error if a Settlement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Settlement to fetch.
     * 
    **/
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     * 
    **/
    orderBy?: Enumerable<SettlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settlements.
     * 
    **/
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settlements.
     * 
    **/
    distinct?: Enumerable<SettlementScalarFieldEnum>
  }


  /**
   * Settlement findMany
   */
  export type SettlementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Settlement
     * 
    **/
    select?: SettlementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettlementInclude | null
    /**
     * Filter, which Settlements to fetch.
     * 
    **/
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     * 
    **/
    orderBy?: Enumerable<SettlementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settlements.
     * 
    **/
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SettlementScalarFieldEnum>
  }


  /**
   * Settlement create
   */
  export type SettlementCreateArgs = {
    /**
     * Select specific fields to fetch from the Settlement
     * 
    **/
    select?: SettlementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettlementInclude | null
    /**
     * The data needed to create a Settlement.
     * 
    **/
    data: XOR<SettlementCreateInput, SettlementUncheckedCreateInput>
  }


  /**
   * Settlement createMany
   */
  export type SettlementCreateManyArgs = {
    /**
     * The data used to create many Settlements.
     * 
    **/
    data: Enumerable<SettlementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Settlement update
   */
  export type SettlementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Settlement
     * 
    **/
    select?: SettlementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettlementInclude | null
    /**
     * The data needed to update a Settlement.
     * 
    **/
    data: XOR<SettlementUpdateInput, SettlementUncheckedUpdateInput>
    /**
     * Choose, which Settlement to update.
     * 
    **/
    where: SettlementWhereUniqueInput
  }


  /**
   * Settlement updateMany
   */
  export type SettlementUpdateManyArgs = {
    /**
     * The data used to update Settlements.
     * 
    **/
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyInput>
    /**
     * Filter which Settlements to update
     * 
    **/
    where?: SettlementWhereInput
  }


  /**
   * Settlement upsert
   */
  export type SettlementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Settlement
     * 
    **/
    select?: SettlementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettlementInclude | null
    /**
     * The filter to search for the Settlement to update in case it exists.
     * 
    **/
    where: SettlementWhereUniqueInput
    /**
     * In case the Settlement found by the `where` argument doesn't exist, create a new Settlement with this data.
     * 
    **/
    create: XOR<SettlementCreateInput, SettlementUncheckedCreateInput>
    /**
     * In case the Settlement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SettlementUpdateInput, SettlementUncheckedUpdateInput>
  }


  /**
   * Settlement delete
   */
  export type SettlementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Settlement
     * 
    **/
    select?: SettlementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettlementInclude | null
    /**
     * Filter which Settlement to delete.
     * 
    **/
    where: SettlementWhereUniqueInput
  }


  /**
   * Settlement deleteMany
   */
  export type SettlementDeleteManyArgs = {
    /**
     * Filter which Settlements to delete
     * 
    **/
    where?: SettlementWhereInput
  }


  /**
   * Settlement without action
   */
  export type SettlementArgs = {
    /**
     * Select specific fields to fetch from the Settlement
     * 
    **/
    select?: SettlementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SettlementInclude | null
  }



  /**
   * Model Question
   */


  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    answersType: answerTypeEnum | null
    category: QuestionCategoryEnum | null
    question: string | null
    isActive: boolean | null
    description: string | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    answersType: answerTypeEnum | null
    category: QuestionCategoryEnum | null
    question: string | null
    isActive: boolean | null
    description: string | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    answersType: number
    category: number
    question: number
    isActive: number
    description: number
    _all: number
  }


  export type QuestionMinAggregateInputType = {
    id?: true
    answersType?: true
    category?: true
    question?: true
    isActive?: true
    description?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    answersType?: true
    category?: true
    question?: true
    isActive?: true
    description?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    answersType?: true
    category?: true
    question?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type QuestionAggregateArgs = {
    /**
     * Filter which Question to aggregate.
     * 
    **/
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs = {
    where?: QuestionWhereInput
    orderBy?: Enumerable<QuestionOrderByWithAggregationInput>
    by: Array<QuestionScalarFieldEnum>
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }


  export type QuestionGroupByOutputType = {
    id: string
    answersType: answerTypeEnum
    category: QuestionCategoryEnum
    question: string
    isActive: boolean
    description: string | null
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect = {
    id?: boolean
    answersType?: boolean
    category?: boolean
    question?: boolean
    isActive?: boolean
    description?: boolean
    answers?: boolean | AnswerFindManyArgs
    _count?: boolean | QuestionCountOutputTypeArgs
  }

  export type QuestionInclude = {
    answers?: boolean | AnswerFindManyArgs
    _count?: boolean | QuestionCountOutputTypeArgs
  }

  export type QuestionGetPayload<
    S extends boolean | null | undefined | QuestionArgs,
    U = keyof S
      > = S extends true
        ? Question
    : S extends undefined
    ? never
    : S extends QuestionArgs | QuestionFindManyArgs
    ?'include' extends U
    ? Question  & {
    [P in TrueKeys<S['include']>]:
        P extends 'answers' ? Array < AnswerGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuestionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'answers' ? Array < AnswerGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuestionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Question ? Question[P] : never
  } 
    : Question
  : Question


  type QuestionCountArgs = Merge<
    Omit<QuestionFindManyArgs, 'select' | 'include'> & {
      select?: QuestionCountAggregateInputType | true
    }
  >

  export interface QuestionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Question'> extends True ? CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>> : CheckSelect<T, Prisma__QuestionClient<Question | null >, Prisma__QuestionClient<QuestionGetPayload<T> | null >>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Question'> extends True ? CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>> : CheckSelect<T, Prisma__QuestionClient<Question | null >, Prisma__QuestionClient<QuestionGetPayload<T> | null >>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionFindManyArgs>(
      args?: SelectSubset<T, QuestionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Question>>, PrismaPromise<Array<QuestionGetPayload<T>>>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
    **/
    create<T extends QuestionCreateArgs>(
      args: SelectSubset<T, QuestionCreateArgs>
    ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>

    /**
     * Create many Questions.
     *     @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     *     @example
     *     // Create many Questions
     *     const question = await prisma.question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionCreateManyArgs>(
      args?: SelectSubset<T, QuestionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
    **/
    delete<T extends QuestionDeleteArgs>(
      args: SelectSubset<T, QuestionDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionUpdateArgs>(
      args: SelectSubset<T, QuestionUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuestionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionUpdateManyArgs>(
      args: SelectSubset<T, QuestionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionUpsertArgs>(
      args: SelectSubset<T, QuestionUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionClient<Question>, Prisma__QuestionClient<QuestionGetPayload<T>>>

    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    answers<T extends AnswerFindManyArgs = {}>(args?: Subset<T, AnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Answer>>, PrismaPromise<Array<AnswerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Throw an Error if a Question can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Question to fetch.
     * 
    **/
    where: QuestionWhereUniqueInput
  }


  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Throw an Error if a Question can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Question to fetch.
     * 
    **/
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     * 
    **/
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     * 
    **/
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * Question findMany
   */
  export type QuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Filter, which Questions to fetch.
     * 
    **/
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     * 
    **/
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * Question create
   */
  export type QuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * The data needed to create a Question.
     * 
    **/
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }


  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs = {
    /**
     * The data used to create many Questions.
     * 
    **/
    data: Enumerable<QuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Question update
   */
  export type QuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * The data needed to update a Question.
     * 
    **/
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     * 
    **/
    where: QuestionWhereUniqueInput
  }


  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs = {
    /**
     * The data used to update Questions.
     * 
    **/
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     * 
    **/
    where?: QuestionWhereInput
  }


  /**
   * Question upsert
   */
  export type QuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * The filter to search for the Question to update in case it exists.
     * 
    **/
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     * 
    **/
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }


  /**
   * Question delete
   */
  export type QuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Filter which Question to delete.
     * 
    **/
    where: QuestionWhereUniqueInput
  }


  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs = {
    /**
     * Filter which Questions to delete
     * 
    **/
    where?: QuestionWhereInput
  }


  /**
   * Question without action
   */
  export type QuestionArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
  }



  /**
   * Model Answer
   */


  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    createdAt: Date | null
    answer: string | null
    answeredBy: string | null
    answeredByReference: string | null
    account: string | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    createdAt: Date | null
    answer: string | null
    answeredBy: string | null
    answeredByReference: string | null
    account: string | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    questionId: number
    createdAt: number
    answer: number
    answeredBy: number
    answeredByReference: number
    account: number
    _all: number
  }


  export type AnswerMinAggregateInputType = {
    id?: true
    questionId?: true
    createdAt?: true
    answer?: true
    answeredBy?: true
    answeredByReference?: true
    account?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    questionId?: true
    createdAt?: true
    answer?: true
    answeredBy?: true
    answeredByReference?: true
    account?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    questionId?: true
    createdAt?: true
    answer?: true
    answeredBy?: true
    answeredByReference?: true
    account?: true
    _all?: true
  }

  export type AnswerAggregateArgs = {
    /**
     * Filter which Answer to aggregate.
     * 
    **/
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     * 
    **/
    orderBy?: Enumerable<AnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs = {
    where?: AnswerWhereInput
    orderBy?: Enumerable<AnswerOrderByWithAggregationInput>
    by: Array<AnswerScalarFieldEnum>
    having?: AnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }


  export type AnswerGroupByOutputType = {
    id: string
    questionId: string
    createdAt: Date
    answer: string
    answeredBy: string | null
    answeredByReference: string | null
    account: string
    _count: AnswerCountAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type AnswerSelect = {
    id?: boolean
    questionId?: boolean
    createdAt?: boolean
    answer?: boolean
    answeredBy?: boolean
    answeredByReference?: boolean
    account?: boolean
    wallet?: boolean | WalletArgs
    answered?: boolean | UserArgs
    question?: boolean | QuestionArgs
  }

  export type AnswerInclude = {
    wallet?: boolean | WalletArgs
    answered?: boolean | UserArgs
    question?: boolean | QuestionArgs
  }

  export type AnswerGetPayload<
    S extends boolean | null | undefined | AnswerArgs,
    U = keyof S
      > = S extends true
        ? Answer
    : S extends undefined
    ? never
    : S extends AnswerArgs | AnswerFindManyArgs
    ?'include' extends U
    ? Answer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :
        P extends 'answered' ? UserGetPayload<S['include'][P]> | null :
        P extends 'question' ? QuestionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :
        P extends 'answered' ? UserGetPayload<S['select'][P]> | null :
        P extends 'question' ? QuestionGetPayload<S['select'][P]> :  P extends keyof Answer ? Answer[P] : never
  } 
    : Answer
  : Answer


  type AnswerCountArgs = Merge<
    Omit<AnswerFindManyArgs, 'select' | 'include'> & {
      select?: AnswerCountAggregateInputType | true
    }
  >

  export interface AnswerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnswerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AnswerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Answer'> extends True ? CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>> : CheckSelect<T, Prisma__AnswerClient<Answer | null >, Prisma__AnswerClient<AnswerGetPayload<T> | null >>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnswerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AnswerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Answer'> extends True ? CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>> : CheckSelect<T, Prisma__AnswerClient<Answer | null >, Prisma__AnswerClient<AnswerGetPayload<T> | null >>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnswerFindManyArgs>(
      args?: SelectSubset<T, AnswerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Answer>>, PrismaPromise<Array<AnswerGetPayload<T>>>>

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
    **/
    create<T extends AnswerCreateArgs>(
      args: SelectSubset<T, AnswerCreateArgs>
    ): CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>>

    /**
     * Create many Answers.
     *     @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     *     @example
     *     // Create many Answers
     *     const answer = await prisma.answer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnswerCreateManyArgs>(
      args?: SelectSubset<T, AnswerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
    **/
    delete<T extends AnswerDeleteArgs>(
      args: SelectSubset<T, AnswerDeleteArgs>
    ): CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>>

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnswerUpdateArgs>(
      args: SelectSubset<T, AnswerUpdateArgs>
    ): CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>>

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnswerDeleteManyArgs>(
      args?: SelectSubset<T, AnswerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnswerUpdateManyArgs>(
      args: SelectSubset<T, AnswerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
    **/
    upsert<T extends AnswerUpsertArgs>(
      args: SelectSubset<T, AnswerUpsertArgs>
    ): CheckSelect<T, Prisma__AnswerClient<Answer>, Prisma__AnswerClient<AnswerGetPayload<T>>>

    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AnswerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    wallet<T extends WalletArgs = {}>(args?: Subset<T, WalletArgs>): CheckSelect<T, Prisma__WalletClient<Wallet | null >, Prisma__WalletClient<WalletGetPayload<T> | null >>;

    answered<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    question<T extends QuestionArgs = {}>(args?: Subset<T, QuestionArgs>): CheckSelect<T, Prisma__QuestionClient<Question | null >, Prisma__QuestionClient<QuestionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Answer findUnique
   */
  export type AnswerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Throw an Error if a Answer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Answer to fetch.
     * 
    **/
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer findFirst
   */
  export type AnswerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Throw an Error if a Answer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Answer to fetch.
     * 
    **/
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     * 
    **/
    orderBy?: Enumerable<AnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     * 
    **/
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     * 
    **/
    distinct?: Enumerable<AnswerScalarFieldEnum>
  }


  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Filter, which Answers to fetch.
     * 
    **/
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     * 
    **/
    orderBy?: Enumerable<AnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     * 
    **/
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AnswerScalarFieldEnum>
  }


  /**
   * Answer create
   */
  export type AnswerCreateArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * The data needed to create a Answer.
     * 
    **/
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
  }


  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs = {
    /**
     * The data used to create many Answers.
     * 
    **/
    data: Enumerable<AnswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Answer update
   */
  export type AnswerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * The data needed to update a Answer.
     * 
    **/
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
    /**
     * Choose, which Answer to update.
     * 
    **/
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs = {
    /**
     * The data used to update Answers.
     * 
    **/
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     * 
    **/
    where?: AnswerWhereInput
  }


  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * The filter to search for the Answer to update in case it exists.
     * 
    **/
    where: AnswerWhereUniqueInput
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     * 
    **/
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
  }


  /**
   * Answer delete
   */
  export type AnswerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Filter which Answer to delete.
     * 
    **/
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs = {
    /**
     * Filter which Answers to delete
     * 
    **/
    where?: AnswerWhereInput
  }


  /**
   * Answer without action
   */
  export type AnswerArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
  }



  /**
   * Model CreditRequest
   */


  export type AggregateCreditRequest = {
    _count: CreditRequestCountAggregateOutputType | null
    _min: CreditRequestMinAggregateOutputType | null
    _max: CreditRequestMaxAggregateOutputType | null
  }

  export type CreditRequestMinAggregateOutputType = {
    id: string | null
    status: CreditRequestStatus | null
    orderId: string | null
    wallet: string | null
    creditConfigurationId: string | null
    userId: string | null
    createdAt: Date | null
    proceedAt: Date | null
  }

  export type CreditRequestMaxAggregateOutputType = {
    id: string | null
    status: CreditRequestStatus | null
    orderId: string | null
    wallet: string | null
    creditConfigurationId: string | null
    userId: string | null
    createdAt: Date | null
    proceedAt: Date | null
  }

  export type CreditRequestCountAggregateOutputType = {
    id: number
    status: number
    orderId: number
    wallet: number
    creditConfigurationId: number
    userId: number
    createdAt: number
    proceedAt: number
    _all: number
  }


  export type CreditRequestMinAggregateInputType = {
    id?: true
    status?: true
    orderId?: true
    wallet?: true
    creditConfigurationId?: true
    userId?: true
    createdAt?: true
    proceedAt?: true
  }

  export type CreditRequestMaxAggregateInputType = {
    id?: true
    status?: true
    orderId?: true
    wallet?: true
    creditConfigurationId?: true
    userId?: true
    createdAt?: true
    proceedAt?: true
  }

  export type CreditRequestCountAggregateInputType = {
    id?: true
    status?: true
    orderId?: true
    wallet?: true
    creditConfigurationId?: true
    userId?: true
    createdAt?: true
    proceedAt?: true
    _all?: true
  }

  export type CreditRequestAggregateArgs = {
    /**
     * Filter which CreditRequest to aggregate.
     * 
    **/
    where?: CreditRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CreditRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditRequests
    **/
    _count?: true | CreditRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditRequestMaxAggregateInputType
  }

  export type GetCreditRequestAggregateType<T extends CreditRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditRequest[P]>
      : GetScalarType<T[P], AggregateCreditRequest[P]>
  }




  export type CreditRequestGroupByArgs = {
    where?: CreditRequestWhereInput
    orderBy?: Enumerable<CreditRequestOrderByWithAggregationInput>
    by: Array<CreditRequestScalarFieldEnum>
    having?: CreditRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditRequestCountAggregateInputType | true
    _min?: CreditRequestMinAggregateInputType
    _max?: CreditRequestMaxAggregateInputType
  }


  export type CreditRequestGroupByOutputType = {
    id: string
    status: CreditRequestStatus
    orderId: string
    wallet: string
    creditConfigurationId: string
    userId: string
    createdAt: Date
    proceedAt: Date
    _count: CreditRequestCountAggregateOutputType | null
    _min: CreditRequestMinAggregateOutputType | null
    _max: CreditRequestMaxAggregateOutputType | null
  }

  type GetCreditRequestGroupByPayload<T extends CreditRequestGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CreditRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CreditRequestGroupByOutputType[P]>
        }
      >
    >


  export type CreditRequestSelect = {
    id?: boolean
    status?: boolean
    orderId?: boolean
    wallet?: boolean
    creditConfigurationId?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    order?: boolean | OrderArgs
    creditConfiguration?: boolean | CreditConfigurationArgs
    createdAt?: boolean
    proceedAt?: boolean
  }

  export type CreditRequestInclude = {
    user?: boolean | UserArgs
    order?: boolean | OrderArgs
    creditConfiguration?: boolean | CreditConfigurationArgs
  }

  export type CreditRequestGetPayload<
    S extends boolean | null | undefined | CreditRequestArgs,
    U = keyof S
      > = S extends true
        ? CreditRequest
    : S extends undefined
    ? never
    : S extends CreditRequestArgs | CreditRequestFindManyArgs
    ?'include' extends U
    ? CreditRequest  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'order' ? OrderGetPayload<S['include'][P]> | null :
        P extends 'creditConfiguration' ? CreditConfigurationGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'order' ? OrderGetPayload<S['select'][P]> | null :
        P extends 'creditConfiguration' ? CreditConfigurationGetPayload<S['select'][P]> | null :  P extends keyof CreditRequest ? CreditRequest[P] : never
  } 
    : CreditRequest
  : CreditRequest


  type CreditRequestCountArgs = Merge<
    Omit<CreditRequestFindManyArgs, 'select' | 'include'> & {
      select?: CreditRequestCountAggregateInputType | true
    }
  >

  export interface CreditRequestDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CreditRequest that matches the filter.
     * @param {CreditRequestFindUniqueArgs} args - Arguments to find a CreditRequest
     * @example
     * // Get one CreditRequest
     * const creditRequest = await prisma.creditRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreditRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreditRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CreditRequest'> extends True ? CheckSelect<T, Prisma__CreditRequestClient<CreditRequest>, Prisma__CreditRequestClient<CreditRequestGetPayload<T>>> : CheckSelect<T, Prisma__CreditRequestClient<CreditRequest | null >, Prisma__CreditRequestClient<CreditRequestGetPayload<T> | null >>

    /**
     * Find the first CreditRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRequestFindFirstArgs} args - Arguments to find a CreditRequest
     * @example
     * // Get one CreditRequest
     * const creditRequest = await prisma.creditRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreditRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreditRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CreditRequest'> extends True ? CheckSelect<T, Prisma__CreditRequestClient<CreditRequest>, Prisma__CreditRequestClient<CreditRequestGetPayload<T>>> : CheckSelect<T, Prisma__CreditRequestClient<CreditRequest | null >, Prisma__CreditRequestClient<CreditRequestGetPayload<T> | null >>

    /**
     * Find zero or more CreditRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditRequests
     * const creditRequests = await prisma.creditRequest.findMany()
     * 
     * // Get first 10 CreditRequests
     * const creditRequests = await prisma.creditRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditRequestWithIdOnly = await prisma.creditRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreditRequestFindManyArgs>(
      args?: SelectSubset<T, CreditRequestFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CreditRequest>>, PrismaPromise<Array<CreditRequestGetPayload<T>>>>

    /**
     * Create a CreditRequest.
     * @param {CreditRequestCreateArgs} args - Arguments to create a CreditRequest.
     * @example
     * // Create one CreditRequest
     * const CreditRequest = await prisma.creditRequest.create({
     *   data: {
     *     // ... data to create a CreditRequest
     *   }
     * })
     * 
    **/
    create<T extends CreditRequestCreateArgs>(
      args: SelectSubset<T, CreditRequestCreateArgs>
    ): CheckSelect<T, Prisma__CreditRequestClient<CreditRequest>, Prisma__CreditRequestClient<CreditRequestGetPayload<T>>>

    /**
     * Create many CreditRequests.
     *     @param {CreditRequestCreateManyArgs} args - Arguments to create many CreditRequests.
     *     @example
     *     // Create many CreditRequests
     *     const creditRequest = await prisma.creditRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreditRequestCreateManyArgs>(
      args?: SelectSubset<T, CreditRequestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CreditRequest.
     * @param {CreditRequestDeleteArgs} args - Arguments to delete one CreditRequest.
     * @example
     * // Delete one CreditRequest
     * const CreditRequest = await prisma.creditRequest.delete({
     *   where: {
     *     // ... filter to delete one CreditRequest
     *   }
     * })
     * 
    **/
    delete<T extends CreditRequestDeleteArgs>(
      args: SelectSubset<T, CreditRequestDeleteArgs>
    ): CheckSelect<T, Prisma__CreditRequestClient<CreditRequest>, Prisma__CreditRequestClient<CreditRequestGetPayload<T>>>

    /**
     * Update one CreditRequest.
     * @param {CreditRequestUpdateArgs} args - Arguments to update one CreditRequest.
     * @example
     * // Update one CreditRequest
     * const creditRequest = await prisma.creditRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreditRequestUpdateArgs>(
      args: SelectSubset<T, CreditRequestUpdateArgs>
    ): CheckSelect<T, Prisma__CreditRequestClient<CreditRequest>, Prisma__CreditRequestClient<CreditRequestGetPayload<T>>>

    /**
     * Delete zero or more CreditRequests.
     * @param {CreditRequestDeleteManyArgs} args - Arguments to filter CreditRequests to delete.
     * @example
     * // Delete a few CreditRequests
     * const { count } = await prisma.creditRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreditRequestDeleteManyArgs>(
      args?: SelectSubset<T, CreditRequestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditRequests
     * const creditRequest = await prisma.creditRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreditRequestUpdateManyArgs>(
      args: SelectSubset<T, CreditRequestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditRequest.
     * @param {CreditRequestUpsertArgs} args - Arguments to update or create a CreditRequest.
     * @example
     * // Update or create a CreditRequest
     * const creditRequest = await prisma.creditRequest.upsert({
     *   create: {
     *     // ... data to create a CreditRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditRequest we want to update
     *   }
     * })
    **/
    upsert<T extends CreditRequestUpsertArgs>(
      args: SelectSubset<T, CreditRequestUpsertArgs>
    ): CheckSelect<T, Prisma__CreditRequestClient<CreditRequest>, Prisma__CreditRequestClient<CreditRequestGetPayload<T>>>

    /**
     * Count the number of CreditRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRequestCountArgs} args - Arguments to filter CreditRequests to count.
     * @example
     * // Count the number of CreditRequests
     * const count = await prisma.creditRequest.count({
     *   where: {
     *     // ... the filter for the CreditRequests we want to count
     *   }
     * })
    **/
    count<T extends CreditRequestCountArgs>(
      args?: Subset<T, CreditRequestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditRequestAggregateArgs>(args: Subset<T, CreditRequestAggregateArgs>): PrismaPromise<GetCreditRequestAggregateType<T>>

    /**
     * Group by CreditRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditRequestGroupByArgs['orderBy'] }
        : { orderBy?: CreditRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditRequestGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreditRequestClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>;

    creditConfiguration<T extends CreditConfigurationArgs = {}>(args?: Subset<T, CreditConfigurationArgs>): CheckSelect<T, Prisma__CreditConfigurationClient<CreditConfiguration | null >, Prisma__CreditConfigurationClient<CreditConfigurationGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CreditRequest findUnique
   */
  export type CreditRequestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CreditRequest
     * 
    **/
    select?: CreditRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditRequestInclude | null
    /**
     * Throw an Error if a CreditRequest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreditRequest to fetch.
     * 
    **/
    where: CreditRequestWhereUniqueInput
  }


  /**
   * CreditRequest findFirst
   */
  export type CreditRequestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CreditRequest
     * 
    **/
    select?: CreditRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditRequestInclude | null
    /**
     * Throw an Error if a CreditRequest can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreditRequest to fetch.
     * 
    **/
    where?: CreditRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditRequests.
     * 
    **/
    cursor?: CreditRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditRequests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditRequests.
     * 
    **/
    distinct?: Enumerable<CreditRequestScalarFieldEnum>
  }


  /**
   * CreditRequest findMany
   */
  export type CreditRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the CreditRequest
     * 
    **/
    select?: CreditRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditRequestInclude | null
    /**
     * Filter, which CreditRequests to fetch.
     * 
    **/
    where?: CreditRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditRequests to fetch.
     * 
    **/
    orderBy?: Enumerable<CreditRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditRequests.
     * 
    **/
    cursor?: CreditRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditRequests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditRequests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CreditRequestScalarFieldEnum>
  }


  /**
   * CreditRequest create
   */
  export type CreditRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the CreditRequest
     * 
    **/
    select?: CreditRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditRequestInclude | null
    /**
     * The data needed to create a CreditRequest.
     * 
    **/
    data: XOR<CreditRequestCreateInput, CreditRequestUncheckedCreateInput>
  }


  /**
   * CreditRequest createMany
   */
  export type CreditRequestCreateManyArgs = {
    /**
     * The data used to create many CreditRequests.
     * 
    **/
    data: Enumerable<CreditRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CreditRequest update
   */
  export type CreditRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the CreditRequest
     * 
    **/
    select?: CreditRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditRequestInclude | null
    /**
     * The data needed to update a CreditRequest.
     * 
    **/
    data: XOR<CreditRequestUpdateInput, CreditRequestUncheckedUpdateInput>
    /**
     * Choose, which CreditRequest to update.
     * 
    **/
    where: CreditRequestWhereUniqueInput
  }


  /**
   * CreditRequest updateMany
   */
  export type CreditRequestUpdateManyArgs = {
    /**
     * The data used to update CreditRequests.
     * 
    **/
    data: XOR<CreditRequestUpdateManyMutationInput, CreditRequestUncheckedUpdateManyInput>
    /**
     * Filter which CreditRequests to update
     * 
    **/
    where?: CreditRequestWhereInput
  }


  /**
   * CreditRequest upsert
   */
  export type CreditRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the CreditRequest
     * 
    **/
    select?: CreditRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditRequestInclude | null
    /**
     * The filter to search for the CreditRequest to update in case it exists.
     * 
    **/
    where: CreditRequestWhereUniqueInput
    /**
     * In case the CreditRequest found by the `where` argument doesn't exist, create a new CreditRequest with this data.
     * 
    **/
    create: XOR<CreditRequestCreateInput, CreditRequestUncheckedCreateInput>
    /**
     * In case the CreditRequest was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CreditRequestUpdateInput, CreditRequestUncheckedUpdateInput>
  }


  /**
   * CreditRequest delete
   */
  export type CreditRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the CreditRequest
     * 
    **/
    select?: CreditRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditRequestInclude | null
    /**
     * Filter which CreditRequest to delete.
     * 
    **/
    where: CreditRequestWhereUniqueInput
  }


  /**
   * CreditRequest deleteMany
   */
  export type CreditRequestDeleteManyArgs = {
    /**
     * Filter which CreditRequests to delete
     * 
    **/
    where?: CreditRequestWhereInput
  }


  /**
   * CreditRequest without action
   */
  export type CreditRequestArgs = {
    /**
     * Select specific fields to fetch from the CreditRequest
     * 
    **/
    select?: CreditRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CreditRequestInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    userPhoto: 'userPhoto',
    phoneNumber: 'phoneNumber',
    countryCode: 'countryCode',
    documentId: 'documentId',
    url: 'url',
    email: 'email',
    pin: 'pin',
    deviceToken: 'deviceToken',
    createdAt: 'createdAt',
    verified: 'verified',
    expoPushToken: 'expoPushToken',
    inviterId: 'inviterId',
    faceIdImage: 'faceIdImage',
    documentCountry: 'documentCountry',
    documentData: 'documentData',
    documentFirstName: 'documentFirstName',
    documentLastName: 'documentLastName',
    documentImage: 'documentImage',
    documentGender: 'documentGender',
    documentDateOfBirth: 'documentDateOfBirth',
    documentDateOfIssue: 'documentDateOfIssue',
    documentSerialNumber: 'documentSerialNumber',
    documentCreatedAt: 'documentCreatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UsersWalletsScalarFieldEnum: {
    userId: 'userId',
    walletId: 'walletId',
    role: 'role'
  };

  export type UsersWalletsScalarFieldEnum = (typeof UsersWalletsScalarFieldEnum)[keyof typeof UsersWalletsScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    customerId: 'customerId',
    vendorId: 'vendorId'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    supplierId: 'supplierId',
    vendorId: 'vendorId'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    account: 'account',
    active: 'active',
    createdAt: 'createdAt',
    type: 'type',
    count: 'count',
    level: 'level'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const BlacklistScalarFieldEnum: {
    id: 'id',
    taxId: 'taxId',
    documentId: 'documentId',
    phoneNumber: 'phoneNumber',
    createdAt: 'createdAt'
  };

  export type BlacklistScalarFieldEnum = (typeof BlacklistScalarFieldEnum)[keyof typeof BlacklistScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    type: 'type',
    balance: 'balance',
    account: 'account',
    createdAt: 'createdAt',
    currency: 'currency',
    settlementAutomatic: 'settlementAutomatic',
    settlementDefaultId: 'settlementDefaultId',
    verificationStartedAt: 'verificationStartedAt',
    shippingId: 'shippingId',
    picture: 'picture'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const TrustScalarFieldEnum: {
    account: 'account',
    trustRating: 'trustRating',
    score: 'score',
    createdAt: 'createdAt'
  };

  export type TrustScalarFieldEnum = (typeof TrustScalarFieldEnum)[keyof typeof TrustScalarFieldEnum]


  export const MetaDataScalarFieldEnum: {
    walletAccount: 'walletAccount',
    CRB: 'CRB',
    taxId: 'taxId',
    taxName: 'taxName',
    seller: 'seller',
    sellerPhase: 'sellerPhase',
    buyerPhase: 'buyerPhase',
    partnerRole: 'partnerRole',
    documentCOI: 'documentCOI',
    documentCR12: 'documentCR12',
    documentSCF: 'documentSCF',
    documentSCA: 'documentSCA',
    documentStore: 'documentStore',
    documentKRAcert: 'documentKRAcert',
    legalStatus: 'legalStatus',
    metaBaseURL: 'metaBaseURL',
    buyer: 'buyer',
    maxBuyerOrderAmount: 'maxBuyerOrderAmount'
  };

  export type MetaDataScalarFieldEnum = (typeof MetaDataScalarFieldEnum)[keyof typeof MetaDataScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    fee: 'fee',
    totalAmount: 'totalAmount',
    description: 'description',
    paymentType: 'paymentType',
    paymentTypeId: 'paymentTypeId',
    currency: 'currency',
    transactionType: 'transactionType',
    method: 'method',
    walletId: 'walletId',
    createdAt: 'createdAt',
    name: 'name',
    balanceAfter: 'balanceAfter',
    balanceBefore: 'balanceBefore'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    quantity: 'quantity',
    vendorName: 'vendorName',
    vendorType: 'vendorType',
    name: 'name',
    price: 'price',
    unitPrice: 'unitPrice',
    listedPublic: 'listedPublic',
    description: 'description',
    gallery: 'gallery',
    categories: 'categories',
    createdAt: 'createdAt',
    currency: 'currency',
    ecommercePlatform: 'ecommercePlatform',
    platformId: 'platformId',
    affiliateId: 'affiliateId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vendorId: 'vendorId',
    status: 'status',
    notes: 'notes',
    name: 'name',
    phoneNumber: 'phoneNumber',
    affiliateId: 'affiliateId',
    products: 'products',
    items: 'items',
    deliveryCode: 'deliveryCode',
    createdAt: 'createdAt',
    paymentStatus: 'paymentStatus',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    billingId: 'billingId',
    shippingId: 'shippingId',
    ecommercePlatform: 'ecommercePlatform',
    currency: 'currency',
    platformId: 'platformId',
    customerId: 'customerId',
    referenceNumber: 'referenceNumber'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const BillingScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    company: 'company',
    address1: 'address1',
    address2: 'address2',
    city: 'city',
    state: 'state',
    postcode: 'postcode',
    country: 'country',
    email: 'email',
    phoneNumber: 'phoneNumber',
    walletId: 'walletId'
  };

  export type BillingScalarFieldEnum = (typeof BillingScalarFieldEnum)[keyof typeof BillingScalarFieldEnum]


  export const BuyerContactsScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    name: 'name',
    phoneNumber: 'phoneNumber',
    createdAt: 'createdAt'
  };

  export type BuyerContactsScalarFieldEnum = (typeof BuyerContactsScalarFieldEnum)[keyof typeof BuyerContactsScalarFieldEnum]


  export const ShippingScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    company: 'company',
    address1: 'address1',
    address2: 'address2',
    city: 'city',
    state: 'state',
    postcode: 'postcode',
    country: 'country',
    email: 'email',
    longitude: 'longitude',
    shippingType: 'shippingType',
    shippingFee: 'shippingFee',
    latitude: 'latitude',
    phoneNumber: 'phoneNumber',
    walletId: 'walletId',
    isDefault: 'isDefault',
    seviVerified: 'seviVerified',
    createdAt: 'createdAt'
  };

  export type ShippingScalarFieldEnum = (typeof ShippingScalarFieldEnum)[keyof typeof ShippingScalarFieldEnum]


  export const CreditScalarFieldEnum: {
    id: 'id',
    typeId: 'typeId',
    currency: 'currency',
    orderId: 'orderId',
    type: 'type',
    amount: 'amount',
    debtorId: 'debtorId',
    creditorId: 'creditorId',
    installmentsCount: 'installmentsCount',
    installmentsCountPaid: 'installmentsCountPaid',
    status: 'status',
    description: 'description',
    totalPaid: 'totalPaid',
    totalToPay: 'totalToPay',
    agreedDate: 'agreedDate',
    userId: 'userId',
    createdAt: 'createdAt',
    referenceNumber: 'referenceNumber',
    creditConfigurationId: 'creditConfigurationId',
    endDate: 'endDate',
    paidAt: 'paidAt',
    duration: 'duration',
    durationSlices: 'durationSlices',
    affiliateId: 'affiliateId',
    defaultAt: 'defaultAt',
    fundUpfrontAmount: 'fundUpfrontAmount',
    orderWalletId: 'orderWalletId',
    fundFeesAmount: 'fundFeesAmount',
    amountWithFees: 'amountWithFees',
    seviFeesAmount: 'seviFeesAmount',
    orderWalletShareFeesAmount: 'orderWalletShareFeesAmount',
    fundPostDeliveryAmount: 'fundPostDeliveryAmount'
  };

  export type CreditScalarFieldEnum = (typeof CreditScalarFieldEnum)[keyof typeof CreditScalarFieldEnum]


  export const InstallmentScalarFieldEnum: {
    id: 'id',
    installmentCount: 'installmentCount',
    startDate: 'startDate',
    endDate: 'endDate',
    referenceNumber: 'referenceNumber',
    amount: 'amount',
    paidAmount: 'paidAmount',
    debtorId: 'debtorId',
    creditorId: 'creditorId',
    orderId: 'orderId',
    status: 'status',
    firstTryFailedAt: 'firstTryFailedAt',
    creditId: 'creditId',
    createdAt: 'createdAt',
    userId: 'userId',
    amountWithPenalty: 'amountWithPenalty',
    seviFees: 'seviFees',
    penalty: 'penalty',
    paidAt: 'paidAt',
    creditConfigurationId: 'creditConfigurationId',
    affiliateFees: 'affiliateFees',
    currency: 'currency'
  };

  export type InstallmentScalarFieldEnum = (typeof InstallmentScalarFieldEnum)[keyof typeof InstallmentScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    entityId: 'entityId',
    entityType: 'entityType',
    priority: 'priority',
    phoneNumber: 'phoneNumber',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    entity: 'entity',
    userId: 'userId'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    messageId: 'messageId',
    installmentSlices: 'installmentSlices',
    SMS: 'SMS',
    description: 'description',
    pushNotificationTitle: 'pushNotificationTitle',
    pushNotificationBody: 'pushNotificationBody',
    email: 'email',
    language: 'language'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const VerifyScalarFieldEnum: {
    id: 'id',
    UID: 'UID',
    phoneNumber: 'phoneNumber',
    countryCode: 'countryCode',
    createdAt: 'createdAt',
    creditConfigId: 'creditConfigId',
    OTP: 'OTP',
    email: 'email',
    userId: 'userId',
    orderPaymentMethod: 'orderPaymentMethod'
  };

  export type VerifyScalarFieldEnum = (typeof VerifyScalarFieldEnum)[keyof typeof VerifyScalarFieldEnum]


  export const LoginScalarFieldEnum: {
    id: 'id',
    qrKey: 'qrKey',
    jwt: 'jwt',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LoginScalarFieldEnum = (typeof LoginScalarFieldEnum)[keyof typeof LoginScalarFieldEnum]


  export const VisitScalarFieldEnum: {
    id: 'id',
    account: 'account',
    createdAt: 'createdAt',
    visitedBy: 'visitedBy',
    visitedByReference: 'visitedByReference',
    whenVisitTookPlace: 'whenVisitTookPlace'
  };

  export type VisitScalarFieldEnum = (typeof VisitScalarFieldEnum)[keyof typeof VisitScalarFieldEnum]


  export const ReferenceNumberScalarFieldEnum: {
    id: 'id',
    prefix: 'prefix',
    lastReference: 'lastReference'
  };

  export type ReferenceNumberScalarFieldEnum = (typeof ReferenceNumberScalarFieldEnum)[keyof typeof ReferenceNumberScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    status: 'status',
    version: 'version',
    createdAt: 'createdAt',
    name: 'name'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const CreditConfigurationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shouldPayDeposit: 'shouldPayDeposit',
    depositPercentage: 'depositPercentage',
    duration: 'duration',
    slices: 'slices',
    seviFeesPercentage: 'seviFeesPercentage',
    daysToStartAfterDelivery: 'daysToStartAfterDelivery',
    lateInstallmentFeesPercentage: 'lateInstallmentFeesPercentage',
    affiliatePercentage: 'affiliatePercentage',
    creditLateFeesPercentage: 'creditLateFeesPercentage',
    creditLateDays: 'creditLateDays',
    createdAt: 'createdAt',
    status: 'status',
    numberOfAllowedCredits: 'numberOfAllowedCredits',
    fundFeesPercentage: 'fundFeesPercentage',
    fundId: 'fundId'
  };

  export type CreditConfigurationScalarFieldEnum = (typeof CreditConfigurationScalarFieldEnum)[keyof typeof CreditConfigurationScalarFieldEnum]


  export const CreditConfigurationsWalletsScalarFieldEnum: {
    configurationId: 'configurationId',
    walletId: 'walletId',
    upfrontPercentage: 'upfrontPercentage',
    fundFeesPercentage: 'fundFeesPercentage',
    maxOrderAmount: 'maxOrderAmount',
    maxOutstandingCredit: 'maxOutstandingCredit',
    shareFeesPercentage: 'shareFeesPercentage',
    postDeliveryPercentage: 'postDeliveryPercentage'
  };

  export type CreditConfigurationsWalletsScalarFieldEnum = (typeof CreditConfigurationsWalletsScalarFieldEnum)[keyof typeof CreditConfigurationsWalletsScalarFieldEnum]


  export const OtherMemberKYCScalarFieldEnum: {
    id: 'id',
    name: 'name',
    documentId: 'documentId',
    documentCountry: 'documentCountry',
    documentData: 'documentData',
    documentFirstName: 'documentFirstName',
    documentLastName: 'documentLastName',
    documentImage: 'documentImage',
    documentGender: 'documentGender',
    documentDateOfBirth: 'documentDateOfBirth',
    documentDateOfIssue: 'documentDateOfIssue',
    documentSerialNumber: 'documentSerialNumber',
    documentCreatedAt: 'documentCreatedAt',
    profilePictureURL: 'profilePictureURL',
    idCardURL: 'idCardURL',
    createdAt: 'createdAt',
    createdByUserId: 'createdByUserId',
    userIdToKYC: 'userIdToKYC',
    OTP: 'OTP'
  };

  export type OtherMemberKYCScalarFieldEnum = (typeof OtherMemberKYCScalarFieldEnum)[keyof typeof OtherMemberKYCScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    woocommerceUrl: 'woocommerceUrl',
    woocommerceConsumerKey: 'woocommerceConsumerKey',
    woocommerceActive: 'woocommerceActive',
    woocommerceConsumerSecret: 'woocommerceConsumerSecret',
    walletAccount: 'walletAccount'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const SettlementScalarFieldEnum: {
    id: 'id',
    type: 'type',
    account: 'account',
    bankAccount: 'bankAccount',
    bankAccountName: 'bankAccountName',
    bankBranch: 'bankBranch',
    bankName: 'bankName',
    phoneNumber: 'phoneNumber',
    tillNumber: 'tillNumber',
    paybillNumber: 'paybillNumber',
    verified: 'verified',
    verifiedByUser: 'verifiedByUser',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    createdByAgent: 'createdByAgent'
  };

  export type SettlementScalarFieldEnum = (typeof SettlementScalarFieldEnum)[keyof typeof SettlementScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    answersType: 'answersType',
    category: 'category',
    question: 'question',
    isActive: 'isActive',
    description: 'description'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const AnswerScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    createdAt: 'createdAt',
    answer: 'answer',
    answeredBy: 'answeredBy',
    answeredByReference: 'answeredByReference',
    account: 'account'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const CreditRequestScalarFieldEnum: {
    id: 'id',
    status: 'status',
    orderId: 'orderId',
    wallet: 'wallet',
    creditConfigurationId: 'creditConfigurationId',
    userId: 'userId',
    createdAt: 'createdAt',
    proceedAt: 'proceedAt'
  };

  export type CreditRequestScalarFieldEnum = (typeof CreditRequestScalarFieldEnum)[keyof typeof CreditRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull'
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull',
    AnyNull: 'AnyNull'
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    userPhoto?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    countryCode?: EnumCountryCodeNullableFilter | CountryCode | null
    documentId?: StringNullableFilter | string | null
    url?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    pin?: StringNullableFilter | string | null
    deviceToken?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    verified?: BoolFilter | boolean
    expoPushToken?: StringNullableFilter | string | null
    inviterId?: StringNullableFilter | string | null
    faceIdImage?: StringNullableFilter | string | null
    documentCountry?: EnumCountryCodeNullableFilter | CountryCode | null
    documentData?: JsonNullableFilter
    documentFirstName?: StringNullableFilter | string | null
    documentLastName?: StringNullableFilter | string | null
    documentImage?: StringNullableFilter | string | null
    documentGender?: EnumGenderEnumNullableFilter | GenderEnum | null
    documentDateOfBirth?: DateTimeNullableFilter | Date | string | null
    documentDateOfIssue?: DateTimeNullableFilter | Date | string | null
    documentSerialNumber?: StringNullableFilter | string | null
    documentCreatedAt?: DateTimeNullableFilter | Date | string | null
    activity?: ActivityListRelationFilter
    answers?: AnswerListRelationFilter
    creditsAffilate?: CreditListRelationFilter
    credits?: CreditListRelationFilter
    installment?: InstallmentListRelationFilter
    login?: LoginListRelationFilter
    ordersAffiliate?: OrderListRelationFilter
    orders?: OrderListRelationFilter
    otherMemberKYC?: OtherMemberKYCListRelationFilter
    product?: ProductListRelationFilter
    settlement?: SettlementListRelationFilter
    usersWallets?: UsersWalletsListRelationFilter
    verify?: VerifyListRelationFilter
    visit?: VisitListRelationFilter
    wallets?: WalletListRelationFilter
    Settlement?: SettlementListRelationFilter
    creditRequests?: XOR<CreditRequestRelationFilter, CreditRequestWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userPhoto?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    documentId?: SortOrder
    url?: SortOrder
    email?: SortOrder
    pin?: SortOrder
    deviceToken?: SortOrder
    createdAt?: SortOrder
    verified?: SortOrder
    expoPushToken?: SortOrder
    inviterId?: SortOrder
    faceIdImage?: SortOrder
    documentCountry?: SortOrder
    documentData?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
    activity?: ActivityOrderByRelationAggregateInput
    answers?: AnswerOrderByRelationAggregateInput
    creditsAffilate?: CreditOrderByRelationAggregateInput
    credits?: CreditOrderByRelationAggregateInput
    installment?: InstallmentOrderByRelationAggregateInput
    login?: LoginOrderByRelationAggregateInput
    ordersAffiliate?: OrderOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    otherMemberKYC?: OtherMemberKYCOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
    settlement?: SettlementOrderByRelationAggregateInput
    usersWallets?: UsersWalletsOrderByRelationAggregateInput
    verify?: VerifyOrderByRelationAggregateInput
    visit?: VisitOrderByRelationAggregateInput
    wallets?: WalletOrderByRelationAggregateInput
    Settlement?: SettlementOrderByRelationAggregateInput
    creditRequests?: CreditRequestOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    phoneNumber?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    userPhoto?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    documentId?: SortOrder
    url?: SortOrder
    email?: SortOrder
    pin?: SortOrder
    deviceToken?: SortOrder
    createdAt?: SortOrder
    verified?: SortOrder
    expoPushToken?: SortOrder
    inviterId?: SortOrder
    faceIdImage?: SortOrder
    documentCountry?: SortOrder
    documentData?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    userPhoto?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    countryCode?: EnumCountryCodeNullableWithAggregatesFilter | CountryCode | null
    documentId?: StringNullableWithAggregatesFilter | string | null
    url?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    pin?: StringNullableWithAggregatesFilter | string | null
    deviceToken?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    verified?: BoolWithAggregatesFilter | boolean
    expoPushToken?: StringNullableWithAggregatesFilter | string | null
    inviterId?: StringNullableWithAggregatesFilter | string | null
    faceIdImage?: StringNullableWithAggregatesFilter | string | null
    documentCountry?: EnumCountryCodeNullableWithAggregatesFilter | CountryCode | null
    documentData?: JsonNullableWithAggregatesFilter
    documentFirstName?: StringNullableWithAggregatesFilter | string | null
    documentLastName?: StringNullableWithAggregatesFilter | string | null
    documentImage?: StringNullableWithAggregatesFilter | string | null
    documentGender?: EnumGenderEnumNullableWithAggregatesFilter | GenderEnum | null
    documentDateOfBirth?: DateTimeNullableWithAggregatesFilter | Date | string | null
    documentDateOfIssue?: DateTimeNullableWithAggregatesFilter | Date | string | null
    documentSerialNumber?: StringNullableWithAggregatesFilter | string | null
    documentCreatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UsersWalletsWhereInput = {
    AND?: Enumerable<UsersWalletsWhereInput>
    OR?: Enumerable<UsersWalletsWhereInput>
    NOT?: Enumerable<UsersWalletsWhereInput>
    userId?: StringFilter | string
    walletId?: StringFilter | string
    role?: EnumWalletRoleFilter | WalletRole
    user?: XOR<UserRelationFilter, UserWhereInput>
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
  }

  export type UsersWalletsOrderByWithRelationInput = {
    userId?: SortOrder
    walletId?: SortOrder
    role?: SortOrder
    user?: UserOrderByWithRelationInput
    wallet?: WalletOrderByWithRelationInput
  }

  export type UsersWalletsWhereUniqueInput = {
    walletId_userId?: UsersWalletsWalletIdUserIdCompoundUniqueInput
  }

  export type UsersWalletsOrderByWithAggregationInput = {
    userId?: SortOrder
    walletId?: SortOrder
    role?: SortOrder
    _count?: UsersWalletsCountOrderByAggregateInput
    _max?: UsersWalletsMaxOrderByAggregateInput
    _min?: UsersWalletsMinOrderByAggregateInput
  }

  export type UsersWalletsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsersWalletsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsersWalletsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsersWalletsScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    walletId?: StringWithAggregatesFilter | string
    role?: EnumWalletRoleWithAggregatesFilter | WalletRole
  }

  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    customerId?: StringFilter | string
    vendorId?: StringFilter | string
    customer?: XOR<WalletRelationFilter, WalletWhereInput>
    vendor?: XOR<WalletRelationFilter, WalletWhereInput>
  }

  export type CustomerOrderByWithRelationInput = {
    customerId?: SortOrder
    vendorId?: SortOrder
    customer?: WalletOrderByWithRelationInput
    vendor?: WalletOrderByWithRelationInput
  }

  export type CustomerWhereUniqueInput = {
    customerId_vendorId?: CustomerCustomerIdVendorIdCompoundUniqueInput
  }

  export type CustomerOrderByWithAggregationInput = {
    customerId?: SortOrder
    vendorId?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    customerId?: StringWithAggregatesFilter | string
    vendorId?: StringWithAggregatesFilter | string
  }

  export type SupplierWhereInput = {
    AND?: Enumerable<SupplierWhereInput>
    OR?: Enumerable<SupplierWhereInput>
    NOT?: Enumerable<SupplierWhereInput>
    supplierId?: StringFilter | string
    vendorId?: StringFilter | string
    supplier?: XOR<WalletRelationFilter, WalletWhereInput>
    vendor?: XOR<WalletRelationFilter, WalletWhereInput>
  }

  export type SupplierOrderByWithRelationInput = {
    supplierId?: SortOrder
    vendorId?: SortOrder
    supplier?: WalletOrderByWithRelationInput
    vendor?: WalletOrderByWithRelationInput
  }

  export type SupplierWhereUniqueInput = {
    supplierId_vendorId?: SupplierSupplierIdVendorIdCompoundUniqueInput
  }

  export type SupplierOrderByWithAggregationInput = {
    supplierId?: SortOrder
    vendorId?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SupplierScalarWhereWithAggregatesInput>
    OR?: Enumerable<SupplierScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SupplierScalarWhereWithAggregatesInput>
    supplierId?: StringWithAggregatesFilter | string
    vendorId?: StringWithAggregatesFilter | string
  }

  export type BadgeWhereInput = {
    AND?: Enumerable<BadgeWhereInput>
    OR?: Enumerable<BadgeWhereInput>
    NOT?: Enumerable<BadgeWhereInput>
    id?: StringFilter | string
    account?: StringFilter | string
    active?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    type?: EnumBadgeTypeNullableFilter | BadgeType | null
    count?: IntNullableFilter | number | null
    level?: IntNullableFilter | number | null
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    account?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    count?: SortOrder
    level?: SortOrder
    wallet?: WalletOrderByWithRelationInput
  }

  export type BadgeWhereUniqueInput = {
    id?: string
  }

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    account?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    count?: SortOrder
    level?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BadgeScalarWhereWithAggregatesInput>
    OR?: Enumerable<BadgeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BadgeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    account?: StringWithAggregatesFilter | string
    active?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    type?: EnumBadgeTypeNullableWithAggregatesFilter | BadgeType | null
    count?: IntNullableWithAggregatesFilter | number | null
    level?: IntNullableWithAggregatesFilter | number | null
  }

  export type BlacklistWhereInput = {
    AND?: Enumerable<BlacklistWhereInput>
    OR?: Enumerable<BlacklistWhereInput>
    NOT?: Enumerable<BlacklistWhereInput>
    id?: StringFilter | string
    taxId?: StringNullableFilter | string | null
    documentId?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BlacklistOrderByWithRelationInput = {
    id?: SortOrder
    taxId?: SortOrder
    documentId?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistWhereUniqueInput = {
    id?: string
  }

  export type BlacklistOrderByWithAggregationInput = {
    id?: SortOrder
    taxId?: SortOrder
    documentId?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    _count?: BlacklistCountOrderByAggregateInput
    _max?: BlacklistMaxOrderByAggregateInput
    _min?: BlacklistMinOrderByAggregateInput
  }

  export type BlacklistScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BlacklistScalarWhereWithAggregatesInput>
    OR?: Enumerable<BlacklistScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BlacklistScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    taxId?: StringNullableWithAggregatesFilter | string | null
    documentId?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type WalletWhereInput = {
    AND?: Enumerable<WalletWhereInput>
    OR?: Enumerable<WalletWhereInput>
    NOT?: Enumerable<WalletWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    category?: StringNullableFilter | string | null
    type?: EnumWalletTypesEnumFilter | WalletTypesEnum
    balance?: FloatFilter | number
    account?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    settlementAutomatic?: BoolNullableFilter | boolean | null
    settlementDefaultId?: StringNullableFilter | string | null
    verificationStartedAt?: DateTimeNullableFilter | Date | string | null
    shippingId?: StringNullableFilter | string | null
    picture?: StringNullableFilter | string | null
    settlementDefault?: XOR<SettlementRelationFilter, SettlementWhereInput> | null
    answers?: AnswerListRelationFilter
    badges?: BadgeListRelationFilter
    billing?: BillingListRelationFilter
    creditorCredit?: CreditListRelationFilter
    debtorCredit?: CreditListRelationFilter
    creditConfigurations?: CreditConfigurationListRelationFilter
    customer?: CustomerListRelationFilter
    vendor?: CustomerListRelationFilter
    creditorInstallments?: InstallmentListRelationFilter
    debtorInstallments?: InstallmentListRelationFilter
    metaData?: XOR<MetaDataRelationFilter, MetaDataWhereInput> | null
    order?: OrderListRelationFilter
    orders?: OrderListRelationFilter
    product?: ProductListRelationFilter
    settings?: XOR<SettingsRelationFilter, SettingsWhereInput> | null
    settlement?: SettlementListRelationFilter
    shipping?: ShippingListRelationFilter
    supplier?: SupplierListRelationFilter
    vendorSupplier?: SupplierListRelationFilter
    transaction?: TransactionListRelationFilter
    usersWallets?: UsersWalletsListRelationFilter
    visit?: VisitListRelationFilter
    users?: UserListRelationFilter
    trust?: XOR<TrustRelationFilter, TrustWhereInput> | null
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    settlementAutomatic?: SortOrder
    settlementDefaultId?: SortOrder
    verificationStartedAt?: SortOrder
    shippingId?: SortOrder
    picture?: SortOrder
    settlementDefault?: SettlementOrderByWithRelationInput
    answers?: AnswerOrderByRelationAggregateInput
    badges?: BadgeOrderByRelationAggregateInput
    billing?: BillingOrderByRelationAggregateInput
    creditorCredit?: CreditOrderByRelationAggregateInput
    debtorCredit?: CreditOrderByRelationAggregateInput
    creditConfigurations?: CreditConfigurationOrderByRelationAggregateInput
    customer?: CustomerOrderByRelationAggregateInput
    vendor?: CustomerOrderByRelationAggregateInput
    creditorInstallments?: InstallmentOrderByRelationAggregateInput
    debtorInstallments?: InstallmentOrderByRelationAggregateInput
    metaData?: MetaDataOrderByWithRelationInput
    order?: OrderOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
    settings?: SettingsOrderByWithRelationInput
    settlement?: SettlementOrderByRelationAggregateInput
    shipping?: ShippingOrderByRelationAggregateInput
    supplier?: SupplierOrderByRelationAggregateInput
    vendorSupplier?: SupplierOrderByRelationAggregateInput
    transaction?: TransactionOrderByRelationAggregateInput
    usersWallets?: UsersWalletsOrderByRelationAggregateInput
    visit?: VisitOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    trust?: TrustOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = {
    id?: string
    account?: string
    settlementDefaultId?: string
  }

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    settlementAutomatic?: SortOrder
    settlementDefaultId?: SortOrder
    verificationStartedAt?: SortOrder
    shippingId?: SortOrder
    picture?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WalletScalarWhereWithAggregatesInput>
    OR?: Enumerable<WalletScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WalletScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    category?: StringNullableWithAggregatesFilter | string | null
    type?: EnumWalletTypesEnumWithAggregatesFilter | WalletTypesEnum
    balance?: FloatWithAggregatesFilter | number
    account?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    currency?: EnumCurrencyEnumNullableWithAggregatesFilter | CurrencyEnum | null
    settlementAutomatic?: BoolNullableWithAggregatesFilter | boolean | null
    settlementDefaultId?: StringNullableWithAggregatesFilter | string | null
    verificationStartedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    shippingId?: StringNullableWithAggregatesFilter | string | null
    picture?: StringNullableWithAggregatesFilter | string | null
  }

  export type TrustWhereInput = {
    AND?: Enumerable<TrustWhereInput>
    OR?: Enumerable<TrustWhereInput>
    NOT?: Enumerable<TrustWhereInput>
    account?: StringFilter | string
    trustRating?: FloatNullableFilter | number | null
    score?: FloatNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    Wallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
  }

  export type TrustOrderByWithRelationInput = {
    account?: SortOrder
    trustRating?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    Wallet?: WalletOrderByWithRelationInput
  }

  export type TrustWhereUniqueInput = {
    account?: string
  }

  export type TrustOrderByWithAggregationInput = {
    account?: SortOrder
    trustRating?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    _count?: TrustCountOrderByAggregateInput
    _avg?: TrustAvgOrderByAggregateInput
    _max?: TrustMaxOrderByAggregateInput
    _min?: TrustMinOrderByAggregateInput
    _sum?: TrustSumOrderByAggregateInput
  }

  export type TrustScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TrustScalarWhereWithAggregatesInput>
    OR?: Enumerable<TrustScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TrustScalarWhereWithAggregatesInput>
    account?: StringWithAggregatesFilter | string
    trustRating?: FloatNullableWithAggregatesFilter | number | null
    score?: FloatNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MetaDataWhereInput = {
    AND?: Enumerable<MetaDataWhereInput>
    OR?: Enumerable<MetaDataWhereInput>
    NOT?: Enumerable<MetaDataWhereInput>
    walletAccount?: StringFilter | string
    CRB?: JsonNullableFilter
    taxId?: StringNullableFilter | string | null
    taxName?: StringNullableFilter | string | null
    seller?: BoolNullableFilter | boolean | null
    sellerPhase?: EnumphaseEnumNullableFilter | phaseEnum | null
    buyerPhase?: EnumphaseEnumNullableFilter | phaseEnum | null
    partnerRole?: EnumpartnerRoleEnumNullableFilter | partnerRoleEnum | null
    documentCOI?: StringNullableFilter | string | null
    documentCR12?: StringNullableFilter | string | null
    documentSCF?: StringNullableFilter | string | null
    documentSCA?: StringNullableFilter | string | null
    documentStore?: StringNullableFilter | string | null
    documentKRAcert?: StringNullableFilter | string | null
    legalStatus?: EnumlegalStatusEnumNullableFilter | legalStatusEnum | null
    metaBaseURL?: JsonNullableFilter
    buyer?: BoolNullableFilter | boolean | null
    maxBuyerOrderAmount?: FloatNullableFilter | number | null
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
  }

  export type MetaDataOrderByWithRelationInput = {
    walletAccount?: SortOrder
    CRB?: SortOrder
    taxId?: SortOrder
    taxName?: SortOrder
    seller?: SortOrder
    sellerPhase?: SortOrder
    buyerPhase?: SortOrder
    partnerRole?: SortOrder
    documentCOI?: SortOrder
    documentCR12?: SortOrder
    documentSCF?: SortOrder
    documentSCA?: SortOrder
    documentStore?: SortOrder
    documentKRAcert?: SortOrder
    legalStatus?: SortOrder
    metaBaseURL?: SortOrder
    buyer?: SortOrder
    maxBuyerOrderAmount?: SortOrder
    wallet?: WalletOrderByWithRelationInput
  }

  export type MetaDataWhereUniqueInput = {
    walletAccount?: string
  }

  export type MetaDataOrderByWithAggregationInput = {
    walletAccount?: SortOrder
    CRB?: SortOrder
    taxId?: SortOrder
    taxName?: SortOrder
    seller?: SortOrder
    sellerPhase?: SortOrder
    buyerPhase?: SortOrder
    partnerRole?: SortOrder
    documentCOI?: SortOrder
    documentCR12?: SortOrder
    documentSCF?: SortOrder
    documentSCA?: SortOrder
    documentStore?: SortOrder
    documentKRAcert?: SortOrder
    legalStatus?: SortOrder
    metaBaseURL?: SortOrder
    buyer?: SortOrder
    maxBuyerOrderAmount?: SortOrder
    _count?: MetaDataCountOrderByAggregateInput
    _avg?: MetaDataAvgOrderByAggregateInput
    _max?: MetaDataMaxOrderByAggregateInput
    _min?: MetaDataMinOrderByAggregateInput
    _sum?: MetaDataSumOrderByAggregateInput
  }

  export type MetaDataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MetaDataScalarWhereWithAggregatesInput>
    OR?: Enumerable<MetaDataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MetaDataScalarWhereWithAggregatesInput>
    walletAccount?: StringWithAggregatesFilter | string
    CRB?: JsonNullableWithAggregatesFilter
    taxId?: StringNullableWithAggregatesFilter | string | null
    taxName?: StringNullableWithAggregatesFilter | string | null
    seller?: BoolNullableWithAggregatesFilter | boolean | null
    sellerPhase?: EnumphaseEnumNullableWithAggregatesFilter | phaseEnum | null
    buyerPhase?: EnumphaseEnumNullableWithAggregatesFilter | phaseEnum | null
    partnerRole?: EnumpartnerRoleEnumNullableWithAggregatesFilter | partnerRoleEnum | null
    documentCOI?: StringNullableWithAggregatesFilter | string | null
    documentCR12?: StringNullableWithAggregatesFilter | string | null
    documentSCF?: StringNullableWithAggregatesFilter | string | null
    documentSCA?: StringNullableWithAggregatesFilter | string | null
    documentStore?: StringNullableWithAggregatesFilter | string | null
    documentKRAcert?: StringNullableWithAggregatesFilter | string | null
    legalStatus?: EnumlegalStatusEnumNullableWithAggregatesFilter | legalStatusEnum | null
    metaBaseURL?: JsonNullableWithAggregatesFilter
    buyer?: BoolNullableWithAggregatesFilter | boolean | null
    maxBuyerOrderAmount?: FloatNullableWithAggregatesFilter | number | null
  }

  export type TransactionWhereInput = {
    AND?: Enumerable<TransactionWhereInput>
    OR?: Enumerable<TransactionWhereInput>
    NOT?: Enumerable<TransactionWhereInput>
    id?: StringFilter | string
    amount?: FloatFilter | number
    fee?: FloatFilter | number
    totalAmount?: FloatFilter | number
    description?: StringNullableFilter | string | null
    paymentType?: EnumPaymentTypesEnumFilter | PaymentTypesEnum
    paymentTypeId?: StringNullableFilter | string | null
    currency?: EnumCurrencyEnumFilter | CurrencyEnum
    transactionType?: EnumTransactionTypeEnumNullableFilter | TransactionTypeEnum | null
    method?: EnumTransactionMethodEnumNullableFilter | TransactionMethodEnum | null
    walletId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
    balanceAfter?: FloatNullableFilter | number | null
    balanceBefore?: FloatNullableFilter | number | null
    wallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    totalAmount?: SortOrder
    description?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    method?: SortOrder
    walletId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    balanceAfter?: SortOrder
    balanceBefore?: SortOrder
    wallet?: WalletOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = {
    id?: string
  }

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    totalAmount?: SortOrder
    description?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    method?: SortOrder
    walletId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    balanceAfter?: SortOrder
    balanceBefore?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    amount?: FloatWithAggregatesFilter | number
    fee?: FloatWithAggregatesFilter | number
    totalAmount?: FloatWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    paymentType?: EnumPaymentTypesEnumWithAggregatesFilter | PaymentTypesEnum
    paymentTypeId?: StringNullableWithAggregatesFilter | string | null
    currency?: EnumCurrencyEnumWithAggregatesFilter | CurrencyEnum
    transactionType?: EnumTransactionTypeEnumNullableWithAggregatesFilter | TransactionTypeEnum | null
    method?: EnumTransactionMethodEnumNullableWithAggregatesFilter | TransactionMethodEnum | null
    walletId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringNullableWithAggregatesFilter | string | null
    balanceAfter?: FloatNullableWithAggregatesFilter | number | null
    balanceBefore?: FloatNullableWithAggregatesFilter | number | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    vendorId?: StringNullableFilter | string | null
    quantity?: IntNullableFilter | number | null
    vendorName?: StringNullableFilter | string | null
    vendorType?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    price?: FloatNullableFilter | number | null
    unitPrice?: FloatNullableFilter | number | null
    listedPublic?: BoolNullableFilter | boolean | null
    description?: StringNullableFilter | string | null
    gallery?: JsonNullableFilter
    categories?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    ecommercePlatform?: EnumEcommercePlatformEnumNullableFilter | EcommercePlatformEnum | null
    platformId?: StringNullableFilter | string | null
    affiliateId?: StringNullableFilter | string | null
    affiliate?: XOR<UserRelationFilter, UserWhereInput> | null
    vendorWallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    quantity?: SortOrder
    vendorName?: SortOrder
    vendorType?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
    listedPublic?: SortOrder
    description?: SortOrder
    gallery?: SortOrder
    categories?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    ecommercePlatform?: SortOrder
    platformId?: SortOrder
    affiliateId?: SortOrder
    affiliate?: UserOrderByWithRelationInput
    vendorWallet?: WalletOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    quantity?: SortOrder
    vendorName?: SortOrder
    vendorType?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
    listedPublic?: SortOrder
    description?: SortOrder
    gallery?: SortOrder
    categories?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    ecommercePlatform?: SortOrder
    platformId?: SortOrder
    affiliateId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    vendorId?: StringNullableWithAggregatesFilter | string | null
    quantity?: IntNullableWithAggregatesFilter | number | null
    vendorName?: StringNullableWithAggregatesFilter | string | null
    vendorType?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    price?: FloatNullableWithAggregatesFilter | number | null
    unitPrice?: FloatNullableWithAggregatesFilter | number | null
    listedPublic?: BoolNullableWithAggregatesFilter | boolean | null
    description?: StringNullableWithAggregatesFilter | string | null
    gallery?: JsonNullableWithAggregatesFilter
    categories?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    currency?: EnumCurrencyEnumNullableWithAggregatesFilter | CurrencyEnum | null
    ecommercePlatform?: EnumEcommercePlatformEnumNullableWithAggregatesFilter | EcommercePlatformEnum | null
    platformId?: StringNullableWithAggregatesFilter | string | null
    affiliateId?: StringNullableWithAggregatesFilter | string | null
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vendorId?: StringNullableFilter | string | null
    status?: EnumOrderStatusEnumNullableFilter | OrderStatusEnum | null
    notes?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    affiliateId?: StringNullableFilter | string | null
    products?: JsonNullableFilter
    items?: JsonNullableFilter
    deliveryCode?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    paymentStatus?: EnumPaymentStatusEnumFilter | PaymentStatusEnum
    amount?: FloatFilter | number
    paymentMethod?: EnumOrderPaymentMethodsEnumNullableFilter | OrderPaymentMethodsEnum | null
    billingId?: StringNullableFilter | string | null
    shippingId?: StringNullableFilter | string | null
    ecommercePlatform?: EnumEcommercePlatformEnumNullableFilter | EcommercePlatformEnum | null
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    platformId?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    referenceNumber?: StringNullableFilter | string | null
    affiliate?: XOR<UserRelationFilter, UserWhereInput> | null
    billing?: XOR<BillingRelationFilter, BillingWhereInput> | null
    customer?: XOR<WalletRelationFilter, WalletWhereInput> | null
    shipping?: XOR<ShippingRelationFilter, ShippingWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    vendorWallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
    credit?: XOR<CreditRelationFilter, CreditWhereInput> | null
    installments?: InstallmentListRelationFilter
    creditRequest?: XOR<CreditRequestRelationFilter, CreditRequestWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    affiliateId?: SortOrder
    products?: SortOrder
    items?: SortOrder
    deliveryCode?: SortOrder
    createdAt?: SortOrder
    paymentStatus?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    billingId?: SortOrder
    shippingId?: SortOrder
    ecommercePlatform?: SortOrder
    currency?: SortOrder
    platformId?: SortOrder
    customerId?: SortOrder
    referenceNumber?: SortOrder
    affiliate?: UserOrderByWithRelationInput
    billing?: BillingOrderByWithRelationInput
    customer?: WalletOrderByWithRelationInput
    shipping?: ShippingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    vendorWallet?: WalletOrderByWithRelationInput
    credit?: CreditOrderByWithRelationInput
    installments?: InstallmentOrderByRelationAggregateInput
    creditRequest?: CreditRequestOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = {
    id?: string
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    affiliateId?: SortOrder
    products?: SortOrder
    items?: SortOrder
    deliveryCode?: SortOrder
    createdAt?: SortOrder
    paymentStatus?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    billingId?: SortOrder
    shippingId?: SortOrder
    ecommercePlatform?: SortOrder
    currency?: SortOrder
    platformId?: SortOrder
    customerId?: SortOrder
    referenceNumber?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    vendorId?: StringNullableWithAggregatesFilter | string | null
    status?: EnumOrderStatusEnumNullableWithAggregatesFilter | OrderStatusEnum | null
    notes?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    affiliateId?: StringNullableWithAggregatesFilter | string | null
    products?: JsonNullableWithAggregatesFilter
    items?: JsonNullableWithAggregatesFilter
    deliveryCode?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    paymentStatus?: EnumPaymentStatusEnumWithAggregatesFilter | PaymentStatusEnum
    amount?: FloatWithAggregatesFilter | number
    paymentMethod?: EnumOrderPaymentMethodsEnumNullableWithAggregatesFilter | OrderPaymentMethodsEnum | null
    billingId?: StringNullableWithAggregatesFilter | string | null
    shippingId?: StringNullableWithAggregatesFilter | string | null
    ecommercePlatform?: EnumEcommercePlatformEnumNullableWithAggregatesFilter | EcommercePlatformEnum | null
    currency?: EnumCurrencyEnumNullableWithAggregatesFilter | CurrencyEnum | null
    platformId?: StringNullableWithAggregatesFilter | string | null
    customerId?: StringNullableWithAggregatesFilter | string | null
    referenceNumber?: StringNullableWithAggregatesFilter | string | null
  }

  export type BillingWhereInput = {
    AND?: Enumerable<BillingWhereInput>
    OR?: Enumerable<BillingWhereInput>
    NOT?: Enumerable<BillingWhereInput>
    id?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    company?: StringNullableFilter | string | null
    address1?: StringNullableFilter | string | null
    address2?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    postcode?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    walletId?: StringNullableFilter | string | null
    wallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
    order?: OrderListRelationFilter
  }

  export type BillingOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    order?: OrderOrderByRelationAggregateInput
  }

  export type BillingWhereUniqueInput = {
    id?: string
  }

  export type BillingOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
    _count?: BillingCountOrderByAggregateInput
    _max?: BillingMaxOrderByAggregateInput
    _min?: BillingMinOrderByAggregateInput
  }

  export type BillingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BillingScalarWhereWithAggregatesInput>
    OR?: Enumerable<BillingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BillingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    company?: StringNullableWithAggregatesFilter | string | null
    address1?: StringNullableWithAggregatesFilter | string | null
    address2?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
    postcode?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    walletId?: StringNullableWithAggregatesFilter | string | null
  }

  export type BuyerContactsWhereInput = {
    AND?: Enumerable<BuyerContactsWhereInput>
    OR?: Enumerable<BuyerContactsWhereInput>
    NOT?: Enumerable<BuyerContactsWhereInput>
    id?: StringFilter | string
    walletId?: StringFilter | string
    name?: StringFilter | string
    phoneNumber?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type BuyerContactsOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type BuyerContactsWhereUniqueInput = {
    id?: string
  }

  export type BuyerContactsOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
    _count?: BuyerContactsCountOrderByAggregateInput
    _max?: BuyerContactsMaxOrderByAggregateInput
    _min?: BuyerContactsMinOrderByAggregateInput
  }

  export type BuyerContactsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BuyerContactsScalarWhereWithAggregatesInput>
    OR?: Enumerable<BuyerContactsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BuyerContactsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    walletId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    phoneNumber?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ShippingWhereInput = {
    AND?: Enumerable<ShippingWhereInput>
    OR?: Enumerable<ShippingWhereInput>
    NOT?: Enumerable<ShippingWhereInput>
    id?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    company?: StringNullableFilter | string | null
    address1?: StringNullableFilter | string | null
    address2?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    postcode?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    longitude?: StringNullableFilter | string | null
    shippingType?: EnumShippingTypeEnumNullableFilter | ShippingTypeEnum | null
    shippingFee?: FloatNullableFilter | number | null
    latitude?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    walletId?: StringNullableFilter | string | null
    isDefault?: BoolNullableFilter | boolean | null
    seviVerified?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    wallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
    Order?: OrderListRelationFilter
  }

  export type ShippingOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    longitude?: SortOrder
    shippingType?: SortOrder
    shippingFee?: SortOrder
    latitude?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
    isDefault?: SortOrder
    seviVerified?: SortOrder
    createdAt?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    Order?: OrderOrderByRelationAggregateInput
  }

  export type ShippingWhereUniqueInput = {
    id?: string
  }

  export type ShippingOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    longitude?: SortOrder
    shippingType?: SortOrder
    shippingFee?: SortOrder
    latitude?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
    isDefault?: SortOrder
    seviVerified?: SortOrder
    createdAt?: SortOrder
    _count?: ShippingCountOrderByAggregateInput
    _avg?: ShippingAvgOrderByAggregateInput
    _max?: ShippingMaxOrderByAggregateInput
    _min?: ShippingMinOrderByAggregateInput
    _sum?: ShippingSumOrderByAggregateInput
  }

  export type ShippingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShippingScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShippingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShippingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    company?: StringNullableWithAggregatesFilter | string | null
    address1?: StringNullableWithAggregatesFilter | string | null
    address2?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
    postcode?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    longitude?: StringNullableWithAggregatesFilter | string | null
    shippingType?: EnumShippingTypeEnumNullableWithAggregatesFilter | ShippingTypeEnum | null
    shippingFee?: FloatNullableWithAggregatesFilter | number | null
    latitude?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    walletId?: StringNullableWithAggregatesFilter | string | null
    isDefault?: BoolNullableWithAggregatesFilter | boolean | null
    seviVerified?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CreditWhereInput = {
    AND?: Enumerable<CreditWhereInput>
    OR?: Enumerable<CreditWhereInput>
    NOT?: Enumerable<CreditWhereInput>
    id?: StringFilter | string
    typeId?: StringNullableFilter | string | null
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    orderId?: StringNullableFilter | string | null
    type?: EnumcreditRefTypeNullableFilter | creditRefType | null
    amount?: FloatNullableFilter | number | null
    debtorId?: StringNullableFilter | string | null
    creditorId?: StringNullableFilter | string | null
    installmentsCount?: IntNullableFilter | number | null
    installmentsCountPaid?: IntNullableFilter | number | null
    status?: EnumcreditStatusEnumNullableFilter | creditStatusEnum | null
    description?: StringNullableFilter | string | null
    totalPaid?: FloatNullableFilter | number | null
    totalToPay?: FloatNullableFilter | number | null
    agreedDate?: DateTimeNullableFilter | Date | string | null
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    referenceNumber?: StringFilter | string
    creditConfigurationId?: StringFilter | string
    endDate?: DateTimeNullableFilter | Date | string | null
    paidAt?: DateTimeNullableFilter | Date | string | null
    duration?: IntNullableFilter | number | null
    durationSlices?: EnumSlicesEnumFilter | SlicesEnum
    affiliateId?: StringNullableFilter | string | null
    defaultAt?: DateTimeNullableFilter | Date | string | null
    fundUpfrontAmount?: FloatNullableFilter | number | null
    orderWalletId?: StringNullableFilter | string | null
    fundFeesAmount?: FloatNullableFilter | number | null
    amountWithFees?: FloatNullableFilter | number | null
    seviFeesAmount?: FloatNullableFilter | number | null
    orderWalletShareFeesAmount?: FloatNullableFilter | number | null
    fundPostDeliveryAmount?: FloatNullableFilter | number | null
    affiliate?: XOR<UserRelationFilter, UserWhereInput> | null
    creditConfiguration?: XOR<CreditConfigurationRelationFilter, CreditConfigurationWhereInput>
    creditor?: XOR<WalletRelationFilter, WalletWhereInput> | null
    debtor?: XOR<WalletRelationFilter, WalletWhereInput> | null
    order?: XOR<OrderRelationFilter, OrderWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    installments?: InstallmentListRelationFilter
  }

  export type CreditOrderByWithRelationInput = {
    id?: SortOrder
    typeId?: SortOrder
    currency?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    installmentsCount?: SortOrder
    installmentsCountPaid?: SortOrder
    status?: SortOrder
    description?: SortOrder
    totalPaid?: SortOrder
    totalToPay?: SortOrder
    agreedDate?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    referenceNumber?: SortOrder
    creditConfigurationId?: SortOrder
    endDate?: SortOrder
    paidAt?: SortOrder
    duration?: SortOrder
    durationSlices?: SortOrder
    affiliateId?: SortOrder
    defaultAt?: SortOrder
    fundUpfrontAmount?: SortOrder
    orderWalletId?: SortOrder
    fundFeesAmount?: SortOrder
    amountWithFees?: SortOrder
    seviFeesAmount?: SortOrder
    orderWalletShareFeesAmount?: SortOrder
    fundPostDeliveryAmount?: SortOrder
    affiliate?: UserOrderByWithRelationInput
    creditConfiguration?: CreditConfigurationOrderByWithRelationInput
    creditor?: WalletOrderByWithRelationInput
    debtor?: WalletOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    installments?: InstallmentOrderByRelationAggregateInput
  }

  export type CreditWhereUniqueInput = {
    id?: string
    orderId?: string
    referenceNumber?: string
  }

  export type CreditOrderByWithAggregationInput = {
    id?: SortOrder
    typeId?: SortOrder
    currency?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    installmentsCount?: SortOrder
    installmentsCountPaid?: SortOrder
    status?: SortOrder
    description?: SortOrder
    totalPaid?: SortOrder
    totalToPay?: SortOrder
    agreedDate?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    referenceNumber?: SortOrder
    creditConfigurationId?: SortOrder
    endDate?: SortOrder
    paidAt?: SortOrder
    duration?: SortOrder
    durationSlices?: SortOrder
    affiliateId?: SortOrder
    defaultAt?: SortOrder
    fundUpfrontAmount?: SortOrder
    orderWalletId?: SortOrder
    fundFeesAmount?: SortOrder
    amountWithFees?: SortOrder
    seviFeesAmount?: SortOrder
    orderWalletShareFeesAmount?: SortOrder
    fundPostDeliveryAmount?: SortOrder
    _count?: CreditCountOrderByAggregateInput
    _avg?: CreditAvgOrderByAggregateInput
    _max?: CreditMaxOrderByAggregateInput
    _min?: CreditMinOrderByAggregateInput
    _sum?: CreditSumOrderByAggregateInput
  }

  export type CreditScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreditScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreditScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreditScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    typeId?: StringNullableWithAggregatesFilter | string | null
    currency?: EnumCurrencyEnumNullableWithAggregatesFilter | CurrencyEnum | null
    orderId?: StringNullableWithAggregatesFilter | string | null
    type?: EnumcreditRefTypeNullableWithAggregatesFilter | creditRefType | null
    amount?: FloatNullableWithAggregatesFilter | number | null
    debtorId?: StringNullableWithAggregatesFilter | string | null
    creditorId?: StringNullableWithAggregatesFilter | string | null
    installmentsCount?: IntNullableWithAggregatesFilter | number | null
    installmentsCountPaid?: IntNullableWithAggregatesFilter | number | null
    status?: EnumcreditStatusEnumNullableWithAggregatesFilter | creditStatusEnum | null
    description?: StringNullableWithAggregatesFilter | string | null
    totalPaid?: FloatNullableWithAggregatesFilter | number | null
    totalToPay?: FloatNullableWithAggregatesFilter | number | null
    agreedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    referenceNumber?: StringWithAggregatesFilter | string
    creditConfigurationId?: StringWithAggregatesFilter | string
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    duration?: IntNullableWithAggregatesFilter | number | null
    durationSlices?: EnumSlicesEnumWithAggregatesFilter | SlicesEnum
    affiliateId?: StringNullableWithAggregatesFilter | string | null
    defaultAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    fundUpfrontAmount?: FloatNullableWithAggregatesFilter | number | null
    orderWalletId?: StringNullableWithAggregatesFilter | string | null
    fundFeesAmount?: FloatNullableWithAggregatesFilter | number | null
    amountWithFees?: FloatNullableWithAggregatesFilter | number | null
    seviFeesAmount?: FloatNullableWithAggregatesFilter | number | null
    orderWalletShareFeesAmount?: FloatNullableWithAggregatesFilter | number | null
    fundPostDeliveryAmount?: FloatNullableWithAggregatesFilter | number | null
  }

  export type InstallmentWhereInput = {
    AND?: Enumerable<InstallmentWhereInput>
    OR?: Enumerable<InstallmentWhereInput>
    NOT?: Enumerable<InstallmentWhereInput>
    id?: StringFilter | string
    installmentCount?: IntNullableFilter | number | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    referenceNumber?: StringNullableFilter | string | null
    amount?: FloatFilter | number
    paidAmount?: FloatFilter | number
    debtorId?: StringNullableFilter | string | null
    creditorId?: StringNullableFilter | string | null
    orderId?: StringNullableFilter | string | null
    status?: EnuminstallmentStatusTypeEnumNullableFilter | installmentStatusTypeEnum | null
    firstTryFailedAt?: DateTimeNullableFilter | Date | string | null
    creditId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    userId?: StringNullableFilter | string | null
    amountWithPenalty?: FloatFilter | number
    seviFees?: FloatFilter | number
    penalty?: FloatFilter | number
    paidAt?: DateTimeNullableFilter | Date | string | null
    creditConfigurationId?: StringFilter | string
    affiliateFees?: FloatFilter | number
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    creditConfiguration?: XOR<CreditConfigurationRelationFilter, CreditConfigurationWhereInput>
    credit?: XOR<CreditRelationFilter, CreditWhereInput> | null
    creditor?: XOR<WalletRelationFilter, WalletWhereInput> | null
    debtor?: XOR<WalletRelationFilter, WalletWhereInput> | null
    order?: XOR<OrderRelationFilter, OrderWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type InstallmentOrderByWithRelationInput = {
    id?: SortOrder
    installmentCount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    referenceNumber?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    firstTryFailedAt?: SortOrder
    creditId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    amountWithPenalty?: SortOrder
    seviFees?: SortOrder
    penalty?: SortOrder
    paidAt?: SortOrder
    creditConfigurationId?: SortOrder
    affiliateFees?: SortOrder
    currency?: SortOrder
    creditConfiguration?: CreditConfigurationOrderByWithRelationInput
    credit?: CreditOrderByWithRelationInput
    creditor?: WalletOrderByWithRelationInput
    debtor?: WalletOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InstallmentWhereUniqueInput = {
    id?: string
  }

  export type InstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    installmentCount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    referenceNumber?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    firstTryFailedAt?: SortOrder
    creditId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    amountWithPenalty?: SortOrder
    seviFees?: SortOrder
    penalty?: SortOrder
    paidAt?: SortOrder
    creditConfigurationId?: SortOrder
    affiliateFees?: SortOrder
    currency?: SortOrder
    _count?: InstallmentCountOrderByAggregateInput
    _avg?: InstallmentAvgOrderByAggregateInput
    _max?: InstallmentMaxOrderByAggregateInput
    _min?: InstallmentMinOrderByAggregateInput
    _sum?: InstallmentSumOrderByAggregateInput
  }

  export type InstallmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InstallmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<InstallmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InstallmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    installmentCount?: IntNullableWithAggregatesFilter | number | null
    startDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    referenceNumber?: StringNullableWithAggregatesFilter | string | null
    amount?: FloatWithAggregatesFilter | number
    paidAmount?: FloatWithAggregatesFilter | number
    debtorId?: StringNullableWithAggregatesFilter | string | null
    creditorId?: StringNullableWithAggregatesFilter | string | null
    orderId?: StringNullableWithAggregatesFilter | string | null
    status?: EnuminstallmentStatusTypeEnumNullableWithAggregatesFilter | installmentStatusTypeEnum | null
    firstTryFailedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    creditId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringNullableWithAggregatesFilter | string | null
    amountWithPenalty?: FloatWithAggregatesFilter | number
    seviFees?: FloatWithAggregatesFilter | number
    penalty?: FloatWithAggregatesFilter | number
    paidAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    creditConfigurationId?: StringWithAggregatesFilter | string
    affiliateFees?: FloatWithAggregatesFilter | number
    currency?: EnumCurrencyEnumNullableWithAggregatesFilter | CurrencyEnum | null
  }

  export type ActivityWhereInput = {
    AND?: Enumerable<ActivityWhereInput>
    OR?: Enumerable<ActivityWhereInput>
    NOT?: Enumerable<ActivityWhereInput>
    id?: StringFilter | string
    entityId?: StringNullableFilter | string | null
    entityType?: EnumActivityEntityTypeNullableFilter | ActivityEntityType | null
    priority?: EnumActivityPriorityNullableFilter | ActivityPriority | null
    phoneNumber?: StringNullableFilter | string | null
    message?: JsonNullableFilter
    isRead?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    entity?: JsonNullableFilter
    userId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    priority?: SortOrder
    phoneNumber?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    entity?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = {
    id?: string
  }

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    priority?: SortOrder
    phoneNumber?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    entity?: SortOrder
    userId?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    entityId?: StringNullableWithAggregatesFilter | string | null
    entityType?: EnumActivityEntityTypeNullableWithAggregatesFilter | ActivityEntityType | null
    priority?: EnumActivityPriorityNullableWithAggregatesFilter | ActivityPriority | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    message?: JsonNullableWithAggregatesFilter
    isRead?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    entity?: JsonNullableWithAggregatesFilter
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    messageId?: StringFilter | string
    installmentSlices?: EnumSlicesEnumNullableListFilter
    SMS?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    pushNotificationTitle?: StringNullableFilter | string | null
    pushNotificationBody?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    language?: EnumlanguageFilter | language
  }

  export type MessageOrderByWithRelationInput = {
    messageId?: SortOrder
    installmentSlices?: SortOrder
    SMS?: SortOrder
    description?: SortOrder
    pushNotificationTitle?: SortOrder
    pushNotificationBody?: SortOrder
    email?: SortOrder
    language?: SortOrder
  }

  export type MessageWhereUniqueInput = {
    messageId_language?: MessageMessageIdLanguageCompoundUniqueInput
  }

  export type MessageOrderByWithAggregationInput = {
    messageId?: SortOrder
    installmentSlices?: SortOrder
    SMS?: SortOrder
    description?: SortOrder
    pushNotificationTitle?: SortOrder
    pushNotificationBody?: SortOrder
    email?: SortOrder
    language?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    messageId?: StringWithAggregatesFilter | string
    installmentSlices?: EnumSlicesEnumNullableListFilter
    SMS?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    pushNotificationTitle?: StringNullableWithAggregatesFilter | string | null
    pushNotificationBody?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    language?: EnumlanguageWithAggregatesFilter | language
  }

  export type VerifyWhereInput = {
    AND?: Enumerable<VerifyWhereInput>
    OR?: Enumerable<VerifyWhereInput>
    NOT?: Enumerable<VerifyWhereInput>
    id?: StringFilter | string
    UID?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    countryCode?: EnumCountryCodeNullableFilter | CountryCode | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    creditConfigId?: StringNullableFilter | string | null
    OTP?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    orderPaymentMethod?: EnumOrderPaymentMethodsEnumNullableFilter | OrderPaymentMethodsEnum | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type VerifyOrderByWithRelationInput = {
    id?: SortOrder
    UID?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    creditConfigId?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    orderPaymentMethod?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VerifyWhereUniqueInput = {
    id?: string
  }

  export type VerifyOrderByWithAggregationInput = {
    id?: SortOrder
    UID?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    creditConfigId?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    orderPaymentMethod?: SortOrder
    _count?: VerifyCountOrderByAggregateInput
    _max?: VerifyMaxOrderByAggregateInput
    _min?: VerifyMinOrderByAggregateInput
  }

  export type VerifyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VerifyScalarWhereWithAggregatesInput>
    OR?: Enumerable<VerifyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VerifyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    UID?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    countryCode?: EnumCountryCodeNullableWithAggregatesFilter | CountryCode | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    creditConfigId?: StringNullableWithAggregatesFilter | string | null
    OTP?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    orderPaymentMethod?: EnumOrderPaymentMethodsEnumNullableWithAggregatesFilter | OrderPaymentMethodsEnum | null
  }

  export type LoginWhereInput = {
    AND?: Enumerable<LoginWhereInput>
    OR?: Enumerable<LoginWhereInput>
    NOT?: Enumerable<LoginWhereInput>
    id?: StringFilter | string
    qrKey?: StringNullableFilter | string | null
    jwt?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type LoginOrderByWithRelationInput = {
    id?: SortOrder
    qrKey?: SortOrder
    jwt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LoginWhereUniqueInput = {
    id?: string
  }

  export type LoginOrderByWithAggregationInput = {
    id?: SortOrder
    qrKey?: SortOrder
    jwt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: LoginCountOrderByAggregateInput
    _max?: LoginMaxOrderByAggregateInput
    _min?: LoginMinOrderByAggregateInput
  }

  export type LoginScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoginScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoginScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoginScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    qrKey?: StringNullableWithAggregatesFilter | string | null
    jwt?: StringNullableWithAggregatesFilter | string | null
    userId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VisitWhereInput = {
    AND?: Enumerable<VisitWhereInput>
    OR?: Enumerable<VisitWhereInput>
    NOT?: Enumerable<VisitWhereInput>
    id?: StringFilter | string
    account?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    visitedBy?: StringNullableFilter | string | null
    visitedByReference?: StringNullableFilter | string | null
    whenVisitTookPlace?: DateTimeNullableFilter | Date | string | null
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
    visited?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type VisitOrderByWithRelationInput = {
    id?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    visitedBy?: SortOrder
    visitedByReference?: SortOrder
    whenVisitTookPlace?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    visited?: UserOrderByWithRelationInput
  }

  export type VisitWhereUniqueInput = {
    id?: string
  }

  export type VisitOrderByWithAggregationInput = {
    id?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    visitedBy?: SortOrder
    visitedByReference?: SortOrder
    whenVisitTookPlace?: SortOrder
    _count?: VisitCountOrderByAggregateInput
    _max?: VisitMaxOrderByAggregateInput
    _min?: VisitMinOrderByAggregateInput
  }

  export type VisitScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VisitScalarWhereWithAggregatesInput>
    OR?: Enumerable<VisitScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VisitScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    account?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    visitedBy?: StringNullableWithAggregatesFilter | string | null
    visitedByReference?: StringNullableWithAggregatesFilter | string | null
    whenVisitTookPlace?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ReferenceNumberWhereInput = {
    AND?: Enumerable<ReferenceNumberWhereInput>
    OR?: Enumerable<ReferenceNumberWhereInput>
    NOT?: Enumerable<ReferenceNumberWhereInput>
    id?: StringFilter | string
    prefix?: StringFilter | string
    lastReference?: IntNullableFilter | number | null
  }

  export type ReferenceNumberOrderByWithRelationInput = {
    id?: SortOrder
    prefix?: SortOrder
    lastReference?: SortOrder
  }

  export type ReferenceNumberWhereUniqueInput = {
    id?: string
    prefix?: string
  }

  export type ReferenceNumberOrderByWithAggregationInput = {
    id?: SortOrder
    prefix?: SortOrder
    lastReference?: SortOrder
    _count?: ReferenceNumberCountOrderByAggregateInput
    _avg?: ReferenceNumberAvgOrderByAggregateInput
    _max?: ReferenceNumberMaxOrderByAggregateInput
    _min?: ReferenceNumberMinOrderByAggregateInput
    _sum?: ReferenceNumberSumOrderByAggregateInput
  }

  export type ReferenceNumberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReferenceNumberScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReferenceNumberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReferenceNumberScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    prefix?: StringWithAggregatesFilter | string
    lastReference?: IntNullableWithAggregatesFilter | number | null
  }

  export type JobWhereInput = {
    AND?: Enumerable<JobWhereInput>
    OR?: Enumerable<JobWhereInput>
    NOT?: Enumerable<JobWhereInput>
    id?: StringFilter | string
    status?: EnumJobStatusFilter | JobStatus
    version?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type JobWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    status?: EnumJobStatusWithAggregatesFilter | JobStatus
    version?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
  }

  export type CreditConfigurationWhereInput = {
    AND?: Enumerable<CreditConfigurationWhereInput>
    OR?: Enumerable<CreditConfigurationWhereInput>
    NOT?: Enumerable<CreditConfigurationWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    shouldPayDeposit?: BoolNullableFilter | boolean | null
    depositPercentage?: FloatFilter | number
    duration?: IntFilter | number
    slices?: EnumSlicesEnumFilter | SlicesEnum
    seviFeesPercentage?: FloatFilter | number
    daysToStartAfterDelivery?: IntFilter | number
    lateInstallmentFeesPercentage?: FloatFilter | number
    affiliatePercentage?: FloatFilter | number
    creditLateFeesPercentage?: FloatFilter | number
    creditLateDays?: FloatFilter | number
    createdAt?: DateTimeNullableFilter | Date | string | null
    status?: EnumCreditConfigurationStatusFilter | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFilter | number
    fundFeesPercentage?: FloatNullableFilter | number | null
    fundId?: StringFilter | string
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
    credit?: CreditListRelationFilter
    attachedWallets?: CreditConfigurationsWalletsListRelationFilter
    Installment?: InstallmentListRelationFilter
    creditRequests?: XOR<CreditRequestRelationFilter, CreditRequestWhereInput> | null
  }

  export type CreditConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shouldPayDeposit?: SortOrder
    depositPercentage?: SortOrder
    duration?: SortOrder
    slices?: SortOrder
    seviFeesPercentage?: SortOrder
    daysToStartAfterDelivery?: SortOrder
    lateInstallmentFeesPercentage?: SortOrder
    affiliatePercentage?: SortOrder
    creditLateFeesPercentage?: SortOrder
    creditLateDays?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numberOfAllowedCredits?: SortOrder
    fundFeesPercentage?: SortOrder
    fundId?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    credit?: CreditOrderByRelationAggregateInput
    attachedWallets?: CreditConfigurationsWalletsOrderByRelationAggregateInput
    Installment?: InstallmentOrderByRelationAggregateInput
    creditRequests?: CreditRequestOrderByWithRelationInput
  }

  export type CreditConfigurationWhereUniqueInput = {
    id?: string
  }

  export type CreditConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shouldPayDeposit?: SortOrder
    depositPercentage?: SortOrder
    duration?: SortOrder
    slices?: SortOrder
    seviFeesPercentage?: SortOrder
    daysToStartAfterDelivery?: SortOrder
    lateInstallmentFeesPercentage?: SortOrder
    affiliatePercentage?: SortOrder
    creditLateFeesPercentage?: SortOrder
    creditLateDays?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numberOfAllowedCredits?: SortOrder
    fundFeesPercentage?: SortOrder
    fundId?: SortOrder
    _count?: CreditConfigurationCountOrderByAggregateInput
    _avg?: CreditConfigurationAvgOrderByAggregateInput
    _max?: CreditConfigurationMaxOrderByAggregateInput
    _min?: CreditConfigurationMinOrderByAggregateInput
    _sum?: CreditConfigurationSumOrderByAggregateInput
  }

  export type CreditConfigurationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreditConfigurationScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreditConfigurationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreditConfigurationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    shouldPayDeposit?: BoolNullableWithAggregatesFilter | boolean | null
    depositPercentage?: FloatWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    slices?: EnumSlicesEnumWithAggregatesFilter | SlicesEnum
    seviFeesPercentage?: FloatWithAggregatesFilter | number
    daysToStartAfterDelivery?: IntWithAggregatesFilter | number
    lateInstallmentFeesPercentage?: FloatWithAggregatesFilter | number
    affiliatePercentage?: FloatWithAggregatesFilter | number
    creditLateFeesPercentage?: FloatWithAggregatesFilter | number
    creditLateDays?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: EnumCreditConfigurationStatusWithAggregatesFilter | CreditConfigurationStatus
    numberOfAllowedCredits?: IntWithAggregatesFilter | number
    fundFeesPercentage?: FloatNullableWithAggregatesFilter | number | null
    fundId?: StringWithAggregatesFilter | string
  }

  export type CreditConfigurationsWalletsWhereInput = {
    AND?: Enumerable<CreditConfigurationsWalletsWhereInput>
    OR?: Enumerable<CreditConfigurationsWalletsWhereInput>
    NOT?: Enumerable<CreditConfigurationsWalletsWhereInput>
    configurationId?: StringFilter | string
    walletId?: StringFilter | string
    upfrontPercentage?: FloatFilter | number
    fundFeesPercentage?: FloatFilter | number
    maxOrderAmount?: FloatFilter | number
    maxOutstandingCredit?: FloatFilter | number
    shareFeesPercentage?: FloatFilter | number
    postDeliveryPercentage?: FloatFilter | number
    configuration?: XOR<CreditConfigurationRelationFilter, CreditConfigurationWhereInput>
  }

  export type CreditConfigurationsWalletsOrderByWithRelationInput = {
    configurationId?: SortOrder
    walletId?: SortOrder
    upfrontPercentage?: SortOrder
    fundFeesPercentage?: SortOrder
    maxOrderAmount?: SortOrder
    maxOutstandingCredit?: SortOrder
    shareFeesPercentage?: SortOrder
    postDeliveryPercentage?: SortOrder
    configuration?: CreditConfigurationOrderByWithRelationInput
  }

  export type CreditConfigurationsWalletsWhereUniqueInput = {
    walletId_configurationId?: CreditConfigurationsWalletsWalletIdConfigurationIdCompoundUniqueInput
  }

  export type CreditConfigurationsWalletsOrderByWithAggregationInput = {
    configurationId?: SortOrder
    walletId?: SortOrder
    upfrontPercentage?: SortOrder
    fundFeesPercentage?: SortOrder
    maxOrderAmount?: SortOrder
    maxOutstandingCredit?: SortOrder
    shareFeesPercentage?: SortOrder
    postDeliveryPercentage?: SortOrder
    _count?: CreditConfigurationsWalletsCountOrderByAggregateInput
    _avg?: CreditConfigurationsWalletsAvgOrderByAggregateInput
    _max?: CreditConfigurationsWalletsMaxOrderByAggregateInput
    _min?: CreditConfigurationsWalletsMinOrderByAggregateInput
    _sum?: CreditConfigurationsWalletsSumOrderByAggregateInput
  }

  export type CreditConfigurationsWalletsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreditConfigurationsWalletsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreditConfigurationsWalletsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreditConfigurationsWalletsScalarWhereWithAggregatesInput>
    configurationId?: StringWithAggregatesFilter | string
    walletId?: StringWithAggregatesFilter | string
    upfrontPercentage?: FloatWithAggregatesFilter | number
    fundFeesPercentage?: FloatWithAggregatesFilter | number
    maxOrderAmount?: FloatWithAggregatesFilter | number
    maxOutstandingCredit?: FloatWithAggregatesFilter | number
    shareFeesPercentage?: FloatWithAggregatesFilter | number
    postDeliveryPercentage?: FloatWithAggregatesFilter | number
  }

  export type OtherMemberKYCWhereInput = {
    AND?: Enumerable<OtherMemberKYCWhereInput>
    OR?: Enumerable<OtherMemberKYCWhereInput>
    NOT?: Enumerable<OtherMemberKYCWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    documentId?: StringFilter | string
    documentCountry?: EnumCountryCodeNullableFilter | CountryCode | null
    documentData?: JsonNullableFilter
    documentFirstName?: StringNullableFilter | string | null
    documentLastName?: StringNullableFilter | string | null
    documentImage?: StringNullableFilter | string | null
    documentGender?: EnumGenderEnumNullableFilter | GenderEnum | null
    documentDateOfBirth?: DateTimeNullableFilter | Date | string | null
    documentDateOfIssue?: DateTimeNullableFilter | Date | string | null
    documentSerialNumber?: StringNullableFilter | string | null
    documentCreatedAt?: DateTimeNullableFilter | Date | string | null
    profilePictureURL?: StringFilter | string
    idCardURL?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdByUserId?: StringFilter | string
    userIdToKYC?: StringFilter | string
    OTP?: StringFilter | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OtherMemberKYCOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    documentId?: SortOrder
    documentCountry?: SortOrder
    documentData?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
    profilePictureURL?: SortOrder
    idCardURL?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
    userIdToKYC?: SortOrder
    OTP?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type OtherMemberKYCWhereUniqueInput = {
    id?: string
  }

  export type OtherMemberKYCOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    documentId?: SortOrder
    documentCountry?: SortOrder
    documentData?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
    profilePictureURL?: SortOrder
    idCardURL?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
    userIdToKYC?: SortOrder
    OTP?: SortOrder
    _count?: OtherMemberKYCCountOrderByAggregateInput
    _max?: OtherMemberKYCMaxOrderByAggregateInput
    _min?: OtherMemberKYCMinOrderByAggregateInput
  }

  export type OtherMemberKYCScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OtherMemberKYCScalarWhereWithAggregatesInput>
    OR?: Enumerable<OtherMemberKYCScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OtherMemberKYCScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    documentId?: StringWithAggregatesFilter | string
    documentCountry?: EnumCountryCodeNullableWithAggregatesFilter | CountryCode | null
    documentData?: JsonNullableWithAggregatesFilter
    documentFirstName?: StringNullableWithAggregatesFilter | string | null
    documentLastName?: StringNullableWithAggregatesFilter | string | null
    documentImage?: StringNullableWithAggregatesFilter | string | null
    documentGender?: EnumGenderEnumNullableWithAggregatesFilter | GenderEnum | null
    documentDateOfBirth?: DateTimeNullableWithAggregatesFilter | Date | string | null
    documentDateOfIssue?: DateTimeNullableWithAggregatesFilter | Date | string | null
    documentSerialNumber?: StringNullableWithAggregatesFilter | string | null
    documentCreatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    profilePictureURL?: StringWithAggregatesFilter | string
    idCardURL?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdByUserId?: StringWithAggregatesFilter | string
    userIdToKYC?: StringWithAggregatesFilter | string
    OTP?: StringWithAggregatesFilter | string
  }

  export type SettingsWhereInput = {
    AND?: Enumerable<SettingsWhereInput>
    OR?: Enumerable<SettingsWhereInput>
    NOT?: Enumerable<SettingsWhereInput>
    woocommerceUrl?: StringNullableFilter | string | null
    woocommerceConsumerKey?: StringNullableFilter | string | null
    woocommerceActive?: BoolNullableFilter | boolean | null
    woocommerceConsumerSecret?: StringNullableFilter | string | null
    walletAccount?: StringFilter | string
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
  }

  export type SettingsOrderByWithRelationInput = {
    woocommerceUrl?: SortOrder
    woocommerceConsumerKey?: SortOrder
    woocommerceActive?: SortOrder
    woocommerceConsumerSecret?: SortOrder
    walletAccount?: SortOrder
    wallet?: WalletOrderByWithRelationInput
  }

  export type SettingsWhereUniqueInput = {
    walletAccount?: string
  }

  export type SettingsOrderByWithAggregationInput = {
    woocommerceUrl?: SortOrder
    woocommerceConsumerKey?: SortOrder
    woocommerceActive?: SortOrder
    woocommerceConsumerSecret?: SortOrder
    walletAccount?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SettingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SettingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SettingsScalarWhereWithAggregatesInput>
    woocommerceUrl?: StringNullableWithAggregatesFilter | string | null
    woocommerceConsumerKey?: StringNullableWithAggregatesFilter | string | null
    woocommerceActive?: BoolNullableWithAggregatesFilter | boolean | null
    woocommerceConsumerSecret?: StringNullableWithAggregatesFilter | string | null
    walletAccount?: StringWithAggregatesFilter | string
  }

  export type SettlementWhereInput = {
    AND?: Enumerable<SettlementWhereInput>
    OR?: Enumerable<SettlementWhereInput>
    NOT?: Enumerable<SettlementWhereInput>
    id?: StringFilter | string
    type?: EnumTransactionMethodEnumFilter | TransactionMethodEnum
    account?: StringFilter | string
    bankAccount?: StringNullableFilter | string | null
    bankAccountName?: StringNullableFilter | string | null
    bankBranch?: StringNullableFilter | string | null
    bankName?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    tillNumber?: StringNullableFilter | string | null
    paybillNumber?: StringNullableFilter | string | null
    verified?: BoolNullableFilter | boolean | null
    verifiedByUser?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringFilter | string
    createdByAgent?: BoolFilter | boolean
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
    settlementCreator?: XOR<UserRelationFilter, UserWhereInput>
    settlementVerifier?: XOR<UserRelationFilter, UserWhereInput> | null
    Wallet?: WalletListRelationFilter
  }

  export type SettlementOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    account?: SortOrder
    bankAccount?: SortOrder
    bankAccountName?: SortOrder
    bankBranch?: SortOrder
    bankName?: SortOrder
    phoneNumber?: SortOrder
    tillNumber?: SortOrder
    paybillNumber?: SortOrder
    verified?: SortOrder
    verifiedByUser?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByAgent?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    settlementCreator?: UserOrderByWithRelationInput
    settlementVerifier?: UserOrderByWithRelationInput
    Wallet?: WalletOrderByRelationAggregateInput
  }

  export type SettlementWhereUniqueInput = {
    id?: string
  }

  export type SettlementOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    account?: SortOrder
    bankAccount?: SortOrder
    bankAccountName?: SortOrder
    bankBranch?: SortOrder
    bankName?: SortOrder
    phoneNumber?: SortOrder
    tillNumber?: SortOrder
    paybillNumber?: SortOrder
    verified?: SortOrder
    verifiedByUser?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByAgent?: SortOrder
    _count?: SettlementCountOrderByAggregateInput
    _max?: SettlementMaxOrderByAggregateInput
    _min?: SettlementMinOrderByAggregateInput
  }

  export type SettlementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SettlementScalarWhereWithAggregatesInput>
    OR?: Enumerable<SettlementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SettlementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumTransactionMethodEnumWithAggregatesFilter | TransactionMethodEnum
    account?: StringWithAggregatesFilter | string
    bankAccount?: StringNullableWithAggregatesFilter | string | null
    bankAccountName?: StringNullableWithAggregatesFilter | string | null
    bankBranch?: StringNullableWithAggregatesFilter | string | null
    bankName?: StringNullableWithAggregatesFilter | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    tillNumber?: StringNullableWithAggregatesFilter | string | null
    paybillNumber?: StringNullableWithAggregatesFilter | string | null
    verified?: BoolNullableWithAggregatesFilter | boolean | null
    verifiedByUser?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    createdBy?: StringWithAggregatesFilter | string
    createdByAgent?: BoolWithAggregatesFilter | boolean
  }

  export type QuestionWhereInput = {
    AND?: Enumerable<QuestionWhereInput>
    OR?: Enumerable<QuestionWhereInput>
    NOT?: Enumerable<QuestionWhereInput>
    id?: StringFilter | string
    answersType?: EnumanswerTypeEnumFilter | answerTypeEnum
    category?: EnumQuestionCategoryEnumFilter | QuestionCategoryEnum
    question?: StringFilter | string
    isActive?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    answers?: AnswerListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    answersType?: SortOrder
    category?: SortOrder
    question?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    answers?: AnswerOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = {
    id?: string
  }

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    answersType?: SortOrder
    category?: SortOrder
    question?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    answersType?: EnumanswerTypeEnumWithAggregatesFilter | answerTypeEnum
    category?: EnumQuestionCategoryEnumWithAggregatesFilter | QuestionCategoryEnum
    question?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type AnswerWhereInput = {
    AND?: Enumerable<AnswerWhereInput>
    OR?: Enumerable<AnswerWhereInput>
    NOT?: Enumerable<AnswerWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    answer?: StringFilter | string
    answeredBy?: StringNullableFilter | string | null
    answeredByReference?: StringNullableFilter | string | null
    account?: StringFilter | string
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
    answered?: XOR<UserRelationFilter, UserWhereInput> | null
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }

  export type AnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    answer?: SortOrder
    answeredBy?: SortOrder
    answeredByReference?: SortOrder
    account?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    answered?: UserOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
  }

  export type AnswerWhereUniqueInput = {
    id?: string
  }

  export type AnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    answer?: SortOrder
    answeredBy?: SortOrder
    answeredByReference?: SortOrder
    account?: SortOrder
    _count?: AnswerCountOrderByAggregateInput
    _max?: AnswerMaxOrderByAggregateInput
    _min?: AnswerMinOrderByAggregateInput
  }

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AnswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<AnswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AnswerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    questionId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    answer?: StringWithAggregatesFilter | string
    answeredBy?: StringNullableWithAggregatesFilter | string | null
    answeredByReference?: StringNullableWithAggregatesFilter | string | null
    account?: StringWithAggregatesFilter | string
  }

  export type CreditRequestWhereInput = {
    AND?: Enumerable<CreditRequestWhereInput>
    OR?: Enumerable<CreditRequestWhereInput>
    NOT?: Enumerable<CreditRequestWhereInput>
    id?: StringFilter | string
    status?: EnumCreditRequestStatusFilter | CreditRequestStatus
    orderId?: StringFilter | string
    wallet?: StringFilter | string
    creditConfigurationId?: StringFilter | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    order?: XOR<OrderRelationFilter, OrderWhereInput> | null
    creditConfiguration?: XOR<CreditConfigurationRelationFilter, CreditConfigurationWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    proceedAt?: DateTimeFilter | Date | string
  }

  export type CreditRequestOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    orderId?: SortOrder
    wallet?: SortOrder
    creditConfigurationId?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    creditConfiguration?: CreditConfigurationOrderByWithRelationInput
    createdAt?: SortOrder
    proceedAt?: SortOrder
  }

  export type CreditRequestWhereUniqueInput = {
    id?: string
    orderId?: string
    creditConfigurationId?: string
    userId?: string
    orderId_userId?: CreditRequestOrderIdUserIdCompoundUniqueInput
  }

  export type CreditRequestOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    orderId?: SortOrder
    wallet?: SortOrder
    creditConfigurationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    proceedAt?: SortOrder
    _count?: CreditRequestCountOrderByAggregateInput
    _max?: CreditRequestMaxOrderByAggregateInput
    _min?: CreditRequestMinOrderByAggregateInput
  }

  export type CreditRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CreditRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<CreditRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CreditRequestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    status?: EnumCreditRequestStatusWithAggregatesFilter | CreditRequestStatus
    orderId?: StringWithAggregatesFilter | string
    wallet?: StringWithAggregatesFilter | string
    creditConfigurationId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    proceedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersWalletsCreateInput = {
    role?: WalletRole
    user: UserCreateNestedOneWithoutUsersWalletsInput
    wallet: WalletCreateNestedOneWithoutUsersWalletsInput
  }

  export type UsersWalletsUncheckedCreateInput = {
    userId: string
    walletId: string
    role?: WalletRole
  }

  export type UsersWalletsUpdateInput = {
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
    user?: UserUpdateOneRequiredWithoutUsersWalletsInput
    wallet?: WalletUpdateOneRequiredWithoutUsersWalletsInput
  }

  export type UsersWalletsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
  }

  export type UsersWalletsCreateManyInput = {
    userId: string
    walletId: string
    role?: WalletRole
  }

  export type UsersWalletsUpdateManyMutationInput = {
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
  }

  export type UsersWalletsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
  }

  export type CustomerCreateInput = {
    customer: WalletCreateNestedOneWithoutCustomerInput
    vendor: WalletCreateNestedOneWithoutVendorInput
  }

  export type CustomerUncheckedCreateInput = {
    customerId: string
    vendorId: string
  }

  export type CustomerUpdateInput = {
    customer?: WalletUpdateOneRequiredWithoutCustomerInput
    vendor?: WalletUpdateOneRequiredWithoutVendorInput
  }

  export type CustomerUncheckedUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerCreateManyInput = {
    customerId: string
    vendorId: string
  }

  export type CustomerUpdateManyMutationInput = {

  }

  export type CustomerUncheckedUpdateManyInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierCreateInput = {
    supplier: WalletCreateNestedOneWithoutSupplierInput
    vendor: WalletCreateNestedOneWithoutVendorSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    supplierId: string
    vendorId: string
  }

  export type SupplierUpdateInput = {
    supplier?: WalletUpdateOneRequiredWithoutSupplierInput
    vendor?: WalletUpdateOneRequiredWithoutVendorSupplierInput
  }

  export type SupplierUncheckedUpdateInput = {
    supplierId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierCreateManyInput = {
    supplierId: string
    vendorId: string
  }

  export type SupplierUpdateManyMutationInput = {

  }

  export type SupplierUncheckedUpdateManyInput = {
    supplierId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
  }

  export type BadgeCreateInput = {
    id?: string
    active?: boolean | null
    createdAt?: Date | string | null
    type?: BadgeType | null
    count?: number | null
    level?: number | null
    wallet: WalletCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    account: string
    active?: boolean | null
    createdAt?: Date | string | null
    type?: BadgeType | null
    count?: number | null
    level?: number | null
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumBadgeTypeFieldUpdateOperationsInput | BadgeType | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    wallet?: WalletUpdateOneRequiredWithoutBadgesInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumBadgeTypeFieldUpdateOperationsInput | BadgeType | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BadgeCreateManyInput = {
    id?: string
    account: string
    active?: boolean | null
    createdAt?: Date | string | null
    type?: BadgeType | null
    count?: number | null
    level?: number | null
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumBadgeTypeFieldUpdateOperationsInput | BadgeType | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumBadgeTypeFieldUpdateOperationsInput | BadgeType | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlacklistCreateInput = {
    id?: string
    taxId?: string | null
    documentId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string | null
  }

  export type BlacklistUncheckedCreateInput = {
    id?: string
    taxId?: string | null
    documentId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string | null
  }

  export type BlacklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlacklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlacklistCreateManyInput = {
    id?: string
    taxId?: string | null
    documentId?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string | null
  }

  export type BlacklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlacklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletCreateInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletCreateManyInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrustCreateInput = {
    trustRating?: number | null
    score?: number | null
    createdAt?: Date | string
    Wallet?: WalletCreateNestedOneWithoutTrustInput
  }

  export type TrustUncheckedCreateInput = {
    account: string
    trustRating?: number | null
    score?: number | null
    createdAt?: Date | string
  }

  export type TrustUpdateInput = {
    trustRating?: NullableFloatFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Wallet?: WalletUpdateOneWithoutTrustInput
  }

  export type TrustUncheckedUpdateInput = {
    account?: StringFieldUpdateOperationsInput | string
    trustRating?: NullableFloatFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustCreateManyInput = {
    account: string
    trustRating?: number | null
    score?: number | null
    createdAt?: Date | string
  }

  export type TrustUpdateManyMutationInput = {
    trustRating?: NullableFloatFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustUncheckedUpdateManyInput = {
    account?: StringFieldUpdateOperationsInput | string
    trustRating?: NullableFloatFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetaDataCreateInput = {
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    taxName?: string | null
    seller?: boolean | null
    sellerPhase?: phaseEnum | null
    buyerPhase?: phaseEnum | null
    partnerRole?: partnerRoleEnum | null
    documentCOI?: string | null
    documentCR12?: string | null
    documentSCF?: string | null
    documentSCA?: string | null
    documentStore?: string | null
    documentKRAcert?: string | null
    legalStatus?: legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: boolean | null
    maxBuyerOrderAmount?: number | null
    wallet: WalletCreateNestedOneWithoutMetaDataInput
  }

  export type MetaDataUncheckedCreateInput = {
    walletAccount: string
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    taxName?: string | null
    seller?: boolean | null
    sellerPhase?: phaseEnum | null
    buyerPhase?: phaseEnum | null
    partnerRole?: partnerRoleEnum | null
    documentCOI?: string | null
    documentCR12?: string | null
    documentSCF?: string | null
    documentSCA?: string | null
    documentStore?: string | null
    documentKRAcert?: string | null
    legalStatus?: legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: boolean | null
    maxBuyerOrderAmount?: number | null
  }

  export type MetaDataUpdateInput = {
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sellerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    buyerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    partnerRole?: NullableEnumpartnerRoleEnumFieldUpdateOperationsInput | partnerRoleEnum | null
    documentCOI?: NullableStringFieldUpdateOperationsInput | string | null
    documentCR12?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCF?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCA?: NullableStringFieldUpdateOperationsInput | string | null
    documentStore?: NullableStringFieldUpdateOperationsInput | string | null
    documentKRAcert?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableEnumlegalStatusEnumFieldUpdateOperationsInput | legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    maxBuyerOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet?: WalletUpdateOneRequiredWithoutMetaDataInput
  }

  export type MetaDataUncheckedUpdateInput = {
    walletAccount?: StringFieldUpdateOperationsInput | string
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sellerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    buyerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    partnerRole?: NullableEnumpartnerRoleEnumFieldUpdateOperationsInput | partnerRoleEnum | null
    documentCOI?: NullableStringFieldUpdateOperationsInput | string | null
    documentCR12?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCF?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCA?: NullableStringFieldUpdateOperationsInput | string | null
    documentStore?: NullableStringFieldUpdateOperationsInput | string | null
    documentKRAcert?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableEnumlegalStatusEnumFieldUpdateOperationsInput | legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    maxBuyerOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MetaDataCreateManyInput = {
    walletAccount: string
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    taxName?: string | null
    seller?: boolean | null
    sellerPhase?: phaseEnum | null
    buyerPhase?: phaseEnum | null
    partnerRole?: partnerRoleEnum | null
    documentCOI?: string | null
    documentCR12?: string | null
    documentSCF?: string | null
    documentSCA?: string | null
    documentStore?: string | null
    documentKRAcert?: string | null
    legalStatus?: legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: boolean | null
    maxBuyerOrderAmount?: number | null
  }

  export type MetaDataUpdateManyMutationInput = {
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sellerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    buyerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    partnerRole?: NullableEnumpartnerRoleEnumFieldUpdateOperationsInput | partnerRoleEnum | null
    documentCOI?: NullableStringFieldUpdateOperationsInput | string | null
    documentCR12?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCF?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCA?: NullableStringFieldUpdateOperationsInput | string | null
    documentStore?: NullableStringFieldUpdateOperationsInput | string | null
    documentKRAcert?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableEnumlegalStatusEnumFieldUpdateOperationsInput | legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    maxBuyerOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MetaDataUncheckedUpdateManyInput = {
    walletAccount?: StringFieldUpdateOperationsInput | string
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sellerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    buyerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    partnerRole?: NullableEnumpartnerRoleEnumFieldUpdateOperationsInput | partnerRoleEnum | null
    documentCOI?: NullableStringFieldUpdateOperationsInput | string | null
    documentCR12?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCF?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCA?: NullableStringFieldUpdateOperationsInput | string | null
    documentStore?: NullableStringFieldUpdateOperationsInput | string | null
    documentKRAcert?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableEnumlegalStatusEnumFieldUpdateOperationsInput | legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    maxBuyerOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    fee: number
    totalAmount: number
    description?: string | null
    paymentType: PaymentTypesEnum
    paymentTypeId?: string | null
    currency?: CurrencyEnum
    transactionType?: TransactionTypeEnum | null
    method?: TransactionMethodEnum | null
    createdAt?: Date | string
    name?: string | null
    balanceAfter?: number | null
    balanceBefore?: number | null
    wallet?: WalletCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    amount: number
    fee: number
    totalAmount: number
    description?: string | null
    paymentType: PaymentTypesEnum
    paymentTypeId?: string | null
    currency?: CurrencyEnum
    transactionType?: TransactionTypeEnum | null
    method?: TransactionMethodEnum | null
    walletId?: string | null
    createdAt?: Date | string
    name?: string | null
    balanceAfter?: number | null
    balanceBefore?: number | null
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: EnumPaymentTypesEnumFieldUpdateOperationsInput | PaymentTypesEnum
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum
    transactionType?: NullableEnumTransactionTypeEnumFieldUpdateOperationsInput | TransactionTypeEnum | null
    method?: NullableEnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    balanceBefore?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet?: WalletUpdateOneWithoutTransactionInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: EnumPaymentTypesEnumFieldUpdateOperationsInput | PaymentTypesEnum
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum
    transactionType?: NullableEnumTransactionTypeEnumFieldUpdateOperationsInput | TransactionTypeEnum | null
    method?: NullableEnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    balanceBefore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionCreateManyInput = {
    id?: string
    amount: number
    fee: number
    totalAmount: number
    description?: string | null
    paymentType: PaymentTypesEnum
    paymentTypeId?: string | null
    currency?: CurrencyEnum
    transactionType?: TransactionTypeEnum | null
    method?: TransactionMethodEnum | null
    walletId?: string | null
    createdAt?: Date | string
    name?: string | null
    balanceAfter?: number | null
    balanceBefore?: number | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: EnumPaymentTypesEnumFieldUpdateOperationsInput | PaymentTypesEnum
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum
    transactionType?: NullableEnumTransactionTypeEnumFieldUpdateOperationsInput | TransactionTypeEnum | null
    method?: NullableEnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    balanceBefore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: EnumPaymentTypesEnumFieldUpdateOperationsInput | PaymentTypesEnum
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum
    transactionType?: NullableEnumTransactionTypeEnumFieldUpdateOperationsInput | TransactionTypeEnum | null
    method?: NullableEnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    balanceBefore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductCreateInput = {
    id?: string
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
    affiliate?: UserCreateNestedOneWithoutProductInput
    vendorWallet?: WalletCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    vendorId?: string | null
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
    affiliateId?: string | null
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutProductInput
    vendorWallet?: WalletUpdateOneWithoutProductInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyInput = {
    id?: string
    vendorId?: string | null
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
    affiliateId?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    billing?: BillingCreateNestedOneWithoutOrderInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    billing?: BillingUpdateOneWithoutOrderInput
    customer?: WalletUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    installments?: InstallmentUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type OrderCreateManyInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    phoneNumber?: string | null
    wallet?: WalletCreateNestedOneWithoutBillingInput
    order?: OrderCreateNestedManyWithoutBillingInput
  }

  export type BillingUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    phoneNumber?: string | null
    walletId?: string | null
    order?: OrderUncheckedCreateNestedManyWithoutBillingInput
  }

  export type BillingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutBillingInput
    order?: OrderUpdateManyWithoutBillingInput
  }

  export type BillingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUncheckedUpdateManyWithoutBillingInput
  }

  export type BillingCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    phoneNumber?: string | null
    walletId?: string | null
  }

  export type BillingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BuyerContactsCreateInput = {
    id?: string
    walletId: string
    name: string
    phoneNumber: string
    createdAt?: Date | string
  }

  export type BuyerContactsUncheckedCreateInput = {
    id?: string
    walletId: string
    name: string
    phoneNumber: string
    createdAt?: Date | string
  }

  export type BuyerContactsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerContactsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerContactsCreateManyInput = {
    id?: string
    walletId: string
    name: string
    phoneNumber: string
    createdAt?: Date | string
  }

  export type BuyerContactsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerContactsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    longitude?: string | null
    shippingType?: ShippingTypeEnum | null
    shippingFee?: number | null
    latitude?: string | null
    phoneNumber?: string | null
    isDefault?: boolean | null
    seviVerified?: boolean | null
    createdAt?: Date | string | null
    wallet?: WalletCreateNestedOneWithoutShippingInput
    Order?: OrderCreateNestedManyWithoutShippingInput
  }

  export type ShippingUncheckedCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    longitude?: string | null
    shippingType?: ShippingTypeEnum | null
    shippingFee?: number | null
    latitude?: string | null
    phoneNumber?: string | null
    walletId?: string | null
    isDefault?: boolean | null
    seviVerified?: boolean | null
    createdAt?: Date | string | null
    Order?: OrderUncheckedCreateNestedManyWithoutShippingInput
  }

  export type ShippingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallet?: WalletUpdateOneWithoutShippingInput
    Order?: OrderUpdateManyWithoutShippingInput
  }

  export type ShippingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: OrderUncheckedUpdateManyWithoutShippingInput
  }

  export type ShippingCreateManyInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    longitude?: string | null
    shippingType?: ShippingTypeEnum | null
    shippingFee?: number | null
    latitude?: string | null
    phoneNumber?: string | null
    walletId?: string | null
    isDefault?: boolean | null
    seviVerified?: boolean | null
    createdAt?: Date | string | null
  }

  export type ShippingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShippingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreditCreateInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    affiliate?: UserCreateNestedOneWithoutCreditsAffilateInput
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutCreditInput
    creditor?: WalletCreateNestedOneWithoutCreditorCreditInput
    debtor?: WalletCreateNestedOneWithoutDebtorCreditInput
    order?: OrderCreateNestedOneWithoutCreditInput
    user?: UserCreateNestedOneWithoutCreditsInput
    installments?: InstallmentCreateNestedManyWithoutCreditInput
  }

  export type CreditUncheckedCreateInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    affiliate?: UserUpdateOneWithoutCreditsAffilateInput
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutCreditInput
    creditor?: WalletUpdateOneWithoutCreditorCreditInput
    debtor?: WalletUpdateOneWithoutDebtorCreditInput
    order?: OrderUpdateOneWithoutCreditInput
    user?: UserUpdateOneWithoutCreditsInput
    installments?: InstallmentUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    installments?: InstallmentUncheckedUpdateManyWithoutCreditInput
  }

  export type CreditCreateManyInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
  }

  export type CreditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InstallmentCreateInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutInstallmentInput
    credit?: CreditCreateNestedOneWithoutInstallmentsInput
    creditor?: WalletCreateNestedOneWithoutCreditorInstallmentsInput
    debtor?: WalletCreateNestedOneWithoutDebtorInstallmentsInput
    order?: OrderCreateNestedOneWithoutInstallmentsInput
    user?: UserCreateNestedOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutInstallmentInput
    credit?: CreditUpdateOneWithoutInstallmentsInput
    creditor?: WalletUpdateOneWithoutCreditorInstallmentsInput
    debtor?: WalletUpdateOneWithoutDebtorInstallmentsInput
    order?: OrderUpdateOneWithoutInstallmentsInput
    user?: UserUpdateOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type InstallmentCreateManyInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type InstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type ActivityCreateInput = {
    id?: string
    entityId?: string | null
    entityType?: ActivityEntityType | null
    priority?: ActivityPriority | null
    phoneNumber?: string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean | null
    createdAt?: Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    entityId?: string | null
    entityType?: ActivityEntityType | null
    priority?: ActivityPriority | null
    phoneNumber?: string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean | null
    createdAt?: Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumActivityEntityTypeFieldUpdateOperationsInput | ActivityEntityType | null
    priority?: NullableEnumActivityPriorityFieldUpdateOperationsInput | ActivityPriority | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutActivityInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumActivityEntityTypeFieldUpdateOperationsInput | ActivityEntityType | null
    priority?: NullableEnumActivityPriorityFieldUpdateOperationsInput | ActivityPriority | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateManyInput = {
    id?: string
    entityId?: string | null
    entityType?: ActivityEntityType | null
    priority?: ActivityPriority | null
    phoneNumber?: string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean | null
    createdAt?: Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumActivityEntityTypeFieldUpdateOperationsInput | ActivityEntityType | null
    priority?: NullableEnumActivityPriorityFieldUpdateOperationsInput | ActivityPriority | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumActivityEntityTypeFieldUpdateOperationsInput | ActivityEntityType | null
    priority?: NullableEnumActivityPriorityFieldUpdateOperationsInput | ActivityPriority | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    messageId: string
    installmentSlices?: MessageCreateinstallmentSlicesInput | Enumerable<SlicesEnum>
    SMS?: string | null
    description?: string | null
    pushNotificationTitle?: string | null
    pushNotificationBody?: string | null
    email?: string | null
    language: language
  }

  export type MessageUncheckedCreateInput = {
    messageId: string
    installmentSlices?: MessageCreateinstallmentSlicesInput | Enumerable<SlicesEnum>
    SMS?: string | null
    description?: string | null
    pushNotificationTitle?: string | null
    pushNotificationBody?: string | null
    email?: string | null
    language: language
  }

  export type MessageUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    installmentSlices?: MessageUpdateinstallmentSlicesInput | Enumerable<SlicesEnum>
    SMS?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pushNotificationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    pushNotificationBody?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumlanguageFieldUpdateOperationsInput | language
  }

  export type MessageUncheckedUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    installmentSlices?: MessageUpdateinstallmentSlicesInput | Enumerable<SlicesEnum>
    SMS?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pushNotificationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    pushNotificationBody?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumlanguageFieldUpdateOperationsInput | language
  }

  export type MessageCreateManyInput = {
    messageId: string
    installmentSlices?: MessageCreateinstallmentSlicesInput | Enumerable<SlicesEnum>
    SMS?: string | null
    description?: string | null
    pushNotificationTitle?: string | null
    pushNotificationBody?: string | null
    email?: string | null
    language: language
  }

  export type MessageUpdateManyMutationInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    installmentSlices?: MessageUpdateinstallmentSlicesInput | Enumerable<SlicesEnum>
    SMS?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pushNotificationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    pushNotificationBody?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumlanguageFieldUpdateOperationsInput | language
  }

  export type MessageUncheckedUpdateManyInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    installmentSlices?: MessageUpdateinstallmentSlicesInput | Enumerable<SlicesEnum>
    SMS?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pushNotificationTitle?: NullableStringFieldUpdateOperationsInput | string | null
    pushNotificationBody?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumlanguageFieldUpdateOperationsInput | language
  }

  export type VerifyCreateInput = {
    id?: string
    UID?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    createdAt?: Date | string | null
    creditConfigId?: string | null
    OTP?: string | null
    email?: string | null
    orderPaymentMethod?: OrderPaymentMethodsEnum | null
    user?: UserCreateNestedOneWithoutVerifyInput
  }

  export type VerifyUncheckedCreateInput = {
    id?: string
    UID?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    createdAt?: Date | string | null
    creditConfigId?: string | null
    OTP?: string | null
    email?: string | null
    userId?: string | null
    orderPaymentMethod?: OrderPaymentMethodsEnum | null
  }

  export type VerifyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    UID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orderPaymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    user?: UserUpdateOneWithoutVerifyInput
  }

  export type VerifyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    UID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderPaymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
  }

  export type VerifyCreateManyInput = {
    id?: string
    UID?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    createdAt?: Date | string | null
    creditConfigId?: string | null
    OTP?: string | null
    email?: string | null
    userId?: string | null
    orderPaymentMethod?: OrderPaymentMethodsEnum | null
  }

  export type VerifyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    UID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orderPaymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
  }

  export type VerifyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    UID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    orderPaymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
  }

  export type LoginCreateInput = {
    id?: string
    qrKey?: string | null
    jwt?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLoginInput
  }

  export type LoginUncheckedCreateInput = {
    id?: string
    qrKey?: string | null
    jwt?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LoginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrKey?: NullableStringFieldUpdateOperationsInput | string | null
    jwt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLoginInput
  }

  export type LoginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrKey?: NullableStringFieldUpdateOperationsInput | string | null
    jwt?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginCreateManyInput = {
    id?: string
    qrKey?: string | null
    jwt?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type LoginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrKey?: NullableStringFieldUpdateOperationsInput | string | null
    jwt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrKey?: NullableStringFieldUpdateOperationsInput | string | null
    jwt?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCreateInput = {
    id?: string
    createdAt?: Date | string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
    wallet: WalletCreateNestedOneWithoutVisitInput
    visited?: UserCreateNestedOneWithoutVisitInput
  }

  export type VisitUncheckedCreateInput = {
    id?: string
    account: string
    createdAt?: Date | string | null
    visitedBy?: string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
  }

  export type VisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallet?: WalletUpdateOneRequiredWithoutVisitInput
    visited?: UserUpdateOneWithoutVisitInput
  }

  export type VisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitCreateManyInput = {
    id?: string
    account: string
    createdAt?: Date | string | null
    visitedBy?: string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
  }

  export type VisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReferenceNumberCreateInput = {
    id?: string
    prefix: string
    lastReference?: number | null
  }

  export type ReferenceNumberUncheckedCreateInput = {
    id?: string
    prefix: string
    lastReference?: number | null
  }

  export type ReferenceNumberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    lastReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceNumberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    lastReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceNumberCreateManyInput = {
    id?: string
    prefix: string
    lastReference?: number | null
  }

  export type ReferenceNumberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    lastReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferenceNumberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    lastReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JobCreateInput = {
    id?: string
    status: JobStatus
    version?: number
    createdAt?: Date | string
    name: string
  }

  export type JobUncheckedCreateInput = {
    id?: string
    status: JobStatus
    version?: number
    createdAt?: Date | string
    name: string
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type JobCreateManyInput = {
    id?: string
    status: JobStatus
    version?: number
    createdAt?: Date | string
    name: string
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CreditConfigurationCreateInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    wallet: WalletCreateNestedOneWithoutCreditConfigurationsInput
    credit?: CreditCreateNestedManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsCreateNestedManyWithoutConfigurationInput
    Installment?: InstallmentCreateNestedManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedCreateInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    fundId: string
    credit?: CreditUncheckedCreateNestedManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUncheckedCreateNestedManyWithoutConfigurationInput
    Installment?: InstallmentUncheckedCreateNestedManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet?: WalletUpdateOneRequiredWithoutCreditConfigurationsInput
    credit?: CreditUpdateManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUpdateManyWithoutConfigurationInput
    Installment?: InstallmentUpdateManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUpdateOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    fundId?: StringFieldUpdateOperationsInput | string
    credit?: CreditUncheckedUpdateManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUncheckedUpdateManyWithoutConfigurationInput
    Installment?: InstallmentUncheckedUpdateManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationCreateManyInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    fundId: string
  }

  export type CreditConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    fundId?: StringFieldUpdateOperationsInput | string
  }

  export type CreditConfigurationsWalletsCreateInput = {
    walletId: string
    upfrontPercentage: number
    fundFeesPercentage: number
    maxOrderAmount: number
    maxOutstandingCredit: number
    shareFeesPercentage?: number
    postDeliveryPercentage?: number
    configuration: CreditConfigurationCreateNestedOneWithoutAttachedWalletsInput
  }

  export type CreditConfigurationsWalletsUncheckedCreateInput = {
    configurationId: string
    walletId: string
    upfrontPercentage: number
    fundFeesPercentage: number
    maxOrderAmount: number
    maxOutstandingCredit: number
    shareFeesPercentage?: number
    postDeliveryPercentage?: number
  }

  export type CreditConfigurationsWalletsUpdateInput = {
    walletId?: StringFieldUpdateOperationsInput | string
    upfrontPercentage?: FloatFieldUpdateOperationsInput | number
    fundFeesPercentage?: FloatFieldUpdateOperationsInput | number
    maxOrderAmount?: FloatFieldUpdateOperationsInput | number
    maxOutstandingCredit?: FloatFieldUpdateOperationsInput | number
    shareFeesPercentage?: FloatFieldUpdateOperationsInput | number
    postDeliveryPercentage?: FloatFieldUpdateOperationsInput | number
    configuration?: CreditConfigurationUpdateOneRequiredWithoutAttachedWalletsInput
  }

  export type CreditConfigurationsWalletsUncheckedUpdateInput = {
    configurationId?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    upfrontPercentage?: FloatFieldUpdateOperationsInput | number
    fundFeesPercentage?: FloatFieldUpdateOperationsInput | number
    maxOrderAmount?: FloatFieldUpdateOperationsInput | number
    maxOutstandingCredit?: FloatFieldUpdateOperationsInput | number
    shareFeesPercentage?: FloatFieldUpdateOperationsInput | number
    postDeliveryPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type CreditConfigurationsWalletsCreateManyInput = {
    configurationId: string
    walletId: string
    upfrontPercentage: number
    fundFeesPercentage: number
    maxOrderAmount: number
    maxOutstandingCredit: number
    shareFeesPercentage?: number
    postDeliveryPercentage?: number
  }

  export type CreditConfigurationsWalletsUpdateManyMutationInput = {
    walletId?: StringFieldUpdateOperationsInput | string
    upfrontPercentage?: FloatFieldUpdateOperationsInput | number
    fundFeesPercentage?: FloatFieldUpdateOperationsInput | number
    maxOrderAmount?: FloatFieldUpdateOperationsInput | number
    maxOutstandingCredit?: FloatFieldUpdateOperationsInput | number
    shareFeesPercentage?: FloatFieldUpdateOperationsInput | number
    postDeliveryPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type CreditConfigurationsWalletsUncheckedUpdateManyInput = {
    configurationId?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    upfrontPercentage?: FloatFieldUpdateOperationsInput | number
    fundFeesPercentage?: FloatFieldUpdateOperationsInput | number
    maxOrderAmount?: FloatFieldUpdateOperationsInput | number
    maxOutstandingCredit?: FloatFieldUpdateOperationsInput | number
    shareFeesPercentage?: FloatFieldUpdateOperationsInput | number
    postDeliveryPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type OtherMemberKYCCreateInput = {
    id?: string
    name: string
    documentId: string
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    profilePictureURL: string
    idCardURL: string
    createdAt?: Date | string
    userIdToKYC: string
    OTP: string
    createdBy: UserCreateNestedOneWithoutOtherMemberKYCInput
  }

  export type OtherMemberKYCUncheckedCreateInput = {
    id?: string
    name: string
    documentId: string
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    profilePictureURL: string
    idCardURL: string
    createdAt?: Date | string
    createdByUserId: string
    userIdToKYC: string
    OTP: string
  }

  export type OtherMemberKYCUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureURL?: StringFieldUpdateOperationsInput | string
    idCardURL?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userIdToKYC?: StringFieldUpdateOperationsInput | string
    OTP?: StringFieldUpdateOperationsInput | string
    createdBy?: UserUpdateOneRequiredWithoutOtherMemberKYCInput
  }

  export type OtherMemberKYCUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureURL?: StringFieldUpdateOperationsInput | string
    idCardURL?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    userIdToKYC?: StringFieldUpdateOperationsInput | string
    OTP?: StringFieldUpdateOperationsInput | string
  }

  export type OtherMemberKYCCreateManyInput = {
    id?: string
    name: string
    documentId: string
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    profilePictureURL: string
    idCardURL: string
    createdAt?: Date | string
    createdByUserId: string
    userIdToKYC: string
    OTP: string
  }

  export type OtherMemberKYCUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureURL?: StringFieldUpdateOperationsInput | string
    idCardURL?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userIdToKYC?: StringFieldUpdateOperationsInput | string
    OTP?: StringFieldUpdateOperationsInput | string
  }

  export type OtherMemberKYCUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureURL?: StringFieldUpdateOperationsInput | string
    idCardURL?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    userIdToKYC?: StringFieldUpdateOperationsInput | string
    OTP?: StringFieldUpdateOperationsInput | string
  }

  export type SettingsCreateInput = {
    woocommerceUrl?: string | null
    woocommerceConsumerKey?: string | null
    woocommerceActive?: boolean | null
    woocommerceConsumerSecret?: string | null
    wallet: WalletCreateNestedOneWithoutSettingsInput
  }

  export type SettingsUncheckedCreateInput = {
    woocommerceUrl?: string | null
    woocommerceConsumerKey?: string | null
    woocommerceActive?: boolean | null
    woocommerceConsumerSecret?: string | null
    walletAccount: string
  }

  export type SettingsUpdateInput = {
    woocommerceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceConsumerKey?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    woocommerceConsumerSecret?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneRequiredWithoutSettingsInput
  }

  export type SettingsUncheckedUpdateInput = {
    woocommerceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceConsumerKey?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    woocommerceConsumerSecret?: NullableStringFieldUpdateOperationsInput | string | null
    walletAccount?: StringFieldUpdateOperationsInput | string
  }

  export type SettingsCreateManyInput = {
    woocommerceUrl?: string | null
    woocommerceConsumerKey?: string | null
    woocommerceActive?: boolean | null
    woocommerceConsumerSecret?: string | null
    walletAccount: string
  }

  export type SettingsUpdateManyMutationInput = {
    woocommerceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceConsumerKey?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    woocommerceConsumerSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsUncheckedUpdateManyInput = {
    woocommerceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceConsumerKey?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    woocommerceConsumerSecret?: NullableStringFieldUpdateOperationsInput | string | null
    walletAccount?: StringFieldUpdateOperationsInput | string
  }

  export type SettlementCreateInput = {
    id?: string
    type: TransactionMethodEnum
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    createdAt?: Date | string
    createdByAgent: boolean
    wallet: WalletCreateNestedOneWithoutSettlementInput
    settlementCreator: UserCreateNestedOneWithoutSettlementInput
    settlementVerifier?: UserCreateNestedOneWithoutSettlementInput
    Wallet?: WalletCreateNestedManyWithoutSettlementDefaultInput
  }

  export type SettlementUncheckedCreateInput = {
    id?: string
    type: TransactionMethodEnum
    account: string
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    verifiedByUser?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByAgent: boolean
    Wallet?: WalletUncheckedCreateNestedManyWithoutSettlementDefaultInput
  }

  export type SettlementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
    wallet?: WalletUpdateOneRequiredWithoutSettlementInput
    settlementCreator?: UserUpdateOneRequiredWithoutSettlementInput
    settlementVerifier?: UserUpdateOneWithoutSettlementInput
    Wallet?: WalletUpdateManyWithoutSettlementDefaultInput
  }

  export type SettlementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    account?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedByUser?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
    Wallet?: WalletUncheckedUpdateManyWithoutSettlementDefaultInput
  }

  export type SettlementCreateManyInput = {
    id?: string
    type: TransactionMethodEnum
    account: string
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    verifiedByUser?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByAgent: boolean
  }

  export type SettlementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettlementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    account?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedByUser?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionCreateInput = {
    id?: string
    answersType: answerTypeEnum
    category: QuestionCategoryEnum
    question: string
    isActive?: boolean
    description?: string | null
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    answersType: answerTypeEnum
    category: QuestionCategoryEnum
    question: string
    isActive?: boolean
    description?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answersType?: EnumanswerTypeEnumFieldUpdateOperationsInput | answerTypeEnum
    category?: EnumQuestionCategoryEnumFieldUpdateOperationsInput | QuestionCategoryEnum
    question?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUpdateManyWithoutQuestionInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answersType?: EnumanswerTypeEnumFieldUpdateOperationsInput | answerTypeEnum
    category?: EnumQuestionCategoryEnumFieldUpdateOperationsInput | QuestionCategoryEnum
    question?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutQuestionInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    answersType: answerTypeEnum
    category: QuestionCategoryEnum
    question: string
    isActive?: boolean
    description?: string | null
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answersType?: EnumanswerTypeEnumFieldUpdateOperationsInput | answerTypeEnum
    category?: EnumQuestionCategoryEnumFieldUpdateOperationsInput | QuestionCategoryEnum
    question?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    answersType?: EnumanswerTypeEnumFieldUpdateOperationsInput | answerTypeEnum
    category?: EnumQuestionCategoryEnumFieldUpdateOperationsInput | QuestionCategoryEnum
    question?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerCreateInput = {
    id?: string
    createdAt?: Date | string
    answer: string
    answeredByReference?: string | null
    wallet: WalletCreateNestedOneWithoutAnswersInput
    answered?: UserCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateInput = {
    id?: string
    questionId: string
    createdAt?: Date | string
    answer: string
    answeredBy?: string | null
    answeredByReference?: string | null
    account: string
  }

  export type AnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneRequiredWithoutAnswersInput
    answered?: UserUpdateOneWithoutAnswersInput
    question?: QuestionUpdateOneRequiredWithoutAnswersInput
  }

  export type AnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    account?: StringFieldUpdateOperationsInput | string
  }

  export type AnswerCreateManyInput = {
    id?: string
    questionId: string
    createdAt?: Date | string
    answer: string
    answeredBy?: string | null
    answeredByReference?: string | null
    account: string
  }

  export type AnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    account?: StringFieldUpdateOperationsInput | string
  }

  export type CreditRequestCreateInput = {
    id?: string
    status?: CreditRequestStatus
    wallet: string
    user?: UserCreateNestedOneWithoutCreditRequestsInput
    order?: OrderCreateNestedOneWithoutCreditRequestInput
    creditConfiguration?: CreditConfigurationCreateNestedOneWithoutCreditRequestsInput
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestUncheckedCreateInput = {
    id?: string
    status?: CreditRequestStatus
    orderId: string
    wallet: string
    creditConfigurationId: string
    userId: string
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    wallet?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutCreditRequestsInput
    order?: OrderUpdateOneWithoutCreditRequestInput
    creditConfiguration?: CreditConfigurationUpdateOneWithoutCreditRequestsInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    orderId?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRequestCreateManyInput = {
    id?: string
    status?: CreditRequestStatus
    orderId: string
    wallet: string
    creditConfigurationId: string
    userId: string
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    wallet?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    orderId?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumCountryCodeNullableFilter = {
    equals?: CountryCode | null
    in?: Enumerable<CountryCode> | null
    notIn?: Enumerable<CountryCode> | null
    not?: NestedEnumCountryCodeNullableFilter | CountryCode | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type EnumGenderEnumNullableFilter = {
    equals?: GenderEnum | null
    in?: Enumerable<GenderEnum> | null
    notIn?: Enumerable<GenderEnum> | null
    not?: NestedEnumGenderEnumNullableFilter | GenderEnum | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type AnswerListRelationFilter = {
    every?: AnswerWhereInput
    some?: AnswerWhereInput
    none?: AnswerWhereInput
  }

  export type CreditListRelationFilter = {
    every?: CreditWhereInput
    some?: CreditWhereInput
    none?: CreditWhereInput
  }

  export type InstallmentListRelationFilter = {
    every?: InstallmentWhereInput
    some?: InstallmentWhereInput
    none?: InstallmentWhereInput
  }

  export type LoginListRelationFilter = {
    every?: LoginWhereInput
    some?: LoginWhereInput
    none?: LoginWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type OtherMemberKYCListRelationFilter = {
    every?: OtherMemberKYCWhereInput
    some?: OtherMemberKYCWhereInput
    none?: OtherMemberKYCWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SettlementListRelationFilter = {
    every?: SettlementWhereInput
    some?: SettlementWhereInput
    none?: SettlementWhereInput
  }

  export type UsersWalletsListRelationFilter = {
    every?: UsersWalletsWhereInput
    some?: UsersWalletsWhereInput
    none?: UsersWalletsWhereInput
  }

  export type VerifyListRelationFilter = {
    every?: VerifyWhereInput
    some?: VerifyWhereInput
    none?: VerifyWhereInput
  }

  export type VisitListRelationFilter = {
    every?: VisitWhereInput
    some?: VisitWhereInput
    none?: VisitWhereInput
  }

  export type WalletListRelationFilter = {
    every?: WalletWhereInput
    some?: WalletWhereInput
    none?: WalletWhereInput
  }

  export type CreditRequestRelationFilter = {
    is?: CreditRequestWhereInput | null
    isNot?: CreditRequestWhereInput | null
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtherMemberKYCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersWalletsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerifyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userPhoto?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    documentId?: SortOrder
    url?: SortOrder
    email?: SortOrder
    pin?: SortOrder
    deviceToken?: SortOrder
    createdAt?: SortOrder
    verified?: SortOrder
    expoPushToken?: SortOrder
    inviterId?: SortOrder
    faceIdImage?: SortOrder
    documentCountry?: SortOrder
    documentData?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userPhoto?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    documentId?: SortOrder
    url?: SortOrder
    email?: SortOrder
    pin?: SortOrder
    deviceToken?: SortOrder
    createdAt?: SortOrder
    verified?: SortOrder
    expoPushToken?: SortOrder
    inviterId?: SortOrder
    faceIdImage?: SortOrder
    documentCountry?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userPhoto?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    documentId?: SortOrder
    url?: SortOrder
    email?: SortOrder
    pin?: SortOrder
    deviceToken?: SortOrder
    createdAt?: SortOrder
    verified?: SortOrder
    expoPushToken?: SortOrder
    inviterId?: SortOrder
    faceIdImage?: SortOrder
    documentCountry?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumCountryCodeNullableWithAggregatesFilter = {
    equals?: CountryCode | null
    in?: Enumerable<CountryCode> | null
    notIn?: Enumerable<CountryCode> | null
    not?: NestedEnumCountryCodeNullableWithAggregatesFilter | CountryCode | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCountryCodeNullableFilter
    _max?: NestedEnumCountryCodeNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type EnumGenderEnumNullableWithAggregatesFilter = {
    equals?: GenderEnum | null
    in?: Enumerable<GenderEnum> | null
    notIn?: Enumerable<GenderEnum> | null
    not?: NestedEnumGenderEnumNullableWithAggregatesFilter | GenderEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderEnumNullableFilter
    _max?: NestedEnumGenderEnumNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type EnumWalletRoleFilter = {
    equals?: WalletRole
    in?: Enumerable<WalletRole>
    notIn?: Enumerable<WalletRole>
    not?: NestedEnumWalletRoleFilter | WalletRole
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type WalletRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type UsersWalletsWalletIdUserIdCompoundUniqueInput = {
    walletId: string
    userId: string
  }

  export type UsersWalletsCountOrderByAggregateInput = {
    userId?: SortOrder
    walletId?: SortOrder
    role?: SortOrder
  }

  export type UsersWalletsMaxOrderByAggregateInput = {
    userId?: SortOrder
    walletId?: SortOrder
    role?: SortOrder
  }

  export type UsersWalletsMinOrderByAggregateInput = {
    userId?: SortOrder
    walletId?: SortOrder
    role?: SortOrder
  }

  export type EnumWalletRoleWithAggregatesFilter = {
    equals?: WalletRole
    in?: Enumerable<WalletRole>
    notIn?: Enumerable<WalletRole>
    not?: NestedEnumWalletRoleWithAggregatesFilter | WalletRole
    _count?: NestedIntFilter
    _min?: NestedEnumWalletRoleFilter
    _max?: NestedEnumWalletRoleFilter
  }

  export type CustomerCustomerIdVendorIdCompoundUniqueInput = {
    customerId: string
    vendorId: string
  }

  export type CustomerCountOrderByAggregateInput = {
    customerId?: SortOrder
    vendorId?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    customerId?: SortOrder
    vendorId?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    customerId?: SortOrder
    vendorId?: SortOrder
  }

  export type SupplierSupplierIdVendorIdCompoundUniqueInput = {
    supplierId: string
    vendorId: string
  }

  export type SupplierCountOrderByAggregateInput = {
    supplierId?: SortOrder
    vendorId?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    supplierId?: SortOrder
    vendorId?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    supplierId?: SortOrder
    vendorId?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type EnumBadgeTypeNullableFilter = {
    equals?: BadgeType | null
    in?: Enumerable<BadgeType> | null
    notIn?: Enumerable<BadgeType> | null
    not?: NestedEnumBadgeTypeNullableFilter | BadgeType | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    count?: SortOrder
    level?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    count?: SortOrder
    level?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    count?: SortOrder
    level?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    count?: SortOrder
    level?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    count?: SortOrder
    level?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type EnumBadgeTypeNullableWithAggregatesFilter = {
    equals?: BadgeType | null
    in?: Enumerable<BadgeType> | null
    notIn?: Enumerable<BadgeType> | null
    not?: NestedEnumBadgeTypeNullableWithAggregatesFilter | BadgeType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumBadgeTypeNullableFilter
    _max?: NestedEnumBadgeTypeNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BlacklistCountOrderByAggregateInput = {
    id?: SortOrder
    taxId?: SortOrder
    documentId?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistMaxOrderByAggregateInput = {
    id?: SortOrder
    taxId?: SortOrder
    documentId?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistMinOrderByAggregateInput = {
    id?: SortOrder
    taxId?: SortOrder
    documentId?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumWalletTypesEnumFilter = {
    equals?: WalletTypesEnum
    in?: Enumerable<WalletTypesEnum>
    notIn?: Enumerable<WalletTypesEnum>
    not?: NestedEnumWalletTypesEnumFilter | WalletTypesEnum
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type EnumCurrencyEnumNullableFilter = {
    equals?: CurrencyEnum | null
    in?: Enumerable<CurrencyEnum> | null
    notIn?: Enumerable<CurrencyEnum> | null
    not?: NestedEnumCurrencyEnumNullableFilter | CurrencyEnum | null
  }

  export type SettlementRelationFilter = {
    is?: SettlementWhereInput | null
    isNot?: SettlementWhereInput | null
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type BillingListRelationFilter = {
    every?: BillingWhereInput
    some?: BillingWhereInput
    none?: BillingWhereInput
  }

  export type CreditConfigurationListRelationFilter = {
    every?: CreditConfigurationWhereInput
    some?: CreditConfigurationWhereInput
    none?: CreditConfigurationWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type MetaDataRelationFilter = {
    is?: MetaDataWhereInput | null
    isNot?: MetaDataWhereInput | null
  }

  export type SettingsRelationFilter = {
    is?: SettingsWhereInput | null
    isNot?: SettingsWhereInput | null
  }

  export type ShippingListRelationFilter = {
    every?: ShippingWhereInput
    some?: ShippingWhereInput
    none?: ShippingWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TrustRelationFilter = {
    is?: TrustWhereInput | null
    isNot?: TrustWhereInput | null
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    settlementAutomatic?: SortOrder
    settlementDefaultId?: SortOrder
    verificationStartedAt?: SortOrder
    shippingId?: SortOrder
    picture?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    settlementAutomatic?: SortOrder
    settlementDefaultId?: SortOrder
    verificationStartedAt?: SortOrder
    shippingId?: SortOrder
    picture?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    settlementAutomatic?: SortOrder
    settlementDefaultId?: SortOrder
    verificationStartedAt?: SortOrder
    shippingId?: SortOrder
    picture?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumWalletTypesEnumWithAggregatesFilter = {
    equals?: WalletTypesEnum
    in?: Enumerable<WalletTypesEnum>
    notIn?: Enumerable<WalletTypesEnum>
    not?: NestedEnumWalletTypesEnumWithAggregatesFilter | WalletTypesEnum
    _count?: NestedIntFilter
    _min?: NestedEnumWalletTypesEnumFilter
    _max?: NestedEnumWalletTypesEnumFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type EnumCurrencyEnumNullableWithAggregatesFilter = {
    equals?: CurrencyEnum | null
    in?: Enumerable<CurrencyEnum> | null
    notIn?: Enumerable<CurrencyEnum> | null
    not?: NestedEnumCurrencyEnumNullableWithAggregatesFilter | CurrencyEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCurrencyEnumNullableFilter
    _max?: NestedEnumCurrencyEnumNullableFilter
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type TrustCountOrderByAggregateInput = {
    account?: SortOrder
    trustRating?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustAvgOrderByAggregateInput = {
    trustRating?: SortOrder
    score?: SortOrder
  }

  export type TrustMaxOrderByAggregateInput = {
    account?: SortOrder
    trustRating?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustMinOrderByAggregateInput = {
    account?: SortOrder
    trustRating?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustSumOrderByAggregateInput = {
    trustRating?: SortOrder
    score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EnumphaseEnumNullableFilter = {
    equals?: phaseEnum | null
    in?: Enumerable<phaseEnum> | null
    notIn?: Enumerable<phaseEnum> | null
    not?: NestedEnumphaseEnumNullableFilter | phaseEnum | null
  }

  export type EnumpartnerRoleEnumNullableFilter = {
    equals?: partnerRoleEnum | null
    in?: Enumerable<partnerRoleEnum> | null
    notIn?: Enumerable<partnerRoleEnum> | null
    not?: NestedEnumpartnerRoleEnumNullableFilter | partnerRoleEnum | null
  }

  export type EnumlegalStatusEnumNullableFilter = {
    equals?: legalStatusEnum | null
    in?: Enumerable<legalStatusEnum> | null
    notIn?: Enumerable<legalStatusEnum> | null
    not?: NestedEnumlegalStatusEnumNullableFilter | legalStatusEnum | null
  }

  export type MetaDataCountOrderByAggregateInput = {
    walletAccount?: SortOrder
    CRB?: SortOrder
    taxId?: SortOrder
    taxName?: SortOrder
    seller?: SortOrder
    sellerPhase?: SortOrder
    buyerPhase?: SortOrder
    partnerRole?: SortOrder
    documentCOI?: SortOrder
    documentCR12?: SortOrder
    documentSCF?: SortOrder
    documentSCA?: SortOrder
    documentStore?: SortOrder
    documentKRAcert?: SortOrder
    legalStatus?: SortOrder
    metaBaseURL?: SortOrder
    buyer?: SortOrder
    maxBuyerOrderAmount?: SortOrder
  }

  export type MetaDataAvgOrderByAggregateInput = {
    maxBuyerOrderAmount?: SortOrder
  }

  export type MetaDataMaxOrderByAggregateInput = {
    walletAccount?: SortOrder
    taxId?: SortOrder
    taxName?: SortOrder
    seller?: SortOrder
    sellerPhase?: SortOrder
    buyerPhase?: SortOrder
    partnerRole?: SortOrder
    documentCOI?: SortOrder
    documentCR12?: SortOrder
    documentSCF?: SortOrder
    documentSCA?: SortOrder
    documentStore?: SortOrder
    documentKRAcert?: SortOrder
    legalStatus?: SortOrder
    buyer?: SortOrder
    maxBuyerOrderAmount?: SortOrder
  }

  export type MetaDataMinOrderByAggregateInput = {
    walletAccount?: SortOrder
    taxId?: SortOrder
    taxName?: SortOrder
    seller?: SortOrder
    sellerPhase?: SortOrder
    buyerPhase?: SortOrder
    partnerRole?: SortOrder
    documentCOI?: SortOrder
    documentCR12?: SortOrder
    documentSCF?: SortOrder
    documentSCA?: SortOrder
    documentStore?: SortOrder
    documentKRAcert?: SortOrder
    legalStatus?: SortOrder
    buyer?: SortOrder
    maxBuyerOrderAmount?: SortOrder
  }

  export type MetaDataSumOrderByAggregateInput = {
    maxBuyerOrderAmount?: SortOrder
  }

  export type EnumphaseEnumNullableWithAggregatesFilter = {
    equals?: phaseEnum | null
    in?: Enumerable<phaseEnum> | null
    notIn?: Enumerable<phaseEnum> | null
    not?: NestedEnumphaseEnumNullableWithAggregatesFilter | phaseEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumphaseEnumNullableFilter
    _max?: NestedEnumphaseEnumNullableFilter
  }

  export type EnumpartnerRoleEnumNullableWithAggregatesFilter = {
    equals?: partnerRoleEnum | null
    in?: Enumerable<partnerRoleEnum> | null
    notIn?: Enumerable<partnerRoleEnum> | null
    not?: NestedEnumpartnerRoleEnumNullableWithAggregatesFilter | partnerRoleEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumpartnerRoleEnumNullableFilter
    _max?: NestedEnumpartnerRoleEnumNullableFilter
  }

  export type EnumlegalStatusEnumNullableWithAggregatesFilter = {
    equals?: legalStatusEnum | null
    in?: Enumerable<legalStatusEnum> | null
    notIn?: Enumerable<legalStatusEnum> | null
    not?: NestedEnumlegalStatusEnumNullableWithAggregatesFilter | legalStatusEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumlegalStatusEnumNullableFilter
    _max?: NestedEnumlegalStatusEnumNullableFilter
  }

  export type EnumPaymentTypesEnumFilter = {
    equals?: PaymentTypesEnum
    in?: Enumerable<PaymentTypesEnum>
    notIn?: Enumerable<PaymentTypesEnum>
    not?: NestedEnumPaymentTypesEnumFilter | PaymentTypesEnum
  }

  export type EnumCurrencyEnumFilter = {
    equals?: CurrencyEnum
    in?: Enumerable<CurrencyEnum>
    notIn?: Enumerable<CurrencyEnum>
    not?: NestedEnumCurrencyEnumFilter | CurrencyEnum
  }

  export type EnumTransactionTypeEnumNullableFilter = {
    equals?: TransactionTypeEnum | null
    in?: Enumerable<TransactionTypeEnum> | null
    notIn?: Enumerable<TransactionTypeEnum> | null
    not?: NestedEnumTransactionTypeEnumNullableFilter | TransactionTypeEnum | null
  }

  export type EnumTransactionMethodEnumNullableFilter = {
    equals?: TransactionMethodEnum | null
    in?: Enumerable<TransactionMethodEnum> | null
    notIn?: Enumerable<TransactionMethodEnum> | null
    not?: NestedEnumTransactionMethodEnumNullableFilter | TransactionMethodEnum | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    totalAmount?: SortOrder
    description?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    method?: SortOrder
    walletId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    balanceAfter?: SortOrder
    balanceBefore?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    fee?: SortOrder
    totalAmount?: SortOrder
    balanceAfter?: SortOrder
    balanceBefore?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    totalAmount?: SortOrder
    description?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    method?: SortOrder
    walletId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    balanceAfter?: SortOrder
    balanceBefore?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    totalAmount?: SortOrder
    description?: SortOrder
    paymentType?: SortOrder
    paymentTypeId?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    method?: SortOrder
    walletId?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    balanceAfter?: SortOrder
    balanceBefore?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    fee?: SortOrder
    totalAmount?: SortOrder
    balanceAfter?: SortOrder
    balanceBefore?: SortOrder
  }

  export type EnumPaymentTypesEnumWithAggregatesFilter = {
    equals?: PaymentTypesEnum
    in?: Enumerable<PaymentTypesEnum>
    notIn?: Enumerable<PaymentTypesEnum>
    not?: NestedEnumPaymentTypesEnumWithAggregatesFilter | PaymentTypesEnum
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentTypesEnumFilter
    _max?: NestedEnumPaymentTypesEnumFilter
  }

  export type EnumCurrencyEnumWithAggregatesFilter = {
    equals?: CurrencyEnum
    in?: Enumerable<CurrencyEnum>
    notIn?: Enumerable<CurrencyEnum>
    not?: NestedEnumCurrencyEnumWithAggregatesFilter | CurrencyEnum
    _count?: NestedIntFilter
    _min?: NestedEnumCurrencyEnumFilter
    _max?: NestedEnumCurrencyEnumFilter
  }

  export type EnumTransactionTypeEnumNullableWithAggregatesFilter = {
    equals?: TransactionTypeEnum | null
    in?: Enumerable<TransactionTypeEnum> | null
    notIn?: Enumerable<TransactionTypeEnum> | null
    not?: NestedEnumTransactionTypeEnumNullableWithAggregatesFilter | TransactionTypeEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumTransactionTypeEnumNullableFilter
    _max?: NestedEnumTransactionTypeEnumNullableFilter
  }

  export type EnumTransactionMethodEnumNullableWithAggregatesFilter = {
    equals?: TransactionMethodEnum | null
    in?: Enumerable<TransactionMethodEnum> | null
    notIn?: Enumerable<TransactionMethodEnum> | null
    not?: NestedEnumTransactionMethodEnumNullableWithAggregatesFilter | TransactionMethodEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumTransactionMethodEnumNullableFilter
    _max?: NestedEnumTransactionMethodEnumNullableFilter
  }

  export type EnumEcommercePlatformEnumNullableFilter = {
    equals?: EcommercePlatformEnum | null
    in?: Enumerable<EcommercePlatformEnum> | null
    notIn?: Enumerable<EcommercePlatformEnum> | null
    not?: NestedEnumEcommercePlatformEnumNullableFilter | EcommercePlatformEnum | null
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    quantity?: SortOrder
    vendorName?: SortOrder
    vendorType?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
    listedPublic?: SortOrder
    description?: SortOrder
    gallery?: SortOrder
    categories?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    ecommercePlatform?: SortOrder
    platformId?: SortOrder
    affiliateId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    quantity?: SortOrder
    vendorName?: SortOrder
    vendorType?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
    listedPublic?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    ecommercePlatform?: SortOrder
    platformId?: SortOrder
    affiliateId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    quantity?: SortOrder
    vendorName?: SortOrder
    vendorType?: SortOrder
    name?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
    listedPublic?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    ecommercePlatform?: SortOrder
    platformId?: SortOrder
    affiliateId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    unitPrice?: SortOrder
  }

  export type EnumEcommercePlatformEnumNullableWithAggregatesFilter = {
    equals?: EcommercePlatformEnum | null
    in?: Enumerable<EcommercePlatformEnum> | null
    notIn?: Enumerable<EcommercePlatformEnum> | null
    not?: NestedEnumEcommercePlatformEnumNullableWithAggregatesFilter | EcommercePlatformEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEcommercePlatformEnumNullableFilter
    _max?: NestedEnumEcommercePlatformEnumNullableFilter
  }

  export type EnumOrderStatusEnumNullableFilter = {
    equals?: OrderStatusEnum | null
    in?: Enumerable<OrderStatusEnum> | null
    notIn?: Enumerable<OrderStatusEnum> | null
    not?: NestedEnumOrderStatusEnumNullableFilter | OrderStatusEnum | null
  }

  export type EnumPaymentStatusEnumFilter = {
    equals?: PaymentStatusEnum
    in?: Enumerable<PaymentStatusEnum>
    notIn?: Enumerable<PaymentStatusEnum>
    not?: NestedEnumPaymentStatusEnumFilter | PaymentStatusEnum
  }

  export type EnumOrderPaymentMethodsEnumNullableFilter = {
    equals?: OrderPaymentMethodsEnum | null
    in?: Enumerable<OrderPaymentMethodsEnum> | null
    notIn?: Enumerable<OrderPaymentMethodsEnum> | null
    not?: NestedEnumOrderPaymentMethodsEnumNullableFilter | OrderPaymentMethodsEnum | null
  }

  export type BillingRelationFilter = {
    is?: BillingWhereInput | null
    isNot?: BillingWhereInput | null
  }

  export type ShippingRelationFilter = {
    is?: ShippingWhereInput | null
    isNot?: ShippingWhereInput | null
  }

  export type CreditRelationFilter = {
    is?: CreditWhereInput | null
    isNot?: CreditWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    affiliateId?: SortOrder
    products?: SortOrder
    items?: SortOrder
    deliveryCode?: SortOrder
    createdAt?: SortOrder
    paymentStatus?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    billingId?: SortOrder
    shippingId?: SortOrder
    ecommercePlatform?: SortOrder
    currency?: SortOrder
    platformId?: SortOrder
    customerId?: SortOrder
    referenceNumber?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    affiliateId?: SortOrder
    deliveryCode?: SortOrder
    createdAt?: SortOrder
    paymentStatus?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    billingId?: SortOrder
    shippingId?: SortOrder
    ecommercePlatform?: SortOrder
    currency?: SortOrder
    platformId?: SortOrder
    customerId?: SortOrder
    referenceNumber?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    affiliateId?: SortOrder
    deliveryCode?: SortOrder
    createdAt?: SortOrder
    paymentStatus?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    billingId?: SortOrder
    shippingId?: SortOrder
    ecommercePlatform?: SortOrder
    currency?: SortOrder
    platformId?: SortOrder
    customerId?: SortOrder
    referenceNumber?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumOrderStatusEnumNullableWithAggregatesFilter = {
    equals?: OrderStatusEnum | null
    in?: Enumerable<OrderStatusEnum> | null
    notIn?: Enumerable<OrderStatusEnum> | null
    not?: NestedEnumOrderStatusEnumNullableWithAggregatesFilter | OrderStatusEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumOrderStatusEnumNullableFilter
    _max?: NestedEnumOrderStatusEnumNullableFilter
  }

  export type EnumPaymentStatusEnumWithAggregatesFilter = {
    equals?: PaymentStatusEnum
    in?: Enumerable<PaymentStatusEnum>
    notIn?: Enumerable<PaymentStatusEnum>
    not?: NestedEnumPaymentStatusEnumWithAggregatesFilter | PaymentStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentStatusEnumFilter
    _max?: NestedEnumPaymentStatusEnumFilter
  }

  export type EnumOrderPaymentMethodsEnumNullableWithAggregatesFilter = {
    equals?: OrderPaymentMethodsEnum | null
    in?: Enumerable<OrderPaymentMethodsEnum> | null
    notIn?: Enumerable<OrderPaymentMethodsEnum> | null
    not?: NestedEnumOrderPaymentMethodsEnumNullableWithAggregatesFilter | OrderPaymentMethodsEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumOrderPaymentMethodsEnumNullableFilter
    _max?: NestedEnumOrderPaymentMethodsEnumNullableFilter
  }

  export type BillingCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
  }

  export type BillingMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
  }

  export type BillingMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
  }

  export type BuyerContactsCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type BuyerContactsMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type BuyerContactsMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumShippingTypeEnumNullableFilter = {
    equals?: ShippingTypeEnum | null
    in?: Enumerable<ShippingTypeEnum> | null
    notIn?: Enumerable<ShippingTypeEnum> | null
    not?: NestedEnumShippingTypeEnumNullableFilter | ShippingTypeEnum | null
  }

  export type ShippingCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    longitude?: SortOrder
    shippingType?: SortOrder
    shippingFee?: SortOrder
    latitude?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
    isDefault?: SortOrder
    seviVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type ShippingAvgOrderByAggregateInput = {
    shippingFee?: SortOrder
  }

  export type ShippingMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    longitude?: SortOrder
    shippingType?: SortOrder
    shippingFee?: SortOrder
    latitude?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
    isDefault?: SortOrder
    seviVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type ShippingMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    address1?: SortOrder
    address2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    email?: SortOrder
    longitude?: SortOrder
    shippingType?: SortOrder
    shippingFee?: SortOrder
    latitude?: SortOrder
    phoneNumber?: SortOrder
    walletId?: SortOrder
    isDefault?: SortOrder
    seviVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type ShippingSumOrderByAggregateInput = {
    shippingFee?: SortOrder
  }

  export type EnumShippingTypeEnumNullableWithAggregatesFilter = {
    equals?: ShippingTypeEnum | null
    in?: Enumerable<ShippingTypeEnum> | null
    notIn?: Enumerable<ShippingTypeEnum> | null
    not?: NestedEnumShippingTypeEnumNullableWithAggregatesFilter | ShippingTypeEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumShippingTypeEnumNullableFilter
    _max?: NestedEnumShippingTypeEnumNullableFilter
  }

  export type EnumcreditRefTypeNullableFilter = {
    equals?: creditRefType | null
    in?: Enumerable<creditRefType> | null
    notIn?: Enumerable<creditRefType> | null
    not?: NestedEnumcreditRefTypeNullableFilter | creditRefType | null
  }

  export type EnumcreditStatusEnumNullableFilter = {
    equals?: creditStatusEnum | null
    in?: Enumerable<creditStatusEnum> | null
    notIn?: Enumerable<creditStatusEnum> | null
    not?: NestedEnumcreditStatusEnumNullableFilter | creditStatusEnum | null
  }

  export type EnumSlicesEnumFilter = {
    equals?: SlicesEnum
    in?: Enumerable<SlicesEnum>
    notIn?: Enumerable<SlicesEnum>
    not?: NestedEnumSlicesEnumFilter | SlicesEnum
  }

  export type CreditConfigurationRelationFilter = {
    is?: CreditConfigurationWhereInput
    isNot?: CreditConfigurationWhereInput
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type CreditCountOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    currency?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    installmentsCount?: SortOrder
    installmentsCountPaid?: SortOrder
    status?: SortOrder
    description?: SortOrder
    totalPaid?: SortOrder
    totalToPay?: SortOrder
    agreedDate?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    referenceNumber?: SortOrder
    creditConfigurationId?: SortOrder
    endDate?: SortOrder
    paidAt?: SortOrder
    duration?: SortOrder
    durationSlices?: SortOrder
    affiliateId?: SortOrder
    defaultAt?: SortOrder
    fundUpfrontAmount?: SortOrder
    orderWalletId?: SortOrder
    fundFeesAmount?: SortOrder
    amountWithFees?: SortOrder
    seviFeesAmount?: SortOrder
    orderWalletShareFeesAmount?: SortOrder
    fundPostDeliveryAmount?: SortOrder
  }

  export type CreditAvgOrderByAggregateInput = {
    amount?: SortOrder
    installmentsCount?: SortOrder
    installmentsCountPaid?: SortOrder
    totalPaid?: SortOrder
    totalToPay?: SortOrder
    duration?: SortOrder
    fundUpfrontAmount?: SortOrder
    fundFeesAmount?: SortOrder
    amountWithFees?: SortOrder
    seviFeesAmount?: SortOrder
    orderWalletShareFeesAmount?: SortOrder
    fundPostDeliveryAmount?: SortOrder
  }

  export type CreditMaxOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    currency?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    installmentsCount?: SortOrder
    installmentsCountPaid?: SortOrder
    status?: SortOrder
    description?: SortOrder
    totalPaid?: SortOrder
    totalToPay?: SortOrder
    agreedDate?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    referenceNumber?: SortOrder
    creditConfigurationId?: SortOrder
    endDate?: SortOrder
    paidAt?: SortOrder
    duration?: SortOrder
    durationSlices?: SortOrder
    affiliateId?: SortOrder
    defaultAt?: SortOrder
    fundUpfrontAmount?: SortOrder
    orderWalletId?: SortOrder
    fundFeesAmount?: SortOrder
    amountWithFees?: SortOrder
    seviFeesAmount?: SortOrder
    orderWalletShareFeesAmount?: SortOrder
    fundPostDeliveryAmount?: SortOrder
  }

  export type CreditMinOrderByAggregateInput = {
    id?: SortOrder
    typeId?: SortOrder
    currency?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    installmentsCount?: SortOrder
    installmentsCountPaid?: SortOrder
    status?: SortOrder
    description?: SortOrder
    totalPaid?: SortOrder
    totalToPay?: SortOrder
    agreedDate?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    referenceNumber?: SortOrder
    creditConfigurationId?: SortOrder
    endDate?: SortOrder
    paidAt?: SortOrder
    duration?: SortOrder
    durationSlices?: SortOrder
    affiliateId?: SortOrder
    defaultAt?: SortOrder
    fundUpfrontAmount?: SortOrder
    orderWalletId?: SortOrder
    fundFeesAmount?: SortOrder
    amountWithFees?: SortOrder
    seviFeesAmount?: SortOrder
    orderWalletShareFeesAmount?: SortOrder
    fundPostDeliveryAmount?: SortOrder
  }

  export type CreditSumOrderByAggregateInput = {
    amount?: SortOrder
    installmentsCount?: SortOrder
    installmentsCountPaid?: SortOrder
    totalPaid?: SortOrder
    totalToPay?: SortOrder
    duration?: SortOrder
    fundUpfrontAmount?: SortOrder
    fundFeesAmount?: SortOrder
    amountWithFees?: SortOrder
    seviFeesAmount?: SortOrder
    orderWalletShareFeesAmount?: SortOrder
    fundPostDeliveryAmount?: SortOrder
  }

  export type EnumcreditRefTypeNullableWithAggregatesFilter = {
    equals?: creditRefType | null
    in?: Enumerable<creditRefType> | null
    notIn?: Enumerable<creditRefType> | null
    not?: NestedEnumcreditRefTypeNullableWithAggregatesFilter | creditRefType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumcreditRefTypeNullableFilter
    _max?: NestedEnumcreditRefTypeNullableFilter
  }

  export type EnumcreditStatusEnumNullableWithAggregatesFilter = {
    equals?: creditStatusEnum | null
    in?: Enumerable<creditStatusEnum> | null
    notIn?: Enumerable<creditStatusEnum> | null
    not?: NestedEnumcreditStatusEnumNullableWithAggregatesFilter | creditStatusEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumcreditStatusEnumNullableFilter
    _max?: NestedEnumcreditStatusEnumNullableFilter
  }

  export type EnumSlicesEnumWithAggregatesFilter = {
    equals?: SlicesEnum
    in?: Enumerable<SlicesEnum>
    notIn?: Enumerable<SlicesEnum>
    not?: NestedEnumSlicesEnumWithAggregatesFilter | SlicesEnum
    _count?: NestedIntFilter
    _min?: NestedEnumSlicesEnumFilter
    _max?: NestedEnumSlicesEnumFilter
  }

  export type EnuminstallmentStatusTypeEnumNullableFilter = {
    equals?: installmentStatusTypeEnum | null
    in?: Enumerable<installmentStatusTypeEnum> | null
    notIn?: Enumerable<installmentStatusTypeEnum> | null
    not?: NestedEnuminstallmentStatusTypeEnumNullableFilter | installmentStatusTypeEnum | null
  }

  export type InstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    installmentCount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    referenceNumber?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    firstTryFailedAt?: SortOrder
    creditId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    amountWithPenalty?: SortOrder
    seviFees?: SortOrder
    penalty?: SortOrder
    paidAt?: SortOrder
    creditConfigurationId?: SortOrder
    affiliateFees?: SortOrder
    currency?: SortOrder
  }

  export type InstallmentAvgOrderByAggregateInput = {
    installmentCount?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    amountWithPenalty?: SortOrder
    seviFees?: SortOrder
    penalty?: SortOrder
    affiliateFees?: SortOrder
  }

  export type InstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    installmentCount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    referenceNumber?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    firstTryFailedAt?: SortOrder
    creditId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    amountWithPenalty?: SortOrder
    seviFees?: SortOrder
    penalty?: SortOrder
    paidAt?: SortOrder
    creditConfigurationId?: SortOrder
    affiliateFees?: SortOrder
    currency?: SortOrder
  }

  export type InstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    installmentCount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    referenceNumber?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    debtorId?: SortOrder
    creditorId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    firstTryFailedAt?: SortOrder
    creditId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    amountWithPenalty?: SortOrder
    seviFees?: SortOrder
    penalty?: SortOrder
    paidAt?: SortOrder
    creditConfigurationId?: SortOrder
    affiliateFees?: SortOrder
    currency?: SortOrder
  }

  export type InstallmentSumOrderByAggregateInput = {
    installmentCount?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    amountWithPenalty?: SortOrder
    seviFees?: SortOrder
    penalty?: SortOrder
    affiliateFees?: SortOrder
  }

  export type EnuminstallmentStatusTypeEnumNullableWithAggregatesFilter = {
    equals?: installmentStatusTypeEnum | null
    in?: Enumerable<installmentStatusTypeEnum> | null
    notIn?: Enumerable<installmentStatusTypeEnum> | null
    not?: NestedEnuminstallmentStatusTypeEnumNullableWithAggregatesFilter | installmentStatusTypeEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnuminstallmentStatusTypeEnumNullableFilter
    _max?: NestedEnuminstallmentStatusTypeEnumNullableFilter
  }

  export type EnumActivityEntityTypeNullableFilter = {
    equals?: ActivityEntityType | null
    in?: Enumerable<ActivityEntityType> | null
    notIn?: Enumerable<ActivityEntityType> | null
    not?: NestedEnumActivityEntityTypeNullableFilter | ActivityEntityType | null
  }

  export type EnumActivityPriorityNullableFilter = {
    equals?: ActivityPriority | null
    in?: Enumerable<ActivityPriority> | null
    notIn?: Enumerable<ActivityPriority> | null
    not?: NestedEnumActivityPriorityNullableFilter | ActivityPriority | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    priority?: SortOrder
    phoneNumber?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    entity?: SortOrder
    userId?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    priority?: SortOrder
    phoneNumber?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    entityType?: SortOrder
    priority?: SortOrder
    phoneNumber?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumActivityEntityTypeNullableWithAggregatesFilter = {
    equals?: ActivityEntityType | null
    in?: Enumerable<ActivityEntityType> | null
    notIn?: Enumerable<ActivityEntityType> | null
    not?: NestedEnumActivityEntityTypeNullableWithAggregatesFilter | ActivityEntityType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumActivityEntityTypeNullableFilter
    _max?: NestedEnumActivityEntityTypeNullableFilter
  }

  export type EnumActivityPriorityNullableWithAggregatesFilter = {
    equals?: ActivityPriority | null
    in?: Enumerable<ActivityPriority> | null
    notIn?: Enumerable<ActivityPriority> | null
    not?: NestedEnumActivityPriorityNullableWithAggregatesFilter | ActivityPriority | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumActivityPriorityNullableFilter
    _max?: NestedEnumActivityPriorityNullableFilter
  }

  export type EnumSlicesEnumNullableListFilter = {
    equals?: Enumerable<SlicesEnum> | null
    has?: SlicesEnum | null
    hasEvery?: Enumerable<SlicesEnum>
    hasSome?: Enumerable<SlicesEnum>
    isEmpty?: boolean
  }

  export type EnumlanguageFilter = {
    equals?: language
    in?: Enumerable<language>
    notIn?: Enumerable<language>
    not?: NestedEnumlanguageFilter | language
  }

  export type MessageMessageIdLanguageCompoundUniqueInput = {
    messageId: string
    language: language
  }

  export type MessageCountOrderByAggregateInput = {
    messageId?: SortOrder
    installmentSlices?: SortOrder
    SMS?: SortOrder
    description?: SortOrder
    pushNotificationTitle?: SortOrder
    pushNotificationBody?: SortOrder
    email?: SortOrder
    language?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    messageId?: SortOrder
    SMS?: SortOrder
    description?: SortOrder
    pushNotificationTitle?: SortOrder
    pushNotificationBody?: SortOrder
    email?: SortOrder
    language?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    messageId?: SortOrder
    SMS?: SortOrder
    description?: SortOrder
    pushNotificationTitle?: SortOrder
    pushNotificationBody?: SortOrder
    email?: SortOrder
    language?: SortOrder
  }

  export type EnumlanguageWithAggregatesFilter = {
    equals?: language
    in?: Enumerable<language>
    notIn?: Enumerable<language>
    not?: NestedEnumlanguageWithAggregatesFilter | language
    _count?: NestedIntFilter
    _min?: NestedEnumlanguageFilter
    _max?: NestedEnumlanguageFilter
  }

  export type VerifyCountOrderByAggregateInput = {
    id?: SortOrder
    UID?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    creditConfigId?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    orderPaymentMethod?: SortOrder
  }

  export type VerifyMaxOrderByAggregateInput = {
    id?: SortOrder
    UID?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    creditConfigId?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    orderPaymentMethod?: SortOrder
  }

  export type VerifyMinOrderByAggregateInput = {
    id?: SortOrder
    UID?: SortOrder
    phoneNumber?: SortOrder
    countryCode?: SortOrder
    createdAt?: SortOrder
    creditConfigId?: SortOrder
    OTP?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    orderPaymentMethod?: SortOrder
  }

  export type LoginCountOrderByAggregateInput = {
    id?: SortOrder
    qrKey?: SortOrder
    jwt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginMaxOrderByAggregateInput = {
    id?: SortOrder
    qrKey?: SortOrder
    jwt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginMinOrderByAggregateInput = {
    id?: SortOrder
    qrKey?: SortOrder
    jwt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitCountOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    visitedBy?: SortOrder
    visitedByReference?: SortOrder
    whenVisitTookPlace?: SortOrder
  }

  export type VisitMaxOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    visitedBy?: SortOrder
    visitedByReference?: SortOrder
    whenVisitTookPlace?: SortOrder
  }

  export type VisitMinOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    createdAt?: SortOrder
    visitedBy?: SortOrder
    visitedByReference?: SortOrder
    whenVisitTookPlace?: SortOrder
  }

  export type ReferenceNumberCountOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    lastReference?: SortOrder
  }

  export type ReferenceNumberAvgOrderByAggregateInput = {
    lastReference?: SortOrder
  }

  export type ReferenceNumberMaxOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    lastReference?: SortOrder
  }

  export type ReferenceNumberMinOrderByAggregateInput = {
    id?: SortOrder
    prefix?: SortOrder
    lastReference?: SortOrder
  }

  export type ReferenceNumberSumOrderByAggregateInput = {
    lastReference?: SortOrder
  }

  export type EnumJobStatusFilter = {
    equals?: JobStatus
    in?: Enumerable<JobStatus>
    notIn?: Enumerable<JobStatus>
    not?: NestedEnumJobStatusFilter | JobStatus
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter = {
    equals?: JobStatus
    in?: Enumerable<JobStatus>
    notIn?: Enumerable<JobStatus>
    not?: NestedEnumJobStatusWithAggregatesFilter | JobStatus
    _count?: NestedIntFilter
    _min?: NestedEnumJobStatusFilter
    _max?: NestedEnumJobStatusFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumCreditConfigurationStatusFilter = {
    equals?: CreditConfigurationStatus
    in?: Enumerable<CreditConfigurationStatus>
    notIn?: Enumerable<CreditConfigurationStatus>
    not?: NestedEnumCreditConfigurationStatusFilter | CreditConfigurationStatus
  }

  export type CreditConfigurationsWalletsListRelationFilter = {
    every?: CreditConfigurationsWalletsWhereInput
    some?: CreditConfigurationsWalletsWhereInput
    none?: CreditConfigurationsWalletsWhereInput
  }

  export type CreditConfigurationsWalletsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shouldPayDeposit?: SortOrder
    depositPercentage?: SortOrder
    duration?: SortOrder
    slices?: SortOrder
    seviFeesPercentage?: SortOrder
    daysToStartAfterDelivery?: SortOrder
    lateInstallmentFeesPercentage?: SortOrder
    affiliatePercentage?: SortOrder
    creditLateFeesPercentage?: SortOrder
    creditLateDays?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numberOfAllowedCredits?: SortOrder
    fundFeesPercentage?: SortOrder
    fundId?: SortOrder
  }

  export type CreditConfigurationAvgOrderByAggregateInput = {
    depositPercentage?: SortOrder
    duration?: SortOrder
    seviFeesPercentage?: SortOrder
    daysToStartAfterDelivery?: SortOrder
    lateInstallmentFeesPercentage?: SortOrder
    affiliatePercentage?: SortOrder
    creditLateFeesPercentage?: SortOrder
    creditLateDays?: SortOrder
    numberOfAllowedCredits?: SortOrder
    fundFeesPercentage?: SortOrder
  }

  export type CreditConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shouldPayDeposit?: SortOrder
    depositPercentage?: SortOrder
    duration?: SortOrder
    slices?: SortOrder
    seviFeesPercentage?: SortOrder
    daysToStartAfterDelivery?: SortOrder
    lateInstallmentFeesPercentage?: SortOrder
    affiliatePercentage?: SortOrder
    creditLateFeesPercentage?: SortOrder
    creditLateDays?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numberOfAllowedCredits?: SortOrder
    fundFeesPercentage?: SortOrder
    fundId?: SortOrder
  }

  export type CreditConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shouldPayDeposit?: SortOrder
    depositPercentage?: SortOrder
    duration?: SortOrder
    slices?: SortOrder
    seviFeesPercentage?: SortOrder
    daysToStartAfterDelivery?: SortOrder
    lateInstallmentFeesPercentage?: SortOrder
    affiliatePercentage?: SortOrder
    creditLateFeesPercentage?: SortOrder
    creditLateDays?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    numberOfAllowedCredits?: SortOrder
    fundFeesPercentage?: SortOrder
    fundId?: SortOrder
  }

  export type CreditConfigurationSumOrderByAggregateInput = {
    depositPercentage?: SortOrder
    duration?: SortOrder
    seviFeesPercentage?: SortOrder
    daysToStartAfterDelivery?: SortOrder
    lateInstallmentFeesPercentage?: SortOrder
    affiliatePercentage?: SortOrder
    creditLateFeesPercentage?: SortOrder
    creditLateDays?: SortOrder
    numberOfAllowedCredits?: SortOrder
    fundFeesPercentage?: SortOrder
  }

  export type EnumCreditConfigurationStatusWithAggregatesFilter = {
    equals?: CreditConfigurationStatus
    in?: Enumerable<CreditConfigurationStatus>
    notIn?: Enumerable<CreditConfigurationStatus>
    not?: NestedEnumCreditConfigurationStatusWithAggregatesFilter | CreditConfigurationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumCreditConfigurationStatusFilter
    _max?: NestedEnumCreditConfigurationStatusFilter
  }

  export type CreditConfigurationsWalletsWalletIdConfigurationIdCompoundUniqueInput = {
    walletId: string
    configurationId: string
  }

  export type CreditConfigurationsWalletsCountOrderByAggregateInput = {
    configurationId?: SortOrder
    walletId?: SortOrder
    upfrontPercentage?: SortOrder
    fundFeesPercentage?: SortOrder
    maxOrderAmount?: SortOrder
    maxOutstandingCredit?: SortOrder
    shareFeesPercentage?: SortOrder
    postDeliveryPercentage?: SortOrder
  }

  export type CreditConfigurationsWalletsAvgOrderByAggregateInput = {
    upfrontPercentage?: SortOrder
    fundFeesPercentage?: SortOrder
    maxOrderAmount?: SortOrder
    maxOutstandingCredit?: SortOrder
    shareFeesPercentage?: SortOrder
    postDeliveryPercentage?: SortOrder
  }

  export type CreditConfigurationsWalletsMaxOrderByAggregateInput = {
    configurationId?: SortOrder
    walletId?: SortOrder
    upfrontPercentage?: SortOrder
    fundFeesPercentage?: SortOrder
    maxOrderAmount?: SortOrder
    maxOutstandingCredit?: SortOrder
    shareFeesPercentage?: SortOrder
    postDeliveryPercentage?: SortOrder
  }

  export type CreditConfigurationsWalletsMinOrderByAggregateInput = {
    configurationId?: SortOrder
    walletId?: SortOrder
    upfrontPercentage?: SortOrder
    fundFeesPercentage?: SortOrder
    maxOrderAmount?: SortOrder
    maxOutstandingCredit?: SortOrder
    shareFeesPercentage?: SortOrder
    postDeliveryPercentage?: SortOrder
  }

  export type CreditConfigurationsWalletsSumOrderByAggregateInput = {
    upfrontPercentage?: SortOrder
    fundFeesPercentage?: SortOrder
    maxOrderAmount?: SortOrder
    maxOutstandingCredit?: SortOrder
    shareFeesPercentage?: SortOrder
    postDeliveryPercentage?: SortOrder
  }

  export type OtherMemberKYCCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    documentId?: SortOrder
    documentCountry?: SortOrder
    documentData?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
    profilePictureURL?: SortOrder
    idCardURL?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
    userIdToKYC?: SortOrder
    OTP?: SortOrder
  }

  export type OtherMemberKYCMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    documentId?: SortOrder
    documentCountry?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
    profilePictureURL?: SortOrder
    idCardURL?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
    userIdToKYC?: SortOrder
    OTP?: SortOrder
  }

  export type OtherMemberKYCMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    documentId?: SortOrder
    documentCountry?: SortOrder
    documentFirstName?: SortOrder
    documentLastName?: SortOrder
    documentImage?: SortOrder
    documentGender?: SortOrder
    documentDateOfBirth?: SortOrder
    documentDateOfIssue?: SortOrder
    documentSerialNumber?: SortOrder
    documentCreatedAt?: SortOrder
    profilePictureURL?: SortOrder
    idCardURL?: SortOrder
    createdAt?: SortOrder
    createdByUserId?: SortOrder
    userIdToKYC?: SortOrder
    OTP?: SortOrder
  }

  export type SettingsCountOrderByAggregateInput = {
    woocommerceUrl?: SortOrder
    woocommerceConsumerKey?: SortOrder
    woocommerceActive?: SortOrder
    woocommerceConsumerSecret?: SortOrder
    walletAccount?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    woocommerceUrl?: SortOrder
    woocommerceConsumerKey?: SortOrder
    woocommerceActive?: SortOrder
    woocommerceConsumerSecret?: SortOrder
    walletAccount?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    woocommerceUrl?: SortOrder
    woocommerceConsumerKey?: SortOrder
    woocommerceActive?: SortOrder
    woocommerceConsumerSecret?: SortOrder
    walletAccount?: SortOrder
  }

  export type EnumTransactionMethodEnumFilter = {
    equals?: TransactionMethodEnum
    in?: Enumerable<TransactionMethodEnum>
    notIn?: Enumerable<TransactionMethodEnum>
    not?: NestedEnumTransactionMethodEnumFilter | TransactionMethodEnum
  }

  export type SettlementCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    account?: SortOrder
    bankAccount?: SortOrder
    bankAccountName?: SortOrder
    bankBranch?: SortOrder
    bankName?: SortOrder
    phoneNumber?: SortOrder
    tillNumber?: SortOrder
    paybillNumber?: SortOrder
    verified?: SortOrder
    verifiedByUser?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByAgent?: SortOrder
  }

  export type SettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    account?: SortOrder
    bankAccount?: SortOrder
    bankAccountName?: SortOrder
    bankBranch?: SortOrder
    bankName?: SortOrder
    phoneNumber?: SortOrder
    tillNumber?: SortOrder
    paybillNumber?: SortOrder
    verified?: SortOrder
    verifiedByUser?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByAgent?: SortOrder
  }

  export type SettlementMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    account?: SortOrder
    bankAccount?: SortOrder
    bankAccountName?: SortOrder
    bankBranch?: SortOrder
    bankName?: SortOrder
    phoneNumber?: SortOrder
    tillNumber?: SortOrder
    paybillNumber?: SortOrder
    verified?: SortOrder
    verifiedByUser?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    createdByAgent?: SortOrder
  }

  export type EnumTransactionMethodEnumWithAggregatesFilter = {
    equals?: TransactionMethodEnum
    in?: Enumerable<TransactionMethodEnum>
    notIn?: Enumerable<TransactionMethodEnum>
    not?: NestedEnumTransactionMethodEnumWithAggregatesFilter | TransactionMethodEnum
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionMethodEnumFilter
    _max?: NestedEnumTransactionMethodEnumFilter
  }

  export type EnumanswerTypeEnumFilter = {
    equals?: answerTypeEnum
    in?: Enumerable<answerTypeEnum>
    notIn?: Enumerable<answerTypeEnum>
    not?: NestedEnumanswerTypeEnumFilter | answerTypeEnum
  }

  export type EnumQuestionCategoryEnumFilter = {
    equals?: QuestionCategoryEnum
    in?: Enumerable<QuestionCategoryEnum>
    notIn?: Enumerable<QuestionCategoryEnum>
    not?: NestedEnumQuestionCategoryEnumFilter | QuestionCategoryEnum
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    answersType?: SortOrder
    category?: SortOrder
    question?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    answersType?: SortOrder
    category?: SortOrder
    question?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    answersType?: SortOrder
    category?: SortOrder
    question?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type EnumanswerTypeEnumWithAggregatesFilter = {
    equals?: answerTypeEnum
    in?: Enumerable<answerTypeEnum>
    notIn?: Enumerable<answerTypeEnum>
    not?: NestedEnumanswerTypeEnumWithAggregatesFilter | answerTypeEnum
    _count?: NestedIntFilter
    _min?: NestedEnumanswerTypeEnumFilter
    _max?: NestedEnumanswerTypeEnumFilter
  }

  export type EnumQuestionCategoryEnumWithAggregatesFilter = {
    equals?: QuestionCategoryEnum
    in?: Enumerable<QuestionCategoryEnum>
    notIn?: Enumerable<QuestionCategoryEnum>
    not?: NestedEnumQuestionCategoryEnumWithAggregatesFilter | QuestionCategoryEnum
    _count?: NestedIntFilter
    _min?: NestedEnumQuestionCategoryEnumFilter
    _max?: NestedEnumQuestionCategoryEnumFilter
  }

  export type QuestionRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type AnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    answer?: SortOrder
    answeredBy?: SortOrder
    answeredByReference?: SortOrder
    account?: SortOrder
  }

  export type AnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    answer?: SortOrder
    answeredBy?: SortOrder
    answeredByReference?: SortOrder
    account?: SortOrder
  }

  export type AnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    answer?: SortOrder
    answeredBy?: SortOrder
    answeredByReference?: SortOrder
    account?: SortOrder
  }

  export type EnumCreditRequestStatusFilter = {
    equals?: CreditRequestStatus
    in?: Enumerable<CreditRequestStatus>
    notIn?: Enumerable<CreditRequestStatus>
    not?: NestedEnumCreditRequestStatusFilter | CreditRequestStatus
  }

  export type CreditRequestOrderIdUserIdCompoundUniqueInput = {
    orderId: string
    userId: string
  }

  export type CreditRequestCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    orderId?: SortOrder
    wallet?: SortOrder
    creditConfigurationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    proceedAt?: SortOrder
  }

  export type CreditRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    orderId?: SortOrder
    wallet?: SortOrder
    creditConfigurationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    proceedAt?: SortOrder
  }

  export type CreditRequestMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    orderId?: SortOrder
    wallet?: SortOrder
    creditConfigurationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    proceedAt?: SortOrder
  }

  export type EnumCreditRequestStatusWithAggregatesFilter = {
    equals?: CreditRequestStatus
    in?: Enumerable<CreditRequestStatus>
    notIn?: Enumerable<CreditRequestStatus>
    not?: NestedEnumCreditRequestStatusWithAggregatesFilter | CreditRequestStatus
    _count?: NestedIntFilter
    _min?: NestedEnumCreditRequestStatusFilter
    _max?: NestedEnumCreditRequestStatusFilter
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutUserInput>, Enumerable<ActivityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutUserInput>
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: Enumerable<ActivityWhereUniqueInput>
  }

  export type AnswerCreateNestedManyWithoutAnsweredInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutAnsweredInput>, Enumerable<AnswerUncheckedCreateWithoutAnsweredInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutAnsweredInput>
    createMany?: AnswerCreateManyAnsweredInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type CreditCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<CreditCreateWithoutAffiliateInput>, Enumerable<CreditUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutAffiliateInput>
    createMany?: CreditCreateManyAffiliateInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type CreditCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CreditCreateWithoutUserInput>, Enumerable<CreditUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutUserInput>
    createMany?: CreditCreateManyUserInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type InstallmentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutUserInput>, Enumerable<InstallmentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutUserInput>
    createMany?: InstallmentCreateManyUserInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type LoginCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LoginCreateWithoutUserInput>, Enumerable<LoginUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoginCreateOrConnectWithoutUserInput>
    createMany?: LoginCreateManyUserInputEnvelope
    connect?: Enumerable<LoginWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAffiliateInput>, Enumerable<OrderUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAffiliateInput>
    createMany?: OrderCreateManyAffiliateInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OtherMemberKYCCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<OtherMemberKYCCreateWithoutCreatedByInput>, Enumerable<OtherMemberKYCUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<OtherMemberKYCCreateOrConnectWithoutCreatedByInput>
    createMany?: OtherMemberKYCCreateManyCreatedByInputEnvelope
    connect?: Enumerable<OtherMemberKYCWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<ProductCreateWithoutAffiliateInput>, Enumerable<ProductUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutAffiliateInput>
    createMany?: ProductCreateManyAffiliateInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type SettlementCreateNestedManyWithoutSettlementCreatorInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutSettlementCreatorInput>, Enumerable<SettlementUncheckedCreateWithoutSettlementCreatorInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutSettlementCreatorInput>
    createMany?: SettlementCreateManySettlementCreatorInputEnvelope
    connect?: Enumerable<SettlementWhereUniqueInput>
  }

  export type UsersWalletsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UsersWalletsCreateWithoutUserInput>, Enumerable<UsersWalletsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsersWalletsCreateOrConnectWithoutUserInput>
    createMany?: UsersWalletsCreateManyUserInputEnvelope
    connect?: Enumerable<UsersWalletsWhereUniqueInput>
  }

  export type VerifyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<VerifyCreateWithoutUserInput>, Enumerable<VerifyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<VerifyCreateOrConnectWithoutUserInput>
    createMany?: VerifyCreateManyUserInputEnvelope
    connect?: Enumerable<VerifyWhereUniqueInput>
  }

  export type VisitCreateNestedManyWithoutVisitedInput = {
    create?: XOR<Enumerable<VisitCreateWithoutVisitedInput>, Enumerable<VisitUncheckedCreateWithoutVisitedInput>>
    connectOrCreate?: Enumerable<VisitCreateOrConnectWithoutVisitedInput>
    createMany?: VisitCreateManyVisitedInputEnvelope
    connect?: Enumerable<VisitWhereUniqueInput>
  }

  export type WalletCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<WalletCreateWithoutUsersInput>, Enumerable<WalletUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<WalletWhereUniqueInput>
  }

  export type SettlementCreateNestedManyWithoutSettlementVerifierInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutSettlementVerifierInput>, Enumerable<SettlementUncheckedCreateWithoutSettlementVerifierInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutSettlementVerifierInput>
    createMany?: SettlementCreateManySettlementVerifierInputEnvelope
    connect?: Enumerable<SettlementWhereUniqueInput>
  }

  export type CreditRequestCreateNestedOneWithoutUserInput = {
    create?: XOR<CreditRequestCreateWithoutUserInput, CreditRequestUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutUserInput
    connect?: CreditRequestWhereUniqueInput
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutUserInput>, Enumerable<ActivityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutUserInput>
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: Enumerable<ActivityWhereUniqueInput>
  }

  export type AnswerUncheckedCreateNestedManyWithoutAnsweredInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutAnsweredInput>, Enumerable<AnswerUncheckedCreateWithoutAnsweredInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutAnsweredInput>
    createMany?: AnswerCreateManyAnsweredInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type CreditUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<CreditCreateWithoutAffiliateInput>, Enumerable<CreditUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutAffiliateInput>
    createMany?: CreditCreateManyAffiliateInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type CreditUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CreditCreateWithoutUserInput>, Enumerable<CreditUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutUserInput>
    createMany?: CreditCreateManyUserInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type InstallmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutUserInput>, Enumerable<InstallmentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutUserInput>
    createMany?: InstallmentCreateManyUserInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type LoginUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LoginCreateWithoutUserInput>, Enumerable<LoginUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoginCreateOrConnectWithoutUserInput>
    createMany?: LoginCreateManyUserInputEnvelope
    connect?: Enumerable<LoginWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAffiliateInput>, Enumerable<OrderUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAffiliateInput>
    createMany?: OrderCreateManyAffiliateInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<OtherMemberKYCCreateWithoutCreatedByInput>, Enumerable<OtherMemberKYCUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<OtherMemberKYCCreateOrConnectWithoutCreatedByInput>
    createMany?: OtherMemberKYCCreateManyCreatedByInputEnvelope
    connect?: Enumerable<OtherMemberKYCWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<ProductCreateWithoutAffiliateInput>, Enumerable<ProductUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutAffiliateInput>
    createMany?: ProductCreateManyAffiliateInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutSettlementCreatorInput>, Enumerable<SettlementUncheckedCreateWithoutSettlementCreatorInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutSettlementCreatorInput>
    createMany?: SettlementCreateManySettlementCreatorInputEnvelope
    connect?: Enumerable<SettlementWhereUniqueInput>
  }

  export type UsersWalletsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UsersWalletsCreateWithoutUserInput>, Enumerable<UsersWalletsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsersWalletsCreateOrConnectWithoutUserInput>
    createMany?: UsersWalletsCreateManyUserInputEnvelope
    connect?: Enumerable<UsersWalletsWhereUniqueInput>
  }

  export type VerifyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<VerifyCreateWithoutUserInput>, Enumerable<VerifyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<VerifyCreateOrConnectWithoutUserInput>
    createMany?: VerifyCreateManyUserInputEnvelope
    connect?: Enumerable<VerifyWhereUniqueInput>
  }

  export type VisitUncheckedCreateNestedManyWithoutVisitedInput = {
    create?: XOR<Enumerable<VisitCreateWithoutVisitedInput>, Enumerable<VisitUncheckedCreateWithoutVisitedInput>>
    connectOrCreate?: Enumerable<VisitCreateOrConnectWithoutVisitedInput>
    createMany?: VisitCreateManyVisitedInputEnvelope
    connect?: Enumerable<VisitWhereUniqueInput>
  }

  export type WalletUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<WalletCreateWithoutUsersInput>, Enumerable<WalletUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<WalletWhereUniqueInput>
  }

  export type SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutSettlementVerifierInput>, Enumerable<SettlementUncheckedCreateWithoutSettlementVerifierInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutSettlementVerifierInput>
    createMany?: SettlementCreateManySettlementVerifierInputEnvelope
    connect?: Enumerable<SettlementWhereUniqueInput>
  }

  export type CreditRequestUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CreditRequestCreateWithoutUserInput, CreditRequestUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutUserInput
    connect?: CreditRequestWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumCountryCodeFieldUpdateOperationsInput = {
    set?: CountryCode | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumGenderEnumFieldUpdateOperationsInput = {
    set?: GenderEnum | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ActivityUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutUserInput>, Enumerable<ActivityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ActivityUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: Enumerable<ActivityWhereUniqueInput>
    disconnect?: Enumerable<ActivityWhereUniqueInput>
    delete?: Enumerable<ActivityWhereUniqueInput>
    connect?: Enumerable<ActivityWhereUniqueInput>
    update?: Enumerable<ActivityUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ActivityUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ActivityScalarWhereInput>
  }

  export type AnswerUpdateManyWithoutAnsweredInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutAnsweredInput>, Enumerable<AnswerUncheckedCreateWithoutAnsweredInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutAnsweredInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutAnsweredInput>
    createMany?: AnswerCreateManyAnsweredInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutAnsweredInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutAnsweredInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type CreditUpdateManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<CreditCreateWithoutAffiliateInput>, Enumerable<CreditUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutAffiliateInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutAffiliateInput>
    createMany?: CreditCreateManyAffiliateInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutAffiliateInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutAffiliateInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type CreditUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CreditCreateWithoutUserInput>, Enumerable<CreditUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CreditCreateManyUserInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type InstallmentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutUserInput>, Enumerable<InstallmentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InstallmentCreateManyUserInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type LoginUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<LoginCreateWithoutUserInput>, Enumerable<LoginUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoginCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LoginUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LoginCreateManyUserInputEnvelope
    set?: Enumerable<LoginWhereUniqueInput>
    disconnect?: Enumerable<LoginWhereUniqueInput>
    delete?: Enumerable<LoginWhereUniqueInput>
    connect?: Enumerable<LoginWhereUniqueInput>
    update?: Enumerable<LoginUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LoginUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LoginScalarWhereInput>
  }

  export type OrderUpdateManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAffiliateInput>, Enumerable<OrderUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAffiliateInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutAffiliateInput>
    createMany?: OrderCreateManyAffiliateInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutAffiliateInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutAffiliateInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OtherMemberKYCUpdateManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<OtherMemberKYCCreateWithoutCreatedByInput>, Enumerable<OtherMemberKYCUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<OtherMemberKYCCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<OtherMemberKYCUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: OtherMemberKYCCreateManyCreatedByInputEnvelope
    set?: Enumerable<OtherMemberKYCWhereUniqueInput>
    disconnect?: Enumerable<OtherMemberKYCWhereUniqueInput>
    delete?: Enumerable<OtherMemberKYCWhereUniqueInput>
    connect?: Enumerable<OtherMemberKYCWhereUniqueInput>
    update?: Enumerable<OtherMemberKYCUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<OtherMemberKYCUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<OtherMemberKYCScalarWhereInput>
  }

  export type ProductUpdateManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<ProductCreateWithoutAffiliateInput>, Enumerable<ProductUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutAffiliateInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutAffiliateInput>
    createMany?: ProductCreateManyAffiliateInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutAffiliateInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutAffiliateInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type SettlementUpdateManyWithoutSettlementCreatorInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutSettlementCreatorInput>, Enumerable<SettlementUncheckedCreateWithoutSettlementCreatorInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutSettlementCreatorInput>
    upsert?: Enumerable<SettlementUpsertWithWhereUniqueWithoutSettlementCreatorInput>
    createMany?: SettlementCreateManySettlementCreatorInputEnvelope
    set?: Enumerable<SettlementWhereUniqueInput>
    disconnect?: Enumerable<SettlementWhereUniqueInput>
    delete?: Enumerable<SettlementWhereUniqueInput>
    connect?: Enumerable<SettlementWhereUniqueInput>
    update?: Enumerable<SettlementUpdateWithWhereUniqueWithoutSettlementCreatorInput>
    updateMany?: Enumerable<SettlementUpdateManyWithWhereWithoutSettlementCreatorInput>
    deleteMany?: Enumerable<SettlementScalarWhereInput>
  }

  export type UsersWalletsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UsersWalletsCreateWithoutUserInput>, Enumerable<UsersWalletsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsersWalletsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UsersWalletsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UsersWalletsCreateManyUserInputEnvelope
    set?: Enumerable<UsersWalletsWhereUniqueInput>
    disconnect?: Enumerable<UsersWalletsWhereUniqueInput>
    delete?: Enumerable<UsersWalletsWhereUniqueInput>
    connect?: Enumerable<UsersWalletsWhereUniqueInput>
    update?: Enumerable<UsersWalletsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UsersWalletsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UsersWalletsScalarWhereInput>
  }

  export type VerifyUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<VerifyCreateWithoutUserInput>, Enumerable<VerifyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<VerifyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<VerifyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: VerifyCreateManyUserInputEnvelope
    set?: Enumerable<VerifyWhereUniqueInput>
    disconnect?: Enumerable<VerifyWhereUniqueInput>
    delete?: Enumerable<VerifyWhereUniqueInput>
    connect?: Enumerable<VerifyWhereUniqueInput>
    update?: Enumerable<VerifyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<VerifyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<VerifyScalarWhereInput>
  }

  export type VisitUpdateManyWithoutVisitedInput = {
    create?: XOR<Enumerable<VisitCreateWithoutVisitedInput>, Enumerable<VisitUncheckedCreateWithoutVisitedInput>>
    connectOrCreate?: Enumerable<VisitCreateOrConnectWithoutVisitedInput>
    upsert?: Enumerable<VisitUpsertWithWhereUniqueWithoutVisitedInput>
    createMany?: VisitCreateManyVisitedInputEnvelope
    set?: Enumerable<VisitWhereUniqueInput>
    disconnect?: Enumerable<VisitWhereUniqueInput>
    delete?: Enumerable<VisitWhereUniqueInput>
    connect?: Enumerable<VisitWhereUniqueInput>
    update?: Enumerable<VisitUpdateWithWhereUniqueWithoutVisitedInput>
    updateMany?: Enumerable<VisitUpdateManyWithWhereWithoutVisitedInput>
    deleteMany?: Enumerable<VisitScalarWhereInput>
  }

  export type WalletUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<WalletCreateWithoutUsersInput>, Enumerable<WalletUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<WalletUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<WalletWhereUniqueInput>
    disconnect?: Enumerable<WalletWhereUniqueInput>
    delete?: Enumerable<WalletWhereUniqueInput>
    connect?: Enumerable<WalletWhereUniqueInput>
    update?: Enumerable<WalletUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<WalletUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<WalletScalarWhereInput>
  }

  export type SettlementUpdateManyWithoutSettlementVerifierInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutSettlementVerifierInput>, Enumerable<SettlementUncheckedCreateWithoutSettlementVerifierInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutSettlementVerifierInput>
    upsert?: Enumerable<SettlementUpsertWithWhereUniqueWithoutSettlementVerifierInput>
    createMany?: SettlementCreateManySettlementVerifierInputEnvelope
    set?: Enumerable<SettlementWhereUniqueInput>
    disconnect?: Enumerable<SettlementWhereUniqueInput>
    delete?: Enumerable<SettlementWhereUniqueInput>
    connect?: Enumerable<SettlementWhereUniqueInput>
    update?: Enumerable<SettlementUpdateWithWhereUniqueWithoutSettlementVerifierInput>
    updateMany?: Enumerable<SettlementUpdateManyWithWhereWithoutSettlementVerifierInput>
    deleteMany?: Enumerable<SettlementScalarWhereInput>
  }

  export type CreditRequestUpdateOneWithoutUserInput = {
    create?: XOR<CreditRequestCreateWithoutUserInput, CreditRequestUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutUserInput
    upsert?: CreditRequestUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditRequestWhereUniqueInput
    update?: XOR<CreditRequestUpdateWithoutUserInput, CreditRequestUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutUserInput>, Enumerable<ActivityUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ActivityUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: Enumerable<ActivityWhereUniqueInput>
    disconnect?: Enumerable<ActivityWhereUniqueInput>
    delete?: Enumerable<ActivityWhereUniqueInput>
    connect?: Enumerable<ActivityWhereUniqueInput>
    update?: Enumerable<ActivityUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ActivityUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ActivityScalarWhereInput>
  }

  export type AnswerUncheckedUpdateManyWithoutAnsweredInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutAnsweredInput>, Enumerable<AnswerUncheckedCreateWithoutAnsweredInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutAnsweredInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutAnsweredInput>
    createMany?: AnswerCreateManyAnsweredInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutAnsweredInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutAnsweredInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type CreditUncheckedUpdateManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<CreditCreateWithoutAffiliateInput>, Enumerable<CreditUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutAffiliateInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutAffiliateInput>
    createMany?: CreditCreateManyAffiliateInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutAffiliateInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutAffiliateInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type CreditUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CreditCreateWithoutUserInput>, Enumerable<CreditUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CreditCreateManyUserInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type InstallmentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutUserInput>, Enumerable<InstallmentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InstallmentCreateManyUserInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type LoginUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<LoginCreateWithoutUserInput>, Enumerable<LoginUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoginCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LoginUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LoginCreateManyUserInputEnvelope
    set?: Enumerable<LoginWhereUniqueInput>
    disconnect?: Enumerable<LoginWhereUniqueInput>
    delete?: Enumerable<LoginWhereUniqueInput>
    connect?: Enumerable<LoginWhereUniqueInput>
    update?: Enumerable<LoginUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LoginUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LoginScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<OrderCreateWithoutAffiliateInput>, Enumerable<OrderUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutAffiliateInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutAffiliateInput>
    createMany?: OrderCreateManyAffiliateInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutAffiliateInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutAffiliateInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<OtherMemberKYCCreateWithoutCreatedByInput>, Enumerable<OtherMemberKYCUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<OtherMemberKYCCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<OtherMemberKYCUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: OtherMemberKYCCreateManyCreatedByInputEnvelope
    set?: Enumerable<OtherMemberKYCWhereUniqueInput>
    disconnect?: Enumerable<OtherMemberKYCWhereUniqueInput>
    delete?: Enumerable<OtherMemberKYCWhereUniqueInput>
    connect?: Enumerable<OtherMemberKYCWhereUniqueInput>
    update?: Enumerable<OtherMemberKYCUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<OtherMemberKYCUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<OtherMemberKYCScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutAffiliateInput = {
    create?: XOR<Enumerable<ProductCreateWithoutAffiliateInput>, Enumerable<ProductUncheckedCreateWithoutAffiliateInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutAffiliateInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutAffiliateInput>
    createMany?: ProductCreateManyAffiliateInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutAffiliateInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutAffiliateInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type SettlementUncheckedUpdateManyWithoutSettlementCreatorInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutSettlementCreatorInput>, Enumerable<SettlementUncheckedCreateWithoutSettlementCreatorInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutSettlementCreatorInput>
    upsert?: Enumerable<SettlementUpsertWithWhereUniqueWithoutSettlementCreatorInput>
    createMany?: SettlementCreateManySettlementCreatorInputEnvelope
    set?: Enumerable<SettlementWhereUniqueInput>
    disconnect?: Enumerable<SettlementWhereUniqueInput>
    delete?: Enumerable<SettlementWhereUniqueInput>
    connect?: Enumerable<SettlementWhereUniqueInput>
    update?: Enumerable<SettlementUpdateWithWhereUniqueWithoutSettlementCreatorInput>
    updateMany?: Enumerable<SettlementUpdateManyWithWhereWithoutSettlementCreatorInput>
    deleteMany?: Enumerable<SettlementScalarWhereInput>
  }

  export type UsersWalletsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UsersWalletsCreateWithoutUserInput>, Enumerable<UsersWalletsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UsersWalletsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UsersWalletsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UsersWalletsCreateManyUserInputEnvelope
    set?: Enumerable<UsersWalletsWhereUniqueInput>
    disconnect?: Enumerable<UsersWalletsWhereUniqueInput>
    delete?: Enumerable<UsersWalletsWhereUniqueInput>
    connect?: Enumerable<UsersWalletsWhereUniqueInput>
    update?: Enumerable<UsersWalletsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UsersWalletsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UsersWalletsScalarWhereInput>
  }

  export type VerifyUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<VerifyCreateWithoutUserInput>, Enumerable<VerifyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<VerifyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<VerifyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: VerifyCreateManyUserInputEnvelope
    set?: Enumerable<VerifyWhereUniqueInput>
    disconnect?: Enumerable<VerifyWhereUniqueInput>
    delete?: Enumerable<VerifyWhereUniqueInput>
    connect?: Enumerable<VerifyWhereUniqueInput>
    update?: Enumerable<VerifyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<VerifyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<VerifyScalarWhereInput>
  }

  export type VisitUncheckedUpdateManyWithoutVisitedInput = {
    create?: XOR<Enumerable<VisitCreateWithoutVisitedInput>, Enumerable<VisitUncheckedCreateWithoutVisitedInput>>
    connectOrCreate?: Enumerable<VisitCreateOrConnectWithoutVisitedInput>
    upsert?: Enumerable<VisitUpsertWithWhereUniqueWithoutVisitedInput>
    createMany?: VisitCreateManyVisitedInputEnvelope
    set?: Enumerable<VisitWhereUniqueInput>
    disconnect?: Enumerable<VisitWhereUniqueInput>
    delete?: Enumerable<VisitWhereUniqueInput>
    connect?: Enumerable<VisitWhereUniqueInput>
    update?: Enumerable<VisitUpdateWithWhereUniqueWithoutVisitedInput>
    updateMany?: Enumerable<VisitUpdateManyWithWhereWithoutVisitedInput>
    deleteMany?: Enumerable<VisitScalarWhereInput>
  }

  export type WalletUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<WalletCreateWithoutUsersInput>, Enumerable<WalletUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<WalletUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<WalletWhereUniqueInput>
    disconnect?: Enumerable<WalletWhereUniqueInput>
    delete?: Enumerable<WalletWhereUniqueInput>
    connect?: Enumerable<WalletWhereUniqueInput>
    update?: Enumerable<WalletUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<WalletUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<WalletScalarWhereInput>
  }

  export type SettlementUncheckedUpdateManyWithoutSettlementVerifierInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutSettlementVerifierInput>, Enumerable<SettlementUncheckedCreateWithoutSettlementVerifierInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutSettlementVerifierInput>
    upsert?: Enumerable<SettlementUpsertWithWhereUniqueWithoutSettlementVerifierInput>
    createMany?: SettlementCreateManySettlementVerifierInputEnvelope
    set?: Enumerable<SettlementWhereUniqueInput>
    disconnect?: Enumerable<SettlementWhereUniqueInput>
    delete?: Enumerable<SettlementWhereUniqueInput>
    connect?: Enumerable<SettlementWhereUniqueInput>
    update?: Enumerable<SettlementUpdateWithWhereUniqueWithoutSettlementVerifierInput>
    updateMany?: Enumerable<SettlementUpdateManyWithWhereWithoutSettlementVerifierInput>
    deleteMany?: Enumerable<SettlementScalarWhereInput>
  }

  export type CreditRequestUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<CreditRequestCreateWithoutUserInput, CreditRequestUncheckedCreateWithoutUserInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutUserInput
    upsert?: CreditRequestUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditRequestWhereUniqueInput
    update?: XOR<CreditRequestUpdateWithoutUserInput, CreditRequestUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUsersWalletsInput = {
    create?: XOR<UserCreateWithoutUsersWalletsInput, UserUncheckedCreateWithoutUsersWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersWalletsInput
    connect?: UserWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutUsersWalletsInput = {
    create?: XOR<WalletCreateWithoutUsersWalletsInput, WalletUncheckedCreateWithoutUsersWalletsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUsersWalletsInput
    connect?: WalletWhereUniqueInput
  }

  export type EnumWalletRoleFieldUpdateOperationsInput = {
    set?: WalletRole
  }

  export type UserUpdateOneRequiredWithoutUsersWalletsInput = {
    create?: XOR<UserCreateWithoutUsersWalletsInput, UserUncheckedCreateWithoutUsersWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersWalletsInput
    upsert?: UserUpsertWithoutUsersWalletsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUsersWalletsInput, UserUncheckedUpdateWithoutUsersWalletsInput>
  }

  export type WalletUpdateOneRequiredWithoutUsersWalletsInput = {
    create?: XOR<WalletCreateWithoutUsersWalletsInput, WalletUncheckedCreateWithoutUsersWalletsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUsersWalletsInput
    upsert?: WalletUpsertWithoutUsersWalletsInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutUsersWalletsInput, WalletUncheckedUpdateWithoutUsersWalletsInput>
  }

  export type WalletCreateNestedOneWithoutCustomerInput = {
    create?: XOR<WalletCreateWithoutCustomerInput, WalletUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: WalletCreateOrConnectWithoutCustomerInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutVendorInput = {
    create?: XOR<WalletCreateWithoutVendorInput, WalletUncheckedCreateWithoutVendorInput>
    connectOrCreate?: WalletCreateOrConnectWithoutVendorInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutCustomerInput = {
    create?: XOR<WalletCreateWithoutCustomerInput, WalletUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: WalletCreateOrConnectWithoutCustomerInput
    upsert?: WalletUpsertWithoutCustomerInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutCustomerInput, WalletUncheckedUpdateWithoutCustomerInput>
  }

  export type WalletUpdateOneRequiredWithoutVendorInput = {
    create?: XOR<WalletCreateWithoutVendorInput, WalletUncheckedCreateWithoutVendorInput>
    connectOrCreate?: WalletCreateOrConnectWithoutVendorInput
    upsert?: WalletUpsertWithoutVendorInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutVendorInput, WalletUncheckedUpdateWithoutVendorInput>
  }

  export type WalletCreateNestedOneWithoutSupplierInput = {
    create?: XOR<WalletCreateWithoutSupplierInput, WalletUncheckedCreateWithoutSupplierInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSupplierInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutVendorSupplierInput = {
    create?: XOR<WalletCreateWithoutVendorSupplierInput, WalletUncheckedCreateWithoutVendorSupplierInput>
    connectOrCreate?: WalletCreateOrConnectWithoutVendorSupplierInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutSupplierInput = {
    create?: XOR<WalletCreateWithoutSupplierInput, WalletUncheckedCreateWithoutSupplierInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSupplierInput
    upsert?: WalletUpsertWithoutSupplierInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutSupplierInput, WalletUncheckedUpdateWithoutSupplierInput>
  }

  export type WalletUpdateOneRequiredWithoutVendorSupplierInput = {
    create?: XOR<WalletCreateWithoutVendorSupplierInput, WalletUncheckedCreateWithoutVendorSupplierInput>
    connectOrCreate?: WalletCreateOrConnectWithoutVendorSupplierInput
    upsert?: WalletUpsertWithoutVendorSupplierInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutVendorSupplierInput, WalletUncheckedUpdateWithoutVendorSupplierInput>
  }

  export type WalletCreateNestedOneWithoutBadgesInput = {
    create?: XOR<WalletCreateWithoutBadgesInput, WalletUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: WalletCreateOrConnectWithoutBadgesInput
    connect?: WalletWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumBadgeTypeFieldUpdateOperationsInput = {
    set?: BadgeType | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WalletUpdateOneRequiredWithoutBadgesInput = {
    create?: XOR<WalletCreateWithoutBadgesInput, WalletUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: WalletCreateOrConnectWithoutBadgesInput
    upsert?: WalletUpsertWithoutBadgesInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutBadgesInput, WalletUncheckedUpdateWithoutBadgesInput>
  }

  export type SettlementCreateNestedOneWithoutWalletInput = {
    create?: XOR<SettlementCreateWithoutWalletInput, SettlementUncheckedCreateWithoutWalletInput>
    connectOrCreate?: SettlementCreateOrConnectWithoutWalletInput
    connect?: SettlementWhereUniqueInput
  }

  export type AnswerCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutWalletInput>, Enumerable<AnswerUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutWalletInput>
    createMany?: AnswerCreateManyWalletInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type BadgeCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<BadgeCreateWithoutWalletInput>, Enumerable<BadgeUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<BadgeCreateOrConnectWithoutWalletInput>
    createMany?: BadgeCreateManyWalletInputEnvelope
    connect?: Enumerable<BadgeWhereUniqueInput>
  }

  export type BillingCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<BillingCreateWithoutWalletInput>, Enumerable<BillingUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<BillingCreateOrConnectWithoutWalletInput>
    createMany?: BillingCreateManyWalletInputEnvelope
    connect?: Enumerable<BillingWhereUniqueInput>
  }

  export type CreditCreateNestedManyWithoutCreditorInput = {
    create?: XOR<Enumerable<CreditCreateWithoutCreditorInput>, Enumerable<CreditUncheckedCreateWithoutCreditorInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutCreditorInput>
    createMany?: CreditCreateManyCreditorInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type CreditCreateNestedManyWithoutDebtorInput = {
    create?: XOR<Enumerable<CreditCreateWithoutDebtorInput>, Enumerable<CreditUncheckedCreateWithoutDebtorInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutDebtorInput>
    createMany?: CreditCreateManyDebtorInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type CreditConfigurationCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<CreditConfigurationCreateWithoutWalletInput>, Enumerable<CreditConfigurationUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<CreditConfigurationCreateOrConnectWithoutWalletInput>
    createMany?: CreditConfigurationCreateManyWalletInputEnvelope
    connect?: Enumerable<CreditConfigurationWhereUniqueInput>
  }

  export type CustomerCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutCustomerInput>, Enumerable<CustomerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerWhereUniqueInput>
  }

  export type CustomerCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutVendorInput>, Enumerable<CustomerUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutVendorInput>
    createMany?: CustomerCreateManyVendorInputEnvelope
    connect?: Enumerable<CustomerWhereUniqueInput>
  }

  export type InstallmentCreateNestedManyWithoutCreditorInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditorInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditorInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditorInput>
    createMany?: InstallmentCreateManyCreditorInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type InstallmentCreateNestedManyWithoutDebtorInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutDebtorInput>, Enumerable<InstallmentUncheckedCreateWithoutDebtorInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutDebtorInput>
    createMany?: InstallmentCreateManyDebtorInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type MetaDataCreateNestedOneWithoutWalletInput = {
    create?: XOR<MetaDataCreateWithoutWalletInput, MetaDataUncheckedCreateWithoutWalletInput>
    connectOrCreate?: MetaDataCreateOrConnectWithoutWalletInput
    connect?: MetaDataWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutVendorWalletInput = {
    create?: XOR<Enumerable<OrderCreateWithoutVendorWalletInput>, Enumerable<OrderUncheckedCreateWithoutVendorWalletInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutVendorWalletInput>
    createMany?: OrderCreateManyVendorWalletInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutVendorWalletInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVendorWalletInput>, Enumerable<ProductUncheckedCreateWithoutVendorWalletInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVendorWalletInput>
    createMany?: ProductCreateManyVendorWalletInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type SettingsCreateNestedOneWithoutWalletInput = {
    create?: XOR<SettingsCreateWithoutWalletInput, SettingsUncheckedCreateWithoutWalletInput>
    connectOrCreate?: SettingsCreateOrConnectWithoutWalletInput
    connect?: SettingsWhereUniqueInput
  }

  export type SettlementCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutWalletInput>, Enumerable<SettlementUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutWalletInput>
    createMany?: SettlementCreateManyWalletInputEnvelope
    connect?: Enumerable<SettlementWhereUniqueInput>
  }

  export type ShippingCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<ShippingCreateWithoutWalletInput>, Enumerable<ShippingUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<ShippingCreateOrConnectWithoutWalletInput>
    createMany?: ShippingCreateManyWalletInputEnvelope
    connect?: Enumerable<ShippingWhereUniqueInput>
  }

  export type SupplierCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<SupplierCreateWithoutSupplierInput>, Enumerable<SupplierUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<SupplierCreateOrConnectWithoutSupplierInput>
    createMany?: SupplierCreateManySupplierInputEnvelope
    connect?: Enumerable<SupplierWhereUniqueInput>
  }

  export type SupplierCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<SupplierCreateWithoutVendorInput>, Enumerable<SupplierUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<SupplierCreateOrConnectWithoutVendorInput>
    createMany?: SupplierCreateManyVendorInputEnvelope
    connect?: Enumerable<SupplierWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutWalletInput>, Enumerable<TransactionUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutWalletInput>
    createMany?: TransactionCreateManyWalletInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type UsersWalletsCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<UsersWalletsCreateWithoutWalletInput>, Enumerable<UsersWalletsUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<UsersWalletsCreateOrConnectWithoutWalletInput>
    createMany?: UsersWalletsCreateManyWalletInputEnvelope
    connect?: Enumerable<UsersWalletsWhereUniqueInput>
  }

  export type VisitCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<VisitCreateWithoutWalletInput>, Enumerable<VisitUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<VisitCreateOrConnectWithoutWalletInput>
    createMany?: VisitCreateManyWalletInputEnvelope
    connect?: Enumerable<VisitWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutWalletsInput = {
    create?: XOR<Enumerable<UserCreateWithoutWalletsInput>, Enumerable<UserUncheckedCreateWithoutWalletsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWalletsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type TrustCreateNestedOneWithoutWalletInput = {
    create?: XOR<TrustCreateWithoutWalletInput, TrustUncheckedCreateWithoutWalletInput>
    connectOrCreate?: TrustCreateOrConnectWithoutWalletInput
    connect?: TrustWhereUniqueInput
  }

  export type AnswerUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutWalletInput>, Enumerable<AnswerUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutWalletInput>
    createMany?: AnswerCreateManyWalletInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type BadgeUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<BadgeCreateWithoutWalletInput>, Enumerable<BadgeUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<BadgeCreateOrConnectWithoutWalletInput>
    createMany?: BadgeCreateManyWalletInputEnvelope
    connect?: Enumerable<BadgeWhereUniqueInput>
  }

  export type BillingUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<BillingCreateWithoutWalletInput>, Enumerable<BillingUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<BillingCreateOrConnectWithoutWalletInput>
    createMany?: BillingCreateManyWalletInputEnvelope
    connect?: Enumerable<BillingWhereUniqueInput>
  }

  export type CreditUncheckedCreateNestedManyWithoutCreditorInput = {
    create?: XOR<Enumerable<CreditCreateWithoutCreditorInput>, Enumerable<CreditUncheckedCreateWithoutCreditorInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutCreditorInput>
    createMany?: CreditCreateManyCreditorInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type CreditUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<Enumerable<CreditCreateWithoutDebtorInput>, Enumerable<CreditUncheckedCreateWithoutDebtorInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutDebtorInput>
    createMany?: CreditCreateManyDebtorInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<CreditConfigurationCreateWithoutWalletInput>, Enumerable<CreditConfigurationUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<CreditConfigurationCreateOrConnectWithoutWalletInput>
    createMany?: CreditConfigurationCreateManyWalletInputEnvelope
    connect?: Enumerable<CreditConfigurationWhereUniqueInput>
  }

  export type CustomerUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutCustomerInput>, Enumerable<CustomerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerWhereUniqueInput>
  }

  export type CustomerUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutVendorInput>, Enumerable<CustomerUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutVendorInput>
    createMany?: CustomerCreateManyVendorInputEnvelope
    connect?: Enumerable<CustomerWhereUniqueInput>
  }

  export type InstallmentUncheckedCreateNestedManyWithoutCreditorInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditorInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditorInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditorInput>
    createMany?: InstallmentCreateManyCreditorInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type InstallmentUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutDebtorInput>, Enumerable<InstallmentUncheckedCreateWithoutDebtorInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutDebtorInput>
    createMany?: InstallmentCreateManyDebtorInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type MetaDataUncheckedCreateNestedOneWithoutWalletInput = {
    create?: XOR<MetaDataCreateWithoutWalletInput, MetaDataUncheckedCreateWithoutWalletInput>
    connectOrCreate?: MetaDataCreateOrConnectWithoutWalletInput
    connect?: MetaDataWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutVendorWalletInput = {
    create?: XOR<Enumerable<OrderCreateWithoutVendorWalletInput>, Enumerable<OrderUncheckedCreateWithoutVendorWalletInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutVendorWalletInput>
    createMany?: OrderCreateManyVendorWalletInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutVendorWalletInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVendorWalletInput>, Enumerable<ProductUncheckedCreateWithoutVendorWalletInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVendorWalletInput>
    createMany?: ProductCreateManyVendorWalletInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type SettingsUncheckedCreateNestedOneWithoutWalletInput = {
    create?: XOR<SettingsCreateWithoutWalletInput, SettingsUncheckedCreateWithoutWalletInput>
    connectOrCreate?: SettingsCreateOrConnectWithoutWalletInput
    connect?: SettingsWhereUniqueInput
  }

  export type SettlementUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutWalletInput>, Enumerable<SettlementUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutWalletInput>
    createMany?: SettlementCreateManyWalletInputEnvelope
    connect?: Enumerable<SettlementWhereUniqueInput>
  }

  export type ShippingUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<ShippingCreateWithoutWalletInput>, Enumerable<ShippingUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<ShippingCreateOrConnectWithoutWalletInput>
    createMany?: ShippingCreateManyWalletInputEnvelope
    connect?: Enumerable<ShippingWhereUniqueInput>
  }

  export type SupplierUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<Enumerable<SupplierCreateWithoutSupplierInput>, Enumerable<SupplierUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<SupplierCreateOrConnectWithoutSupplierInput>
    createMany?: SupplierCreateManySupplierInputEnvelope
    connect?: Enumerable<SupplierWhereUniqueInput>
  }

  export type SupplierUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<SupplierCreateWithoutVendorInput>, Enumerable<SupplierUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<SupplierCreateOrConnectWithoutVendorInput>
    createMany?: SupplierCreateManyVendorInputEnvelope
    connect?: Enumerable<SupplierWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutWalletInput>, Enumerable<TransactionUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutWalletInput>
    createMany?: TransactionCreateManyWalletInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type UsersWalletsUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<UsersWalletsCreateWithoutWalletInput>, Enumerable<UsersWalletsUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<UsersWalletsCreateOrConnectWithoutWalletInput>
    createMany?: UsersWalletsCreateManyWalletInputEnvelope
    connect?: Enumerable<UsersWalletsWhereUniqueInput>
  }

  export type VisitUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<VisitCreateWithoutWalletInput>, Enumerable<VisitUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<VisitCreateOrConnectWithoutWalletInput>
    createMany?: VisitCreateManyWalletInputEnvelope
    connect?: Enumerable<VisitWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutWalletsInput = {
    create?: XOR<Enumerable<UserCreateWithoutWalletsInput>, Enumerable<UserUncheckedCreateWithoutWalletsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWalletsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type TrustUncheckedCreateNestedOneWithoutWalletInput = {
    create?: XOR<TrustCreateWithoutWalletInput, TrustUncheckedCreateWithoutWalletInput>
    connectOrCreate?: TrustCreateOrConnectWithoutWalletInput
    connect?: TrustWhereUniqueInput
  }

  export type EnumWalletTypesEnumFieldUpdateOperationsInput = {
    set?: WalletTypesEnum
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumCurrencyEnumFieldUpdateOperationsInput = {
    set?: CurrencyEnum | null
  }

  export type SettlementUpdateOneWithoutWalletInput = {
    create?: XOR<SettlementCreateWithoutWalletInput, SettlementUncheckedCreateWithoutWalletInput>
    connectOrCreate?: SettlementCreateOrConnectWithoutWalletInput
    upsert?: SettlementUpsertWithoutWalletInput
    disconnect?: boolean
    delete?: boolean
    connect?: SettlementWhereUniqueInput
    update?: XOR<SettlementUpdateWithoutWalletInput, SettlementUncheckedUpdateWithoutWalletInput>
  }

  export type AnswerUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutWalletInput>, Enumerable<AnswerUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: AnswerCreateManyWalletInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type BadgeUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<BadgeCreateWithoutWalletInput>, Enumerable<BadgeUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<BadgeCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<BadgeUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: BadgeCreateManyWalletInputEnvelope
    set?: Enumerable<BadgeWhereUniqueInput>
    disconnect?: Enumerable<BadgeWhereUniqueInput>
    delete?: Enumerable<BadgeWhereUniqueInput>
    connect?: Enumerable<BadgeWhereUniqueInput>
    update?: Enumerable<BadgeUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<BadgeUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<BadgeScalarWhereInput>
  }

  export type BillingUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<BillingCreateWithoutWalletInput>, Enumerable<BillingUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<BillingCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<BillingUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: BillingCreateManyWalletInputEnvelope
    set?: Enumerable<BillingWhereUniqueInput>
    disconnect?: Enumerable<BillingWhereUniqueInput>
    delete?: Enumerable<BillingWhereUniqueInput>
    connect?: Enumerable<BillingWhereUniqueInput>
    update?: Enumerable<BillingUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<BillingUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<BillingScalarWhereInput>
  }

  export type CreditUpdateManyWithoutCreditorInput = {
    create?: XOR<Enumerable<CreditCreateWithoutCreditorInput>, Enumerable<CreditUncheckedCreateWithoutCreditorInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutCreditorInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutCreditorInput>
    createMany?: CreditCreateManyCreditorInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutCreditorInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutCreditorInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type CreditUpdateManyWithoutDebtorInput = {
    create?: XOR<Enumerable<CreditCreateWithoutDebtorInput>, Enumerable<CreditUncheckedCreateWithoutDebtorInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutDebtorInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutDebtorInput>
    createMany?: CreditCreateManyDebtorInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutDebtorInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutDebtorInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type CreditConfigurationUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<CreditConfigurationCreateWithoutWalletInput>, Enumerable<CreditConfigurationUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<CreditConfigurationCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<CreditConfigurationUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: CreditConfigurationCreateManyWalletInputEnvelope
    set?: Enumerable<CreditConfigurationWhereUniqueInput>
    disconnect?: Enumerable<CreditConfigurationWhereUniqueInput>
    delete?: Enumerable<CreditConfigurationWhereUniqueInput>
    connect?: Enumerable<CreditConfigurationWhereUniqueInput>
    update?: Enumerable<CreditConfigurationUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<CreditConfigurationUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<CreditConfigurationScalarWhereInput>
  }

  export type CustomerUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutCustomerInput>, Enumerable<CustomerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerWhereUniqueInput>
    disconnect?: Enumerable<CustomerWhereUniqueInput>
    delete?: Enumerable<CustomerWhereUniqueInput>
    connect?: Enumerable<CustomerWhereUniqueInput>
    update?: Enumerable<CustomerUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerScalarWhereInput>
  }

  export type CustomerUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutVendorInput>, Enumerable<CustomerUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<CustomerUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: CustomerCreateManyVendorInputEnvelope
    set?: Enumerable<CustomerWhereUniqueInput>
    disconnect?: Enumerable<CustomerWhereUniqueInput>
    delete?: Enumerable<CustomerWhereUniqueInput>
    connect?: Enumerable<CustomerWhereUniqueInput>
    update?: Enumerable<CustomerUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<CustomerUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<CustomerScalarWhereInput>
  }

  export type InstallmentUpdateManyWithoutCreditorInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditorInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditorInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditorInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutCreditorInput>
    createMany?: InstallmentCreateManyCreditorInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutCreditorInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutCreditorInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type InstallmentUpdateManyWithoutDebtorInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutDebtorInput>, Enumerable<InstallmentUncheckedCreateWithoutDebtorInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutDebtorInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutDebtorInput>
    createMany?: InstallmentCreateManyDebtorInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutDebtorInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutDebtorInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type MetaDataUpdateOneWithoutWalletInput = {
    create?: XOR<MetaDataCreateWithoutWalletInput, MetaDataUncheckedCreateWithoutWalletInput>
    connectOrCreate?: MetaDataCreateOrConnectWithoutWalletInput
    upsert?: MetaDataUpsertWithoutWalletInput
    disconnect?: boolean
    delete?: boolean
    connect?: MetaDataWhereUniqueInput
    update?: XOR<MetaDataUpdateWithoutWalletInput, MetaDataUncheckedUpdateWithoutWalletInput>
  }

  export type OrderUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUpdateManyWithoutVendorWalletInput = {
    create?: XOR<Enumerable<OrderCreateWithoutVendorWalletInput>, Enumerable<OrderUncheckedCreateWithoutVendorWalletInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutVendorWalletInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutVendorWalletInput>
    createMany?: OrderCreateManyVendorWalletInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutVendorWalletInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutVendorWalletInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ProductUpdateManyWithoutVendorWalletInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVendorWalletInput>, Enumerable<ProductUncheckedCreateWithoutVendorWalletInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVendorWalletInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutVendorWalletInput>
    createMany?: ProductCreateManyVendorWalletInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutVendorWalletInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutVendorWalletInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type SettingsUpdateOneWithoutWalletInput = {
    create?: XOR<SettingsCreateWithoutWalletInput, SettingsUncheckedCreateWithoutWalletInput>
    connectOrCreate?: SettingsCreateOrConnectWithoutWalletInput
    upsert?: SettingsUpsertWithoutWalletInput
    disconnect?: boolean
    delete?: boolean
    connect?: SettingsWhereUniqueInput
    update?: XOR<SettingsUpdateWithoutWalletInput, SettingsUncheckedUpdateWithoutWalletInput>
  }

  export type SettlementUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutWalletInput>, Enumerable<SettlementUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<SettlementUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: SettlementCreateManyWalletInputEnvelope
    set?: Enumerable<SettlementWhereUniqueInput>
    disconnect?: Enumerable<SettlementWhereUniqueInput>
    delete?: Enumerable<SettlementWhereUniqueInput>
    connect?: Enumerable<SettlementWhereUniqueInput>
    update?: Enumerable<SettlementUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<SettlementUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<SettlementScalarWhereInput>
  }

  export type ShippingUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<ShippingCreateWithoutWalletInput>, Enumerable<ShippingUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<ShippingCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<ShippingUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: ShippingCreateManyWalletInputEnvelope
    set?: Enumerable<ShippingWhereUniqueInput>
    disconnect?: Enumerable<ShippingWhereUniqueInput>
    delete?: Enumerable<ShippingWhereUniqueInput>
    connect?: Enumerable<ShippingWhereUniqueInput>
    update?: Enumerable<ShippingUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<ShippingUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<ShippingScalarWhereInput>
  }

  export type SupplierUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<SupplierCreateWithoutSupplierInput>, Enumerable<SupplierUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<SupplierCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<SupplierUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: SupplierCreateManySupplierInputEnvelope
    set?: Enumerable<SupplierWhereUniqueInput>
    disconnect?: Enumerable<SupplierWhereUniqueInput>
    delete?: Enumerable<SupplierWhereUniqueInput>
    connect?: Enumerable<SupplierWhereUniqueInput>
    update?: Enumerable<SupplierUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<SupplierUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<SupplierScalarWhereInput>
  }

  export type SupplierUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<SupplierCreateWithoutVendorInput>, Enumerable<SupplierUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<SupplierCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<SupplierUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: SupplierCreateManyVendorInputEnvelope
    set?: Enumerable<SupplierWhereUniqueInput>
    disconnect?: Enumerable<SupplierWhereUniqueInput>
    delete?: Enumerable<SupplierWhereUniqueInput>
    connect?: Enumerable<SupplierWhereUniqueInput>
    update?: Enumerable<SupplierUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<SupplierUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<SupplierScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutWalletInput>, Enumerable<TransactionUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: TransactionCreateManyWalletInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UsersWalletsUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<UsersWalletsCreateWithoutWalletInput>, Enumerable<UsersWalletsUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<UsersWalletsCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<UsersWalletsUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: UsersWalletsCreateManyWalletInputEnvelope
    set?: Enumerable<UsersWalletsWhereUniqueInput>
    disconnect?: Enumerable<UsersWalletsWhereUniqueInput>
    delete?: Enumerable<UsersWalletsWhereUniqueInput>
    connect?: Enumerable<UsersWalletsWhereUniqueInput>
    update?: Enumerable<UsersWalletsUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<UsersWalletsUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<UsersWalletsScalarWhereInput>
  }

  export type VisitUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<VisitCreateWithoutWalletInput>, Enumerable<VisitUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<VisitCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<VisitUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: VisitCreateManyWalletInputEnvelope
    set?: Enumerable<VisitWhereUniqueInput>
    disconnect?: Enumerable<VisitWhereUniqueInput>
    delete?: Enumerable<VisitWhereUniqueInput>
    connect?: Enumerable<VisitWhereUniqueInput>
    update?: Enumerable<VisitUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<VisitUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<VisitScalarWhereInput>
  }

  export type UserUpdateManyWithoutWalletsInput = {
    create?: XOR<Enumerable<UserCreateWithoutWalletsInput>, Enumerable<UserUncheckedCreateWithoutWalletsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWalletsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutWalletsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutWalletsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutWalletsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type TrustUpdateOneWithoutWalletInput = {
    create?: XOR<TrustCreateWithoutWalletInput, TrustUncheckedCreateWithoutWalletInput>
    connectOrCreate?: TrustCreateOrConnectWithoutWalletInput
    upsert?: TrustUpsertWithoutWalletInput
    disconnect?: boolean
    delete?: boolean
    connect?: TrustWhereUniqueInput
    update?: XOR<TrustUpdateWithoutWalletInput, TrustUncheckedUpdateWithoutWalletInput>
  }

  export type AnswerUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutWalletInput>, Enumerable<AnswerUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: AnswerCreateManyWalletInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type BadgeUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<BadgeCreateWithoutWalletInput>, Enumerable<BadgeUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<BadgeCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<BadgeUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: BadgeCreateManyWalletInputEnvelope
    set?: Enumerable<BadgeWhereUniqueInput>
    disconnect?: Enumerable<BadgeWhereUniqueInput>
    delete?: Enumerable<BadgeWhereUniqueInput>
    connect?: Enumerable<BadgeWhereUniqueInput>
    update?: Enumerable<BadgeUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<BadgeUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<BadgeScalarWhereInput>
  }

  export type BillingUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<BillingCreateWithoutWalletInput>, Enumerable<BillingUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<BillingCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<BillingUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: BillingCreateManyWalletInputEnvelope
    set?: Enumerable<BillingWhereUniqueInput>
    disconnect?: Enumerable<BillingWhereUniqueInput>
    delete?: Enumerable<BillingWhereUniqueInput>
    connect?: Enumerable<BillingWhereUniqueInput>
    update?: Enumerable<BillingUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<BillingUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<BillingScalarWhereInput>
  }

  export type CreditUncheckedUpdateManyWithoutCreditorInput = {
    create?: XOR<Enumerable<CreditCreateWithoutCreditorInput>, Enumerable<CreditUncheckedCreateWithoutCreditorInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutCreditorInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutCreditorInput>
    createMany?: CreditCreateManyCreditorInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutCreditorInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutCreditorInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type CreditUncheckedUpdateManyWithoutDebtorInput = {
    create?: XOR<Enumerable<CreditCreateWithoutDebtorInput>, Enumerable<CreditUncheckedCreateWithoutDebtorInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutDebtorInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutDebtorInput>
    createMany?: CreditCreateManyDebtorInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutDebtorInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutDebtorInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type CreditConfigurationUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<CreditConfigurationCreateWithoutWalletInput>, Enumerable<CreditConfigurationUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<CreditConfigurationCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<CreditConfigurationUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: CreditConfigurationCreateManyWalletInputEnvelope
    set?: Enumerable<CreditConfigurationWhereUniqueInput>
    disconnect?: Enumerable<CreditConfigurationWhereUniqueInput>
    delete?: Enumerable<CreditConfigurationWhereUniqueInput>
    connect?: Enumerable<CreditConfigurationWhereUniqueInput>
    update?: Enumerable<CreditConfigurationUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<CreditConfigurationUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<CreditConfigurationScalarWhereInput>
  }

  export type CustomerUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutCustomerInput>, Enumerable<CustomerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerWhereUniqueInput>
    disconnect?: Enumerable<CustomerWhereUniqueInput>
    delete?: Enumerable<CustomerWhereUniqueInput>
    connect?: Enumerable<CustomerWhereUniqueInput>
    update?: Enumerable<CustomerUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerScalarWhereInput>
  }

  export type CustomerUncheckedUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutVendorInput>, Enumerable<CustomerUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<CustomerUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: CustomerCreateManyVendorInputEnvelope
    set?: Enumerable<CustomerWhereUniqueInput>
    disconnect?: Enumerable<CustomerWhereUniqueInput>
    delete?: Enumerable<CustomerWhereUniqueInput>
    connect?: Enumerable<CustomerWhereUniqueInput>
    update?: Enumerable<CustomerUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<CustomerUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<CustomerScalarWhereInput>
  }

  export type InstallmentUncheckedUpdateManyWithoutCreditorInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditorInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditorInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditorInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutCreditorInput>
    createMany?: InstallmentCreateManyCreditorInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutCreditorInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutCreditorInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type InstallmentUncheckedUpdateManyWithoutDebtorInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutDebtorInput>, Enumerable<InstallmentUncheckedCreateWithoutDebtorInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutDebtorInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutDebtorInput>
    createMany?: InstallmentCreateManyDebtorInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutDebtorInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutDebtorInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type MetaDataUncheckedUpdateOneWithoutWalletInput = {
    create?: XOR<MetaDataCreateWithoutWalletInput, MetaDataUncheckedCreateWithoutWalletInput>
    connectOrCreate?: MetaDataCreateOrConnectWithoutWalletInput
    upsert?: MetaDataUpsertWithoutWalletInput
    disconnect?: boolean
    delete?: boolean
    connect?: MetaDataWhereUniqueInput
    update?: XOR<MetaDataUpdateWithoutWalletInput, MetaDataUncheckedUpdateWithoutWalletInput>
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OrderCreateWithoutCustomerInput>, Enumerable<OrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutVendorWalletInput = {
    create?: XOR<Enumerable<OrderCreateWithoutVendorWalletInput>, Enumerable<OrderUncheckedCreateWithoutVendorWalletInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutVendorWalletInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutVendorWalletInput>
    createMany?: OrderCreateManyVendorWalletInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutVendorWalletInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutVendorWalletInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutVendorWalletInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVendorWalletInput>, Enumerable<ProductUncheckedCreateWithoutVendorWalletInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVendorWalletInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutVendorWalletInput>
    createMany?: ProductCreateManyVendorWalletInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutVendorWalletInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutVendorWalletInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type SettingsUncheckedUpdateOneWithoutWalletInput = {
    create?: XOR<SettingsCreateWithoutWalletInput, SettingsUncheckedCreateWithoutWalletInput>
    connectOrCreate?: SettingsCreateOrConnectWithoutWalletInput
    upsert?: SettingsUpsertWithoutWalletInput
    disconnect?: boolean
    delete?: boolean
    connect?: SettingsWhereUniqueInput
    update?: XOR<SettingsUpdateWithoutWalletInput, SettingsUncheckedUpdateWithoutWalletInput>
  }

  export type SettlementUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<SettlementCreateWithoutWalletInput>, Enumerable<SettlementUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<SettlementCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<SettlementUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: SettlementCreateManyWalletInputEnvelope
    set?: Enumerable<SettlementWhereUniqueInput>
    disconnect?: Enumerable<SettlementWhereUniqueInput>
    delete?: Enumerable<SettlementWhereUniqueInput>
    connect?: Enumerable<SettlementWhereUniqueInput>
    update?: Enumerable<SettlementUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<SettlementUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<SettlementScalarWhereInput>
  }

  export type ShippingUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<ShippingCreateWithoutWalletInput>, Enumerable<ShippingUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<ShippingCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<ShippingUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: ShippingCreateManyWalletInputEnvelope
    set?: Enumerable<ShippingWhereUniqueInput>
    disconnect?: Enumerable<ShippingWhereUniqueInput>
    delete?: Enumerable<ShippingWhereUniqueInput>
    connect?: Enumerable<ShippingWhereUniqueInput>
    update?: Enumerable<ShippingUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<ShippingUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<ShippingScalarWhereInput>
  }

  export type SupplierUncheckedUpdateManyWithoutSupplierInput = {
    create?: XOR<Enumerable<SupplierCreateWithoutSupplierInput>, Enumerable<SupplierUncheckedCreateWithoutSupplierInput>>
    connectOrCreate?: Enumerable<SupplierCreateOrConnectWithoutSupplierInput>
    upsert?: Enumerable<SupplierUpsertWithWhereUniqueWithoutSupplierInput>
    createMany?: SupplierCreateManySupplierInputEnvelope
    set?: Enumerable<SupplierWhereUniqueInput>
    disconnect?: Enumerable<SupplierWhereUniqueInput>
    delete?: Enumerable<SupplierWhereUniqueInput>
    connect?: Enumerable<SupplierWhereUniqueInput>
    update?: Enumerable<SupplierUpdateWithWhereUniqueWithoutSupplierInput>
    updateMany?: Enumerable<SupplierUpdateManyWithWhereWithoutSupplierInput>
    deleteMany?: Enumerable<SupplierScalarWhereInput>
  }

  export type SupplierUncheckedUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<SupplierCreateWithoutVendorInput>, Enumerable<SupplierUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<SupplierCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<SupplierUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: SupplierCreateManyVendorInputEnvelope
    set?: Enumerable<SupplierWhereUniqueInput>
    disconnect?: Enumerable<SupplierWhereUniqueInput>
    delete?: Enumerable<SupplierWhereUniqueInput>
    connect?: Enumerable<SupplierWhereUniqueInput>
    update?: Enumerable<SupplierUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<SupplierUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<SupplierScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutWalletInput>, Enumerable<TransactionUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: TransactionCreateManyWalletInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UsersWalletsUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<UsersWalletsCreateWithoutWalletInput>, Enumerable<UsersWalletsUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<UsersWalletsCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<UsersWalletsUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: UsersWalletsCreateManyWalletInputEnvelope
    set?: Enumerable<UsersWalletsWhereUniqueInput>
    disconnect?: Enumerable<UsersWalletsWhereUniqueInput>
    delete?: Enumerable<UsersWalletsWhereUniqueInput>
    connect?: Enumerable<UsersWalletsWhereUniqueInput>
    update?: Enumerable<UsersWalletsUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<UsersWalletsUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<UsersWalletsScalarWhereInput>
  }

  export type VisitUncheckedUpdateManyWithoutWalletInput = {
    create?: XOR<Enumerable<VisitCreateWithoutWalletInput>, Enumerable<VisitUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<VisitCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<VisitUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: VisitCreateManyWalletInputEnvelope
    set?: Enumerable<VisitWhereUniqueInput>
    disconnect?: Enumerable<VisitWhereUniqueInput>
    delete?: Enumerable<VisitWhereUniqueInput>
    connect?: Enumerable<VisitWhereUniqueInput>
    update?: Enumerable<VisitUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<VisitUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<VisitScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutWalletsInput = {
    create?: XOR<Enumerable<UserCreateWithoutWalletsInput>, Enumerable<UserUncheckedCreateWithoutWalletsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWalletsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutWalletsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutWalletsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutWalletsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type TrustUncheckedUpdateOneWithoutWalletInput = {
    create?: XOR<TrustCreateWithoutWalletInput, TrustUncheckedCreateWithoutWalletInput>
    connectOrCreate?: TrustCreateOrConnectWithoutWalletInput
    upsert?: TrustUpsertWithoutWalletInput
    disconnect?: boolean
    delete?: boolean
    connect?: TrustWhereUniqueInput
    update?: XOR<TrustUpdateWithoutWalletInput, TrustUncheckedUpdateWithoutWalletInput>
  }

  export type WalletCreateNestedOneWithoutTrustInput = {
    create?: XOR<WalletCreateWithoutTrustInput, WalletUncheckedCreateWithoutTrustInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTrustInput
    connect?: WalletWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WalletUpdateOneWithoutTrustInput = {
    create?: XOR<WalletCreateWithoutTrustInput, WalletUncheckedCreateWithoutTrustInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTrustInput
    upsert?: WalletUpsertWithoutTrustInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutTrustInput, WalletUncheckedUpdateWithoutTrustInput>
  }

  export type WalletCreateNestedOneWithoutMetaDataInput = {
    create?: XOR<WalletCreateWithoutMetaDataInput, WalletUncheckedCreateWithoutMetaDataInput>
    connectOrCreate?: WalletCreateOrConnectWithoutMetaDataInput
    connect?: WalletWhereUniqueInput
  }

  export type NullableEnumphaseEnumFieldUpdateOperationsInput = {
    set?: phaseEnum | null
  }

  export type NullableEnumpartnerRoleEnumFieldUpdateOperationsInput = {
    set?: partnerRoleEnum | null
  }

  export type NullableEnumlegalStatusEnumFieldUpdateOperationsInput = {
    set?: legalStatusEnum | null
  }

  export type WalletUpdateOneRequiredWithoutMetaDataInput = {
    create?: XOR<WalletCreateWithoutMetaDataInput, WalletUncheckedCreateWithoutMetaDataInput>
    connectOrCreate?: WalletCreateOrConnectWithoutMetaDataInput
    upsert?: WalletUpsertWithoutMetaDataInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutMetaDataInput, WalletUncheckedUpdateWithoutMetaDataInput>
  }

  export type WalletCreateNestedOneWithoutTransactionInput = {
    create?: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionInput
    connect?: WalletWhereUniqueInput
  }

  export type EnumPaymentTypesEnumFieldUpdateOperationsInput = {
    set?: PaymentTypesEnum
  }

  export type EnumCurrencyEnumFieldUpdateOperationsInput = {
    set?: CurrencyEnum
  }

  export type NullableEnumTransactionTypeEnumFieldUpdateOperationsInput = {
    set?: TransactionTypeEnum | null
  }

  export type NullableEnumTransactionMethodEnumFieldUpdateOperationsInput = {
    set?: TransactionMethodEnum | null
  }

  export type WalletUpdateOneWithoutTransactionInput = {
    create?: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionInput
    upsert?: WalletUpsertWithoutTransactionInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutTransactionInput, WalletUncheckedUpdateWithoutTransactionInput>
  }

  export type UserCreateNestedOneWithoutProductInput = {
    create?: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductInput
    connect?: UserWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutProductInput = {
    create?: XOR<WalletCreateWithoutProductInput, WalletUncheckedCreateWithoutProductInput>
    connectOrCreate?: WalletCreateOrConnectWithoutProductInput
    connect?: WalletWhereUniqueInput
  }

  export type NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput = {
    set?: EcommercePlatformEnum | null
  }

  export type UserUpdateOneWithoutProductInput = {
    create?: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductInput
    upsert?: UserUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProductInput, UserUncheckedUpdateWithoutProductInput>
  }

  export type WalletUpdateOneWithoutProductInput = {
    create?: XOR<WalletCreateWithoutProductInput, WalletUncheckedCreateWithoutProductInput>
    connectOrCreate?: WalletCreateOrConnectWithoutProductInput
    upsert?: WalletUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutProductInput, WalletUncheckedUpdateWithoutProductInput>
  }

  export type UserCreateNestedOneWithoutOrdersAffiliateInput = {
    create?: XOR<UserCreateWithoutOrdersAffiliateInput, UserUncheckedCreateWithoutOrdersAffiliateInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersAffiliateInput
    connect?: UserWhereUniqueInput
  }

  export type BillingCreateNestedOneWithoutOrderInput = {
    create?: XOR<BillingCreateWithoutOrderInput, BillingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: BillingCreateOrConnectWithoutOrderInput
    connect?: BillingWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutOrderInput = {
    create?: XOR<WalletCreateWithoutOrderInput, WalletUncheckedCreateWithoutOrderInput>
    connectOrCreate?: WalletCreateOrConnectWithoutOrderInput
    connect?: WalletWhereUniqueInput
  }

  export type ShippingCreateNestedOneWithoutOrderInput = {
    create?: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShippingCreateOrConnectWithoutOrderInput
    connect?: ShippingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutOrdersInput = {
    create?: XOR<WalletCreateWithoutOrdersInput, WalletUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WalletCreateOrConnectWithoutOrdersInput
    connect?: WalletWhereUniqueInput
  }

  export type CreditCreateNestedOneWithoutOrderInput = {
    create?: XOR<CreditCreateWithoutOrderInput, CreditUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CreditCreateOrConnectWithoutOrderInput
    connect?: CreditWhereUniqueInput
  }

  export type InstallmentCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutOrderInput>, Enumerable<InstallmentUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutOrderInput>
    createMany?: InstallmentCreateManyOrderInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type CreditRequestCreateNestedOneWithoutOrderInput = {
    create?: XOR<CreditRequestCreateWithoutOrderInput, CreditRequestUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutOrderInput
    connect?: CreditRequestWhereUniqueInput
  }

  export type CreditUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<CreditCreateWithoutOrderInput, CreditUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CreditCreateOrConnectWithoutOrderInput
    connect?: CreditWhereUniqueInput
  }

  export type InstallmentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutOrderInput>, Enumerable<InstallmentUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutOrderInput>
    createMany?: InstallmentCreateManyOrderInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type CreditRequestUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<CreditRequestCreateWithoutOrderInput, CreditRequestUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutOrderInput
    connect?: CreditRequestWhereUniqueInput
  }

  export type NullableEnumOrderStatusEnumFieldUpdateOperationsInput = {
    set?: OrderStatusEnum | null
  }

  export type EnumPaymentStatusEnumFieldUpdateOperationsInput = {
    set?: PaymentStatusEnum
  }

  export type NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput = {
    set?: OrderPaymentMethodsEnum | null
  }

  export type UserUpdateOneWithoutOrdersAffiliateInput = {
    create?: XOR<UserCreateWithoutOrdersAffiliateInput, UserUncheckedCreateWithoutOrdersAffiliateInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersAffiliateInput
    upsert?: UserUpsertWithoutOrdersAffiliateInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrdersAffiliateInput, UserUncheckedUpdateWithoutOrdersAffiliateInput>
  }

  export type BillingUpdateOneWithoutOrderInput = {
    create?: XOR<BillingCreateWithoutOrderInput, BillingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: BillingCreateOrConnectWithoutOrderInput
    upsert?: BillingUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: BillingWhereUniqueInput
    update?: XOR<BillingUpdateWithoutOrderInput, BillingUncheckedUpdateWithoutOrderInput>
  }

  export type WalletUpdateOneWithoutOrderInput = {
    create?: XOR<WalletCreateWithoutOrderInput, WalletUncheckedCreateWithoutOrderInput>
    connectOrCreate?: WalletCreateOrConnectWithoutOrderInput
    upsert?: WalletUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutOrderInput, WalletUncheckedUpdateWithoutOrderInput>
  }

  export type ShippingUpdateOneWithoutOrderInput = {
    create?: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShippingCreateOrConnectWithoutOrderInput
    upsert?: ShippingUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: ShippingWhereUniqueInput
    update?: XOR<ShippingUpdateWithoutOrderInput, ShippingUncheckedUpdateWithoutOrderInput>
  }

  export type UserUpdateOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type WalletUpdateOneWithoutOrdersInput = {
    create?: XOR<WalletCreateWithoutOrdersInput, WalletUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WalletCreateOrConnectWithoutOrdersInput
    upsert?: WalletUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutOrdersInput, WalletUncheckedUpdateWithoutOrdersInput>
  }

  export type CreditUpdateOneWithoutOrderInput = {
    create?: XOR<CreditCreateWithoutOrderInput, CreditUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CreditCreateOrConnectWithoutOrderInput
    upsert?: CreditUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditWhereUniqueInput
    update?: XOR<CreditUpdateWithoutOrderInput, CreditUncheckedUpdateWithoutOrderInput>
  }

  export type InstallmentUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutOrderInput>, Enumerable<InstallmentUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: InstallmentCreateManyOrderInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type CreditRequestUpdateOneWithoutOrderInput = {
    create?: XOR<CreditRequestCreateWithoutOrderInput, CreditRequestUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutOrderInput
    upsert?: CreditRequestUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditRequestWhereUniqueInput
    update?: XOR<CreditRequestUpdateWithoutOrderInput, CreditRequestUncheckedUpdateWithoutOrderInput>
  }

  export type CreditUncheckedUpdateOneWithoutOrderInput = {
    create?: XOR<CreditCreateWithoutOrderInput, CreditUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CreditCreateOrConnectWithoutOrderInput
    upsert?: CreditUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditWhereUniqueInput
    update?: XOR<CreditUpdateWithoutOrderInput, CreditUncheckedUpdateWithoutOrderInput>
  }

  export type InstallmentUncheckedUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutOrderInput>, Enumerable<InstallmentUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: InstallmentCreateManyOrderInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type CreditRequestUncheckedUpdateOneWithoutOrderInput = {
    create?: XOR<CreditRequestCreateWithoutOrderInput, CreditRequestUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutOrderInput
    upsert?: CreditRequestUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditRequestWhereUniqueInput
    update?: XOR<CreditRequestUpdateWithoutOrderInput, CreditRequestUncheckedUpdateWithoutOrderInput>
  }

  export type WalletCreateNestedOneWithoutBillingInput = {
    create?: XOR<WalletCreateWithoutBillingInput, WalletUncheckedCreateWithoutBillingInput>
    connectOrCreate?: WalletCreateOrConnectWithoutBillingInput
    connect?: WalletWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutBillingInput = {
    create?: XOR<Enumerable<OrderCreateWithoutBillingInput>, Enumerable<OrderUncheckedCreateWithoutBillingInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutBillingInput>
    createMany?: OrderCreateManyBillingInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutBillingInput = {
    create?: XOR<Enumerable<OrderCreateWithoutBillingInput>, Enumerable<OrderUncheckedCreateWithoutBillingInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutBillingInput>
    createMany?: OrderCreateManyBillingInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type WalletUpdateOneWithoutBillingInput = {
    create?: XOR<WalletCreateWithoutBillingInput, WalletUncheckedCreateWithoutBillingInput>
    connectOrCreate?: WalletCreateOrConnectWithoutBillingInput
    upsert?: WalletUpsertWithoutBillingInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutBillingInput, WalletUncheckedUpdateWithoutBillingInput>
  }

  export type OrderUpdateManyWithoutBillingInput = {
    create?: XOR<Enumerable<OrderCreateWithoutBillingInput>, Enumerable<OrderUncheckedCreateWithoutBillingInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutBillingInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutBillingInput>
    createMany?: OrderCreateManyBillingInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutBillingInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutBillingInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutBillingInput = {
    create?: XOR<Enumerable<OrderCreateWithoutBillingInput>, Enumerable<OrderUncheckedCreateWithoutBillingInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutBillingInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutBillingInput>
    createMany?: OrderCreateManyBillingInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutBillingInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutBillingInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type WalletCreateNestedOneWithoutShippingInput = {
    create?: XOR<WalletCreateWithoutShippingInput, WalletUncheckedCreateWithoutShippingInput>
    connectOrCreate?: WalletCreateOrConnectWithoutShippingInput
    connect?: WalletWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutShippingInput = {
    create?: XOR<Enumerable<OrderCreateWithoutShippingInput>, Enumerable<OrderUncheckedCreateWithoutShippingInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutShippingInput>
    createMany?: OrderCreateManyShippingInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutShippingInput = {
    create?: XOR<Enumerable<OrderCreateWithoutShippingInput>, Enumerable<OrderUncheckedCreateWithoutShippingInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutShippingInput>
    createMany?: OrderCreateManyShippingInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type NullableEnumShippingTypeEnumFieldUpdateOperationsInput = {
    set?: ShippingTypeEnum | null
  }

  export type WalletUpdateOneWithoutShippingInput = {
    create?: XOR<WalletCreateWithoutShippingInput, WalletUncheckedCreateWithoutShippingInput>
    connectOrCreate?: WalletCreateOrConnectWithoutShippingInput
    upsert?: WalletUpsertWithoutShippingInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutShippingInput, WalletUncheckedUpdateWithoutShippingInput>
  }

  export type OrderUpdateManyWithoutShippingInput = {
    create?: XOR<Enumerable<OrderCreateWithoutShippingInput>, Enumerable<OrderUncheckedCreateWithoutShippingInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutShippingInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutShippingInput>
    createMany?: OrderCreateManyShippingInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutShippingInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutShippingInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutShippingInput = {
    create?: XOR<Enumerable<OrderCreateWithoutShippingInput>, Enumerable<OrderUncheckedCreateWithoutShippingInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutShippingInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutShippingInput>
    createMany?: OrderCreateManyShippingInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutShippingInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutShippingInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCreditsAffilateInput = {
    create?: XOR<UserCreateWithoutCreditsAffilateInput, UserUncheckedCreateWithoutCreditsAffilateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditsAffilateInput
    connect?: UserWhereUniqueInput
  }

  export type CreditConfigurationCreateNestedOneWithoutCreditInput = {
    create?: XOR<CreditConfigurationCreateWithoutCreditInput, CreditConfigurationUncheckedCreateWithoutCreditInput>
    connectOrCreate?: CreditConfigurationCreateOrConnectWithoutCreditInput
    connect?: CreditConfigurationWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutCreditorCreditInput = {
    create?: XOR<WalletCreateWithoutCreditorCreditInput, WalletUncheckedCreateWithoutCreditorCreditInput>
    connectOrCreate?: WalletCreateOrConnectWithoutCreditorCreditInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutDebtorCreditInput = {
    create?: XOR<WalletCreateWithoutDebtorCreditInput, WalletUncheckedCreateWithoutDebtorCreditInput>
    connectOrCreate?: WalletCreateOrConnectWithoutDebtorCreditInput
    connect?: WalletWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutCreditInput = {
    create?: XOR<OrderCreateWithoutCreditInput, OrderUncheckedCreateWithoutCreditInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCreditInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreditsInput = {
    create?: XOR<UserCreateWithoutCreditsInput, UserUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditsInput
    connect?: UserWhereUniqueInput
  }

  export type InstallmentCreateNestedManyWithoutCreditInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditInput>
    createMany?: InstallmentCreateManyCreditInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type InstallmentUncheckedCreateNestedManyWithoutCreditInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditInput>
    createMany?: InstallmentCreateManyCreditInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type NullableEnumcreditRefTypeFieldUpdateOperationsInput = {
    set?: creditRefType | null
  }

  export type NullableEnumcreditStatusEnumFieldUpdateOperationsInput = {
    set?: creditStatusEnum | null
  }

  export type EnumSlicesEnumFieldUpdateOperationsInput = {
    set?: SlicesEnum
  }

  export type UserUpdateOneWithoutCreditsAffilateInput = {
    create?: XOR<UserCreateWithoutCreditsAffilateInput, UserUncheckedCreateWithoutCreditsAffilateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditsAffilateInput
    upsert?: UserUpsertWithoutCreditsAffilateInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreditsAffilateInput, UserUncheckedUpdateWithoutCreditsAffilateInput>
  }

  export type CreditConfigurationUpdateOneRequiredWithoutCreditInput = {
    create?: XOR<CreditConfigurationCreateWithoutCreditInput, CreditConfigurationUncheckedCreateWithoutCreditInput>
    connectOrCreate?: CreditConfigurationCreateOrConnectWithoutCreditInput
    upsert?: CreditConfigurationUpsertWithoutCreditInput
    connect?: CreditConfigurationWhereUniqueInput
    update?: XOR<CreditConfigurationUpdateWithoutCreditInput, CreditConfigurationUncheckedUpdateWithoutCreditInput>
  }

  export type WalletUpdateOneWithoutCreditorCreditInput = {
    create?: XOR<WalletCreateWithoutCreditorCreditInput, WalletUncheckedCreateWithoutCreditorCreditInput>
    connectOrCreate?: WalletCreateOrConnectWithoutCreditorCreditInput
    upsert?: WalletUpsertWithoutCreditorCreditInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutCreditorCreditInput, WalletUncheckedUpdateWithoutCreditorCreditInput>
  }

  export type WalletUpdateOneWithoutDebtorCreditInput = {
    create?: XOR<WalletCreateWithoutDebtorCreditInput, WalletUncheckedCreateWithoutDebtorCreditInput>
    connectOrCreate?: WalletCreateOrConnectWithoutDebtorCreditInput
    upsert?: WalletUpsertWithoutDebtorCreditInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutDebtorCreditInput, WalletUncheckedUpdateWithoutDebtorCreditInput>
  }

  export type OrderUpdateOneWithoutCreditInput = {
    create?: XOR<OrderCreateWithoutCreditInput, OrderUncheckedCreateWithoutCreditInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCreditInput
    upsert?: OrderUpsertWithoutCreditInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutCreditInput, OrderUncheckedUpdateWithoutCreditInput>
  }

  export type UserUpdateOneWithoutCreditsInput = {
    create?: XOR<UserCreateWithoutCreditsInput, UserUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditsInput
    upsert?: UserUpsertWithoutCreditsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreditsInput, UserUncheckedUpdateWithoutCreditsInput>
  }

  export type InstallmentUpdateManyWithoutCreditInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutCreditInput>
    createMany?: InstallmentCreateManyCreditInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutCreditInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutCreditInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type InstallmentUncheckedUpdateManyWithoutCreditInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutCreditInput>
    createMany?: InstallmentCreateManyCreditInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutCreditInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutCreditInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type CreditConfigurationCreateNestedOneWithoutInstallmentInput = {
    create?: XOR<CreditConfigurationCreateWithoutInstallmentInput, CreditConfigurationUncheckedCreateWithoutInstallmentInput>
    connectOrCreate?: CreditConfigurationCreateOrConnectWithoutInstallmentInput
    connect?: CreditConfigurationWhereUniqueInput
  }

  export type CreditCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<CreditCreateWithoutInstallmentsInput, CreditUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: CreditCreateOrConnectWithoutInstallmentsInput
    connect?: CreditWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutCreditorInstallmentsInput = {
    create?: XOR<WalletCreateWithoutCreditorInstallmentsInput, WalletUncheckedCreateWithoutCreditorInstallmentsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutCreditorInstallmentsInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutDebtorInstallmentsInput = {
    create?: XOR<WalletCreateWithoutDebtorInstallmentsInput, WalletUncheckedCreateWithoutDebtorInstallmentsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutDebtorInstallmentsInput
    connect?: WalletWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<OrderCreateWithoutInstallmentsInput, OrderUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInstallmentsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInstallmentInput = {
    create?: XOR<UserCreateWithoutInstallmentInput, UserUncheckedCreateWithoutInstallmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstallmentInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput = {
    set?: installmentStatusTypeEnum | null
  }

  export type CreditConfigurationUpdateOneRequiredWithoutInstallmentInput = {
    create?: XOR<CreditConfigurationCreateWithoutInstallmentInput, CreditConfigurationUncheckedCreateWithoutInstallmentInput>
    connectOrCreate?: CreditConfigurationCreateOrConnectWithoutInstallmentInput
    upsert?: CreditConfigurationUpsertWithoutInstallmentInput
    connect?: CreditConfigurationWhereUniqueInput
    update?: XOR<CreditConfigurationUpdateWithoutInstallmentInput, CreditConfigurationUncheckedUpdateWithoutInstallmentInput>
  }

  export type CreditUpdateOneWithoutInstallmentsInput = {
    create?: XOR<CreditCreateWithoutInstallmentsInput, CreditUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: CreditCreateOrConnectWithoutInstallmentsInput
    upsert?: CreditUpsertWithoutInstallmentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditWhereUniqueInput
    update?: XOR<CreditUpdateWithoutInstallmentsInput, CreditUncheckedUpdateWithoutInstallmentsInput>
  }

  export type WalletUpdateOneWithoutCreditorInstallmentsInput = {
    create?: XOR<WalletCreateWithoutCreditorInstallmentsInput, WalletUncheckedCreateWithoutCreditorInstallmentsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutCreditorInstallmentsInput
    upsert?: WalletUpsertWithoutCreditorInstallmentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutCreditorInstallmentsInput, WalletUncheckedUpdateWithoutCreditorInstallmentsInput>
  }

  export type WalletUpdateOneWithoutDebtorInstallmentsInput = {
    create?: XOR<WalletCreateWithoutDebtorInstallmentsInput, WalletUncheckedCreateWithoutDebtorInstallmentsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutDebtorInstallmentsInput
    upsert?: WalletUpsertWithoutDebtorInstallmentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutDebtorInstallmentsInput, WalletUncheckedUpdateWithoutDebtorInstallmentsInput>
  }

  export type OrderUpdateOneWithoutInstallmentsInput = {
    create?: XOR<OrderCreateWithoutInstallmentsInput, OrderUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInstallmentsInput
    upsert?: OrderUpsertWithoutInstallmentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutInstallmentsInput, OrderUncheckedUpdateWithoutInstallmentsInput>
  }

  export type UserUpdateOneWithoutInstallmentInput = {
    create?: XOR<UserCreateWithoutInstallmentInput, UserUncheckedCreateWithoutInstallmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstallmentInput
    upsert?: UserUpsertWithoutInstallmentInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInstallmentInput, UserUncheckedUpdateWithoutInstallmentInput>
  }

  export type UserCreateNestedOneWithoutActivityInput = {
    create?: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumActivityEntityTypeFieldUpdateOperationsInput = {
    set?: ActivityEntityType | null
  }

  export type NullableEnumActivityPriorityFieldUpdateOperationsInput = {
    set?: ActivityPriority | null
  }

  export type UserUpdateOneWithoutActivityInput = {
    create?: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityInput
    upsert?: UserUpsertWithoutActivityInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutActivityInput, UserUncheckedUpdateWithoutActivityInput>
  }

  export type MessageCreateinstallmentSlicesInput = {
    set: Enumerable<SlicesEnum>
  }

  export type MessageUpdateinstallmentSlicesInput = {
    set?: Enumerable<SlicesEnum>
    push?: Enumerable<SlicesEnum>
  }

  export type EnumlanguageFieldUpdateOperationsInput = {
    set?: language
  }

  export type UserCreateNestedOneWithoutVerifyInput = {
    create?: XOR<UserCreateWithoutVerifyInput, UserUncheckedCreateWithoutVerifyInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifyInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutVerifyInput = {
    create?: XOR<UserCreateWithoutVerifyInput, UserUncheckedCreateWithoutVerifyInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifyInput
    upsert?: UserUpsertWithoutVerifyInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutVerifyInput, UserUncheckedUpdateWithoutVerifyInput>
  }

  export type UserCreateNestedOneWithoutLoginInput = {
    create?: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutLoginInput = {
    create?: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginInput
    upsert?: UserUpsertWithoutLoginInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLoginInput, UserUncheckedUpdateWithoutLoginInput>
  }

  export type WalletCreateNestedOneWithoutVisitInput = {
    create?: XOR<WalletCreateWithoutVisitInput, WalletUncheckedCreateWithoutVisitInput>
    connectOrCreate?: WalletCreateOrConnectWithoutVisitInput
    connect?: WalletWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVisitInput = {
    create?: XOR<UserCreateWithoutVisitInput, UserUncheckedCreateWithoutVisitInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitInput
    connect?: UserWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutVisitInput = {
    create?: XOR<WalletCreateWithoutVisitInput, WalletUncheckedCreateWithoutVisitInput>
    connectOrCreate?: WalletCreateOrConnectWithoutVisitInput
    upsert?: WalletUpsertWithoutVisitInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutVisitInput, WalletUncheckedUpdateWithoutVisitInput>
  }

  export type UserUpdateOneWithoutVisitInput = {
    create?: XOR<UserCreateWithoutVisitInput, UserUncheckedCreateWithoutVisitInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisitInput
    upsert?: UserUpsertWithoutVisitInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutVisitInput, UserUncheckedUpdateWithoutVisitInput>
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: JobStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WalletCreateNestedOneWithoutCreditConfigurationsInput = {
    create?: XOR<WalletCreateWithoutCreditConfigurationsInput, WalletUncheckedCreateWithoutCreditConfigurationsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutCreditConfigurationsInput
    connect?: WalletWhereUniqueInput
  }

  export type CreditCreateNestedManyWithoutCreditConfigurationInput = {
    create?: XOR<Enumerable<CreditCreateWithoutCreditConfigurationInput>, Enumerable<CreditUncheckedCreateWithoutCreditConfigurationInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutCreditConfigurationInput>
    createMany?: CreditCreateManyCreditConfigurationInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type CreditConfigurationsWalletsCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<Enumerable<CreditConfigurationsWalletsCreateWithoutConfigurationInput>, Enumerable<CreditConfigurationsWalletsUncheckedCreateWithoutConfigurationInput>>
    connectOrCreate?: Enumerable<CreditConfigurationsWalletsCreateOrConnectWithoutConfigurationInput>
    createMany?: CreditConfigurationsWalletsCreateManyConfigurationInputEnvelope
    connect?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
  }

  export type InstallmentCreateNestedManyWithoutCreditConfigurationInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditConfigurationInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditConfigurationInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditConfigurationInput>
    createMany?: InstallmentCreateManyCreditConfigurationInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type CreditRequestCreateNestedOneWithoutCreditConfigurationInput = {
    create?: XOR<CreditRequestCreateWithoutCreditConfigurationInput, CreditRequestUncheckedCreateWithoutCreditConfigurationInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutCreditConfigurationInput
    connect?: CreditRequestWhereUniqueInput
  }

  export type CreditUncheckedCreateNestedManyWithoutCreditConfigurationInput = {
    create?: XOR<Enumerable<CreditCreateWithoutCreditConfigurationInput>, Enumerable<CreditUncheckedCreateWithoutCreditConfigurationInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutCreditConfigurationInput>
    createMany?: CreditCreateManyCreditConfigurationInputEnvelope
    connect?: Enumerable<CreditWhereUniqueInput>
  }

  export type CreditConfigurationsWalletsUncheckedCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<Enumerable<CreditConfigurationsWalletsCreateWithoutConfigurationInput>, Enumerable<CreditConfigurationsWalletsUncheckedCreateWithoutConfigurationInput>>
    connectOrCreate?: Enumerable<CreditConfigurationsWalletsCreateOrConnectWithoutConfigurationInput>
    createMany?: CreditConfigurationsWalletsCreateManyConfigurationInputEnvelope
    connect?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
  }

  export type InstallmentUncheckedCreateNestedManyWithoutCreditConfigurationInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditConfigurationInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditConfigurationInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditConfigurationInput>
    createMany?: InstallmentCreateManyCreditConfigurationInputEnvelope
    connect?: Enumerable<InstallmentWhereUniqueInput>
  }

  export type CreditRequestUncheckedCreateNestedOneWithoutCreditConfigurationInput = {
    create?: XOR<CreditRequestCreateWithoutCreditConfigurationInput, CreditRequestUncheckedCreateWithoutCreditConfigurationInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutCreditConfigurationInput
    connect?: CreditRequestWhereUniqueInput
  }

  export type EnumCreditConfigurationStatusFieldUpdateOperationsInput = {
    set?: CreditConfigurationStatus
  }

  export type WalletUpdateOneRequiredWithoutCreditConfigurationsInput = {
    create?: XOR<WalletCreateWithoutCreditConfigurationsInput, WalletUncheckedCreateWithoutCreditConfigurationsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutCreditConfigurationsInput
    upsert?: WalletUpsertWithoutCreditConfigurationsInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutCreditConfigurationsInput, WalletUncheckedUpdateWithoutCreditConfigurationsInput>
  }

  export type CreditUpdateManyWithoutCreditConfigurationInput = {
    create?: XOR<Enumerable<CreditCreateWithoutCreditConfigurationInput>, Enumerable<CreditUncheckedCreateWithoutCreditConfigurationInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutCreditConfigurationInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutCreditConfigurationInput>
    createMany?: CreditCreateManyCreditConfigurationInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutCreditConfigurationInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutCreditConfigurationInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type CreditConfigurationsWalletsUpdateManyWithoutConfigurationInput = {
    create?: XOR<Enumerable<CreditConfigurationsWalletsCreateWithoutConfigurationInput>, Enumerable<CreditConfigurationsWalletsUncheckedCreateWithoutConfigurationInput>>
    connectOrCreate?: Enumerable<CreditConfigurationsWalletsCreateOrConnectWithoutConfigurationInput>
    upsert?: Enumerable<CreditConfigurationsWalletsUpsertWithWhereUniqueWithoutConfigurationInput>
    createMany?: CreditConfigurationsWalletsCreateManyConfigurationInputEnvelope
    set?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
    disconnect?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
    delete?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
    connect?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
    update?: Enumerable<CreditConfigurationsWalletsUpdateWithWhereUniqueWithoutConfigurationInput>
    updateMany?: Enumerable<CreditConfigurationsWalletsUpdateManyWithWhereWithoutConfigurationInput>
    deleteMany?: Enumerable<CreditConfigurationsWalletsScalarWhereInput>
  }

  export type InstallmentUpdateManyWithoutCreditConfigurationInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditConfigurationInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditConfigurationInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditConfigurationInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutCreditConfigurationInput>
    createMany?: InstallmentCreateManyCreditConfigurationInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutCreditConfigurationInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutCreditConfigurationInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type CreditRequestUpdateOneWithoutCreditConfigurationInput = {
    create?: XOR<CreditRequestCreateWithoutCreditConfigurationInput, CreditRequestUncheckedCreateWithoutCreditConfigurationInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutCreditConfigurationInput
    upsert?: CreditRequestUpsertWithoutCreditConfigurationInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditRequestWhereUniqueInput
    update?: XOR<CreditRequestUpdateWithoutCreditConfigurationInput, CreditRequestUncheckedUpdateWithoutCreditConfigurationInput>
  }

  export type CreditUncheckedUpdateManyWithoutCreditConfigurationInput = {
    create?: XOR<Enumerable<CreditCreateWithoutCreditConfigurationInput>, Enumerable<CreditUncheckedCreateWithoutCreditConfigurationInput>>
    connectOrCreate?: Enumerable<CreditCreateOrConnectWithoutCreditConfigurationInput>
    upsert?: Enumerable<CreditUpsertWithWhereUniqueWithoutCreditConfigurationInput>
    createMany?: CreditCreateManyCreditConfigurationInputEnvelope
    set?: Enumerable<CreditWhereUniqueInput>
    disconnect?: Enumerable<CreditWhereUniqueInput>
    delete?: Enumerable<CreditWhereUniqueInput>
    connect?: Enumerable<CreditWhereUniqueInput>
    update?: Enumerable<CreditUpdateWithWhereUniqueWithoutCreditConfigurationInput>
    updateMany?: Enumerable<CreditUpdateManyWithWhereWithoutCreditConfigurationInput>
    deleteMany?: Enumerable<CreditScalarWhereInput>
  }

  export type CreditConfigurationsWalletsUncheckedUpdateManyWithoutConfigurationInput = {
    create?: XOR<Enumerable<CreditConfigurationsWalletsCreateWithoutConfigurationInput>, Enumerable<CreditConfigurationsWalletsUncheckedCreateWithoutConfigurationInput>>
    connectOrCreate?: Enumerable<CreditConfigurationsWalletsCreateOrConnectWithoutConfigurationInput>
    upsert?: Enumerable<CreditConfigurationsWalletsUpsertWithWhereUniqueWithoutConfigurationInput>
    createMany?: CreditConfigurationsWalletsCreateManyConfigurationInputEnvelope
    set?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
    disconnect?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
    delete?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
    connect?: Enumerable<CreditConfigurationsWalletsWhereUniqueInput>
    update?: Enumerable<CreditConfigurationsWalletsUpdateWithWhereUniqueWithoutConfigurationInput>
    updateMany?: Enumerable<CreditConfigurationsWalletsUpdateManyWithWhereWithoutConfigurationInput>
    deleteMany?: Enumerable<CreditConfigurationsWalletsScalarWhereInput>
  }

  export type InstallmentUncheckedUpdateManyWithoutCreditConfigurationInput = {
    create?: XOR<Enumerable<InstallmentCreateWithoutCreditConfigurationInput>, Enumerable<InstallmentUncheckedCreateWithoutCreditConfigurationInput>>
    connectOrCreate?: Enumerable<InstallmentCreateOrConnectWithoutCreditConfigurationInput>
    upsert?: Enumerable<InstallmentUpsertWithWhereUniqueWithoutCreditConfigurationInput>
    createMany?: InstallmentCreateManyCreditConfigurationInputEnvelope
    set?: Enumerable<InstallmentWhereUniqueInput>
    disconnect?: Enumerable<InstallmentWhereUniqueInput>
    delete?: Enumerable<InstallmentWhereUniqueInput>
    connect?: Enumerable<InstallmentWhereUniqueInput>
    update?: Enumerable<InstallmentUpdateWithWhereUniqueWithoutCreditConfigurationInput>
    updateMany?: Enumerable<InstallmentUpdateManyWithWhereWithoutCreditConfigurationInput>
    deleteMany?: Enumerable<InstallmentScalarWhereInput>
  }

  export type CreditRequestUncheckedUpdateOneWithoutCreditConfigurationInput = {
    create?: XOR<CreditRequestCreateWithoutCreditConfigurationInput, CreditRequestUncheckedCreateWithoutCreditConfigurationInput>
    connectOrCreate?: CreditRequestCreateOrConnectWithoutCreditConfigurationInput
    upsert?: CreditRequestUpsertWithoutCreditConfigurationInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditRequestWhereUniqueInput
    update?: XOR<CreditRequestUpdateWithoutCreditConfigurationInput, CreditRequestUncheckedUpdateWithoutCreditConfigurationInput>
  }

  export type CreditConfigurationCreateNestedOneWithoutAttachedWalletsInput = {
    create?: XOR<CreditConfigurationCreateWithoutAttachedWalletsInput, CreditConfigurationUncheckedCreateWithoutAttachedWalletsInput>
    connectOrCreate?: CreditConfigurationCreateOrConnectWithoutAttachedWalletsInput
    connect?: CreditConfigurationWhereUniqueInput
  }

  export type CreditConfigurationUpdateOneRequiredWithoutAttachedWalletsInput = {
    create?: XOR<CreditConfigurationCreateWithoutAttachedWalletsInput, CreditConfigurationUncheckedCreateWithoutAttachedWalletsInput>
    connectOrCreate?: CreditConfigurationCreateOrConnectWithoutAttachedWalletsInput
    upsert?: CreditConfigurationUpsertWithoutAttachedWalletsInput
    connect?: CreditConfigurationWhereUniqueInput
    update?: XOR<CreditConfigurationUpdateWithoutAttachedWalletsInput, CreditConfigurationUncheckedUpdateWithoutAttachedWalletsInput>
  }

  export type UserCreateNestedOneWithoutOtherMemberKYCInput = {
    create?: XOR<UserCreateWithoutOtherMemberKYCInput, UserUncheckedCreateWithoutOtherMemberKYCInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtherMemberKYCInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOtherMemberKYCInput = {
    create?: XOR<UserCreateWithoutOtherMemberKYCInput, UserUncheckedCreateWithoutOtherMemberKYCInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtherMemberKYCInput
    upsert?: UserUpsertWithoutOtherMemberKYCInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOtherMemberKYCInput, UserUncheckedUpdateWithoutOtherMemberKYCInput>
  }

  export type WalletCreateNestedOneWithoutSettingsInput = {
    create?: XOR<WalletCreateWithoutSettingsInput, WalletUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSettingsInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutSettingsInput = {
    create?: XOR<WalletCreateWithoutSettingsInput, WalletUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSettingsInput
    upsert?: WalletUpsertWithoutSettingsInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutSettingsInput, WalletUncheckedUpdateWithoutSettingsInput>
  }

  export type WalletCreateNestedOneWithoutSettlementInput = {
    create?: XOR<WalletCreateWithoutSettlementInput, WalletUncheckedCreateWithoutSettlementInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSettlementInput
    connect?: WalletWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSettlementInput = {
    create?: XOR<UserCreateWithoutSettlementInput, UserUncheckedCreateWithoutSettlementInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettlementInput
    connect?: UserWhereUniqueInput
  }

  export type WalletCreateNestedManyWithoutSettlementDefaultInput = {
    create?: XOR<Enumerable<WalletCreateWithoutSettlementDefaultInput>, Enumerable<WalletUncheckedCreateWithoutSettlementDefaultInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutSettlementDefaultInput>
    createMany?: WalletCreateManySettlementDefaultInputEnvelope
    connect?: Enumerable<WalletWhereUniqueInput>
  }

  export type WalletUncheckedCreateNestedManyWithoutSettlementDefaultInput = {
    create?: XOR<Enumerable<WalletCreateWithoutSettlementDefaultInput>, Enumerable<WalletUncheckedCreateWithoutSettlementDefaultInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutSettlementDefaultInput>
    createMany?: WalletCreateManySettlementDefaultInputEnvelope
    connect?: Enumerable<WalletWhereUniqueInput>
  }

  export type EnumTransactionMethodEnumFieldUpdateOperationsInput = {
    set?: TransactionMethodEnum
  }

  export type WalletUpdateOneRequiredWithoutSettlementInput = {
    create?: XOR<WalletCreateWithoutSettlementInput, WalletUncheckedCreateWithoutSettlementInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSettlementInput
    upsert?: WalletUpsertWithoutSettlementInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutSettlementInput, WalletUncheckedUpdateWithoutSettlementInput>
  }

  export type UserUpdateOneRequiredWithoutSettlementInput = {
    create?: XOR<UserCreateWithoutSettlementInput, UserUncheckedCreateWithoutSettlementInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettlementInput
    upsert?: UserUpsertWithoutSettlementInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSettlementInput, UserUncheckedUpdateWithoutSettlementInput>
  }

  export type UserUpdateOneWithoutSettlementInput = {
    create?: XOR<UserCreateWithoutSettlementInput, UserUncheckedCreateWithoutSettlementInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettlementInput
    upsert?: UserUpsertWithoutSettlementInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSettlementInput, UserUncheckedUpdateWithoutSettlementInput>
  }

  export type WalletUpdateManyWithoutSettlementDefaultInput = {
    create?: XOR<Enumerable<WalletCreateWithoutSettlementDefaultInput>, Enumerable<WalletUncheckedCreateWithoutSettlementDefaultInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutSettlementDefaultInput>
    upsert?: Enumerable<WalletUpsertWithWhereUniqueWithoutSettlementDefaultInput>
    createMany?: WalletCreateManySettlementDefaultInputEnvelope
    set?: Enumerable<WalletWhereUniqueInput>
    disconnect?: Enumerable<WalletWhereUniqueInput>
    delete?: Enumerable<WalletWhereUniqueInput>
    connect?: Enumerable<WalletWhereUniqueInput>
    update?: Enumerable<WalletUpdateWithWhereUniqueWithoutSettlementDefaultInput>
    updateMany?: Enumerable<WalletUpdateManyWithWhereWithoutSettlementDefaultInput>
    deleteMany?: Enumerable<WalletScalarWhereInput>
  }

  export type WalletUncheckedUpdateManyWithoutSettlementDefaultInput = {
    create?: XOR<Enumerable<WalletCreateWithoutSettlementDefaultInput>, Enumerable<WalletUncheckedCreateWithoutSettlementDefaultInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutSettlementDefaultInput>
    upsert?: Enumerable<WalletUpsertWithWhereUniqueWithoutSettlementDefaultInput>
    createMany?: WalletCreateManySettlementDefaultInputEnvelope
    set?: Enumerable<WalletWhereUniqueInput>
    disconnect?: Enumerable<WalletWhereUniqueInput>
    delete?: Enumerable<WalletWhereUniqueInput>
    connect?: Enumerable<WalletWhereUniqueInput>
    update?: Enumerable<WalletUpdateWithWhereUniqueWithoutSettlementDefaultInput>
    updateMany?: Enumerable<WalletUpdateManyWithWhereWithoutSettlementDefaultInput>
    deleteMany?: Enumerable<WalletScalarWhereInput>
  }

  export type AnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutQuestionInput>, Enumerable<AnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutQuestionInput>
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type AnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutQuestionInput>, Enumerable<AnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutQuestionInput>
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type EnumanswerTypeEnumFieldUpdateOperationsInput = {
    set?: answerTypeEnum
  }

  export type EnumQuestionCategoryEnumFieldUpdateOperationsInput = {
    set?: QuestionCategoryEnum
  }

  export type AnswerUpdateManyWithoutQuestionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutQuestionInput>, Enumerable<AnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutQuestionInput>, Enumerable<AnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type WalletCreateNestedOneWithoutAnswersInput = {
    create?: XOR<WalletCreateWithoutAnswersInput, WalletUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: WalletCreateOrConnectWithoutAnswersInput
    connect?: WalletWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnswersInput = {
    create?: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutAnswersInput = {
    create?: XOR<WalletCreateWithoutAnswersInput, WalletUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: WalletCreateOrConnectWithoutAnswersInput
    upsert?: WalletUpsertWithoutAnswersInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutAnswersInput, WalletUncheckedUpdateWithoutAnswersInput>
  }

  export type UserUpdateOneWithoutAnswersInput = {
    create?: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnswersInput
    upsert?: UserUpsertWithoutAnswersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAnswersInput, UserUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionUpdateOneRequiredWithoutAnswersInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuestionUpsertWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type UserCreateNestedOneWithoutCreditRequestsInput = {
    create?: XOR<UserCreateWithoutCreditRequestsInput, UserUncheckedCreateWithoutCreditRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutCreditRequestInput = {
    create?: XOR<OrderCreateWithoutCreditRequestInput, OrderUncheckedCreateWithoutCreditRequestInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCreditRequestInput
    connect?: OrderWhereUniqueInput
  }

  export type CreditConfigurationCreateNestedOneWithoutCreditRequestsInput = {
    create?: XOR<CreditConfigurationCreateWithoutCreditRequestsInput, CreditConfigurationUncheckedCreateWithoutCreditRequestsInput>
    connectOrCreate?: CreditConfigurationCreateOrConnectWithoutCreditRequestsInput
    connect?: CreditConfigurationWhereUniqueInput
  }

  export type EnumCreditRequestStatusFieldUpdateOperationsInput = {
    set?: CreditRequestStatus
  }

  export type UserUpdateOneWithoutCreditRequestsInput = {
    create?: XOR<UserCreateWithoutCreditRequestsInput, UserUncheckedCreateWithoutCreditRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditRequestsInput
    upsert?: UserUpsertWithoutCreditRequestsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreditRequestsInput, UserUncheckedUpdateWithoutCreditRequestsInput>
  }

  export type OrderUpdateOneWithoutCreditRequestInput = {
    create?: XOR<OrderCreateWithoutCreditRequestInput, OrderUncheckedCreateWithoutCreditRequestInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCreditRequestInput
    upsert?: OrderUpsertWithoutCreditRequestInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutCreditRequestInput, OrderUncheckedUpdateWithoutCreditRequestInput>
  }

  export type CreditConfigurationUpdateOneWithoutCreditRequestsInput = {
    create?: XOR<CreditConfigurationCreateWithoutCreditRequestsInput, CreditConfigurationUncheckedCreateWithoutCreditRequestsInput>
    connectOrCreate?: CreditConfigurationCreateOrConnectWithoutCreditRequestsInput
    upsert?: CreditConfigurationUpsertWithoutCreditRequestsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CreditConfigurationWhereUniqueInput
    update?: XOR<CreditConfigurationUpdateWithoutCreditRequestsInput, CreditConfigurationUncheckedUpdateWithoutCreditRequestsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumCountryCodeNullableFilter = {
    equals?: CountryCode | null
    in?: Enumerable<CountryCode> | null
    notIn?: Enumerable<CountryCode> | null
    not?: NestedEnumCountryCodeNullableFilter | CountryCode | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumGenderEnumNullableFilter = {
    equals?: GenderEnum | null
    in?: Enumerable<GenderEnum> | null
    notIn?: Enumerable<GenderEnum> | null
    not?: NestedEnumGenderEnumNullableFilter | GenderEnum | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumCountryCodeNullableWithAggregatesFilter = {
    equals?: CountryCode | null
    in?: Enumerable<CountryCode> | null
    notIn?: Enumerable<CountryCode> | null
    not?: NestedEnumCountryCodeNullableWithAggregatesFilter | CountryCode | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCountryCodeNullableFilter
    _max?: NestedEnumCountryCodeNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type NestedEnumGenderEnumNullableWithAggregatesFilter = {
    equals?: GenderEnum | null
    in?: Enumerable<GenderEnum> | null
    notIn?: Enumerable<GenderEnum> | null
    not?: NestedEnumGenderEnumNullableWithAggregatesFilter | GenderEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderEnumNullableFilter
    _max?: NestedEnumGenderEnumNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumWalletRoleFilter = {
    equals?: WalletRole
    in?: Enumerable<WalletRole>
    notIn?: Enumerable<WalletRole>
    not?: NestedEnumWalletRoleFilter | WalletRole
  }

  export type NestedEnumWalletRoleWithAggregatesFilter = {
    equals?: WalletRole
    in?: Enumerable<WalletRole>
    notIn?: Enumerable<WalletRole>
    not?: NestedEnumWalletRoleWithAggregatesFilter | WalletRole
    _count?: NestedIntFilter
    _min?: NestedEnumWalletRoleFilter
    _max?: NestedEnumWalletRoleFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedEnumBadgeTypeNullableFilter = {
    equals?: BadgeType | null
    in?: Enumerable<BadgeType> | null
    notIn?: Enumerable<BadgeType> | null
    not?: NestedEnumBadgeTypeNullableFilter | BadgeType | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedEnumBadgeTypeNullableWithAggregatesFilter = {
    equals?: BadgeType | null
    in?: Enumerable<BadgeType> | null
    notIn?: Enumerable<BadgeType> | null
    not?: NestedEnumBadgeTypeNullableWithAggregatesFilter | BadgeType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumBadgeTypeNullableFilter
    _max?: NestedEnumBadgeTypeNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumWalletTypesEnumFilter = {
    equals?: WalletTypesEnum
    in?: Enumerable<WalletTypesEnum>
    notIn?: Enumerable<WalletTypesEnum>
    not?: NestedEnumWalletTypesEnumFilter | WalletTypesEnum
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumCurrencyEnumNullableFilter = {
    equals?: CurrencyEnum | null
    in?: Enumerable<CurrencyEnum> | null
    notIn?: Enumerable<CurrencyEnum> | null
    not?: NestedEnumCurrencyEnumNullableFilter | CurrencyEnum | null
  }

  export type NestedEnumWalletTypesEnumWithAggregatesFilter = {
    equals?: WalletTypesEnum
    in?: Enumerable<WalletTypesEnum>
    notIn?: Enumerable<WalletTypesEnum>
    not?: NestedEnumWalletTypesEnumWithAggregatesFilter | WalletTypesEnum
    _count?: NestedIntFilter
    _min?: NestedEnumWalletTypesEnumFilter
    _max?: NestedEnumWalletTypesEnumFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumCurrencyEnumNullableWithAggregatesFilter = {
    equals?: CurrencyEnum | null
    in?: Enumerable<CurrencyEnum> | null
    notIn?: Enumerable<CurrencyEnum> | null
    not?: NestedEnumCurrencyEnumNullableWithAggregatesFilter | CurrencyEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumCurrencyEnumNullableFilter
    _max?: NestedEnumCurrencyEnumNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumphaseEnumNullableFilter = {
    equals?: phaseEnum | null
    in?: Enumerable<phaseEnum> | null
    notIn?: Enumerable<phaseEnum> | null
    not?: NestedEnumphaseEnumNullableFilter | phaseEnum | null
  }

  export type NestedEnumpartnerRoleEnumNullableFilter = {
    equals?: partnerRoleEnum | null
    in?: Enumerable<partnerRoleEnum> | null
    notIn?: Enumerable<partnerRoleEnum> | null
    not?: NestedEnumpartnerRoleEnumNullableFilter | partnerRoleEnum | null
  }

  export type NestedEnumlegalStatusEnumNullableFilter = {
    equals?: legalStatusEnum | null
    in?: Enumerable<legalStatusEnum> | null
    notIn?: Enumerable<legalStatusEnum> | null
    not?: NestedEnumlegalStatusEnumNullableFilter | legalStatusEnum | null
  }

  export type NestedEnumphaseEnumNullableWithAggregatesFilter = {
    equals?: phaseEnum | null
    in?: Enumerable<phaseEnum> | null
    notIn?: Enumerable<phaseEnum> | null
    not?: NestedEnumphaseEnumNullableWithAggregatesFilter | phaseEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumphaseEnumNullableFilter
    _max?: NestedEnumphaseEnumNullableFilter
  }

  export type NestedEnumpartnerRoleEnumNullableWithAggregatesFilter = {
    equals?: partnerRoleEnum | null
    in?: Enumerable<partnerRoleEnum> | null
    notIn?: Enumerable<partnerRoleEnum> | null
    not?: NestedEnumpartnerRoleEnumNullableWithAggregatesFilter | partnerRoleEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumpartnerRoleEnumNullableFilter
    _max?: NestedEnumpartnerRoleEnumNullableFilter
  }

  export type NestedEnumlegalStatusEnumNullableWithAggregatesFilter = {
    equals?: legalStatusEnum | null
    in?: Enumerable<legalStatusEnum> | null
    notIn?: Enumerable<legalStatusEnum> | null
    not?: NestedEnumlegalStatusEnumNullableWithAggregatesFilter | legalStatusEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumlegalStatusEnumNullableFilter
    _max?: NestedEnumlegalStatusEnumNullableFilter
  }

  export type NestedEnumPaymentTypesEnumFilter = {
    equals?: PaymentTypesEnum
    in?: Enumerable<PaymentTypesEnum>
    notIn?: Enumerable<PaymentTypesEnum>
    not?: NestedEnumPaymentTypesEnumFilter | PaymentTypesEnum
  }

  export type NestedEnumCurrencyEnumFilter = {
    equals?: CurrencyEnum
    in?: Enumerable<CurrencyEnum>
    notIn?: Enumerable<CurrencyEnum>
    not?: NestedEnumCurrencyEnumFilter | CurrencyEnum
  }

  export type NestedEnumTransactionTypeEnumNullableFilter = {
    equals?: TransactionTypeEnum | null
    in?: Enumerable<TransactionTypeEnum> | null
    notIn?: Enumerable<TransactionTypeEnum> | null
    not?: NestedEnumTransactionTypeEnumNullableFilter | TransactionTypeEnum | null
  }

  export type NestedEnumTransactionMethodEnumNullableFilter = {
    equals?: TransactionMethodEnum | null
    in?: Enumerable<TransactionMethodEnum> | null
    notIn?: Enumerable<TransactionMethodEnum> | null
    not?: NestedEnumTransactionMethodEnumNullableFilter | TransactionMethodEnum | null
  }

  export type NestedEnumPaymentTypesEnumWithAggregatesFilter = {
    equals?: PaymentTypesEnum
    in?: Enumerable<PaymentTypesEnum>
    notIn?: Enumerable<PaymentTypesEnum>
    not?: NestedEnumPaymentTypesEnumWithAggregatesFilter | PaymentTypesEnum
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentTypesEnumFilter
    _max?: NestedEnumPaymentTypesEnumFilter
  }

  export type NestedEnumCurrencyEnumWithAggregatesFilter = {
    equals?: CurrencyEnum
    in?: Enumerable<CurrencyEnum>
    notIn?: Enumerable<CurrencyEnum>
    not?: NestedEnumCurrencyEnumWithAggregatesFilter | CurrencyEnum
    _count?: NestedIntFilter
    _min?: NestedEnumCurrencyEnumFilter
    _max?: NestedEnumCurrencyEnumFilter
  }

  export type NestedEnumTransactionTypeEnumNullableWithAggregatesFilter = {
    equals?: TransactionTypeEnum | null
    in?: Enumerable<TransactionTypeEnum> | null
    notIn?: Enumerable<TransactionTypeEnum> | null
    not?: NestedEnumTransactionTypeEnumNullableWithAggregatesFilter | TransactionTypeEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumTransactionTypeEnumNullableFilter
    _max?: NestedEnumTransactionTypeEnumNullableFilter
  }

  export type NestedEnumTransactionMethodEnumNullableWithAggregatesFilter = {
    equals?: TransactionMethodEnum | null
    in?: Enumerable<TransactionMethodEnum> | null
    notIn?: Enumerable<TransactionMethodEnum> | null
    not?: NestedEnumTransactionMethodEnumNullableWithAggregatesFilter | TransactionMethodEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumTransactionMethodEnumNullableFilter
    _max?: NestedEnumTransactionMethodEnumNullableFilter
  }

  export type NestedEnumEcommercePlatformEnumNullableFilter = {
    equals?: EcommercePlatformEnum | null
    in?: Enumerable<EcommercePlatformEnum> | null
    notIn?: Enumerable<EcommercePlatformEnum> | null
    not?: NestedEnumEcommercePlatformEnumNullableFilter | EcommercePlatformEnum | null
  }

  export type NestedEnumEcommercePlatformEnumNullableWithAggregatesFilter = {
    equals?: EcommercePlatformEnum | null
    in?: Enumerable<EcommercePlatformEnum> | null
    notIn?: Enumerable<EcommercePlatformEnum> | null
    not?: NestedEnumEcommercePlatformEnumNullableWithAggregatesFilter | EcommercePlatformEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEcommercePlatformEnumNullableFilter
    _max?: NestedEnumEcommercePlatformEnumNullableFilter
  }

  export type NestedEnumOrderStatusEnumNullableFilter = {
    equals?: OrderStatusEnum | null
    in?: Enumerable<OrderStatusEnum> | null
    notIn?: Enumerable<OrderStatusEnum> | null
    not?: NestedEnumOrderStatusEnumNullableFilter | OrderStatusEnum | null
  }

  export type NestedEnumPaymentStatusEnumFilter = {
    equals?: PaymentStatusEnum
    in?: Enumerable<PaymentStatusEnum>
    notIn?: Enumerable<PaymentStatusEnum>
    not?: NestedEnumPaymentStatusEnumFilter | PaymentStatusEnum
  }

  export type NestedEnumOrderPaymentMethodsEnumNullableFilter = {
    equals?: OrderPaymentMethodsEnum | null
    in?: Enumerable<OrderPaymentMethodsEnum> | null
    notIn?: Enumerable<OrderPaymentMethodsEnum> | null
    not?: NestedEnumOrderPaymentMethodsEnumNullableFilter | OrderPaymentMethodsEnum | null
  }

  export type NestedEnumOrderStatusEnumNullableWithAggregatesFilter = {
    equals?: OrderStatusEnum | null
    in?: Enumerable<OrderStatusEnum> | null
    notIn?: Enumerable<OrderStatusEnum> | null
    not?: NestedEnumOrderStatusEnumNullableWithAggregatesFilter | OrderStatusEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumOrderStatusEnumNullableFilter
    _max?: NestedEnumOrderStatusEnumNullableFilter
  }

  export type NestedEnumPaymentStatusEnumWithAggregatesFilter = {
    equals?: PaymentStatusEnum
    in?: Enumerable<PaymentStatusEnum>
    notIn?: Enumerable<PaymentStatusEnum>
    not?: NestedEnumPaymentStatusEnumWithAggregatesFilter | PaymentStatusEnum
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentStatusEnumFilter
    _max?: NestedEnumPaymentStatusEnumFilter
  }

  export type NestedEnumOrderPaymentMethodsEnumNullableWithAggregatesFilter = {
    equals?: OrderPaymentMethodsEnum | null
    in?: Enumerable<OrderPaymentMethodsEnum> | null
    notIn?: Enumerable<OrderPaymentMethodsEnum> | null
    not?: NestedEnumOrderPaymentMethodsEnumNullableWithAggregatesFilter | OrderPaymentMethodsEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumOrderPaymentMethodsEnumNullableFilter
    _max?: NestedEnumOrderPaymentMethodsEnumNullableFilter
  }

  export type NestedEnumShippingTypeEnumNullableFilter = {
    equals?: ShippingTypeEnum | null
    in?: Enumerable<ShippingTypeEnum> | null
    notIn?: Enumerable<ShippingTypeEnum> | null
    not?: NestedEnumShippingTypeEnumNullableFilter | ShippingTypeEnum | null
  }

  export type NestedEnumShippingTypeEnumNullableWithAggregatesFilter = {
    equals?: ShippingTypeEnum | null
    in?: Enumerable<ShippingTypeEnum> | null
    notIn?: Enumerable<ShippingTypeEnum> | null
    not?: NestedEnumShippingTypeEnumNullableWithAggregatesFilter | ShippingTypeEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumShippingTypeEnumNullableFilter
    _max?: NestedEnumShippingTypeEnumNullableFilter
  }

  export type NestedEnumcreditRefTypeNullableFilter = {
    equals?: creditRefType | null
    in?: Enumerable<creditRefType> | null
    notIn?: Enumerable<creditRefType> | null
    not?: NestedEnumcreditRefTypeNullableFilter | creditRefType | null
  }

  export type NestedEnumcreditStatusEnumNullableFilter = {
    equals?: creditStatusEnum | null
    in?: Enumerable<creditStatusEnum> | null
    notIn?: Enumerable<creditStatusEnum> | null
    not?: NestedEnumcreditStatusEnumNullableFilter | creditStatusEnum | null
  }

  export type NestedEnumSlicesEnumFilter = {
    equals?: SlicesEnum
    in?: Enumerable<SlicesEnum>
    notIn?: Enumerable<SlicesEnum>
    not?: NestedEnumSlicesEnumFilter | SlicesEnum
  }

  export type NestedEnumcreditRefTypeNullableWithAggregatesFilter = {
    equals?: creditRefType | null
    in?: Enumerable<creditRefType> | null
    notIn?: Enumerable<creditRefType> | null
    not?: NestedEnumcreditRefTypeNullableWithAggregatesFilter | creditRefType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumcreditRefTypeNullableFilter
    _max?: NestedEnumcreditRefTypeNullableFilter
  }

  export type NestedEnumcreditStatusEnumNullableWithAggregatesFilter = {
    equals?: creditStatusEnum | null
    in?: Enumerable<creditStatusEnum> | null
    notIn?: Enumerable<creditStatusEnum> | null
    not?: NestedEnumcreditStatusEnumNullableWithAggregatesFilter | creditStatusEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumcreditStatusEnumNullableFilter
    _max?: NestedEnumcreditStatusEnumNullableFilter
  }

  export type NestedEnumSlicesEnumWithAggregatesFilter = {
    equals?: SlicesEnum
    in?: Enumerable<SlicesEnum>
    notIn?: Enumerable<SlicesEnum>
    not?: NestedEnumSlicesEnumWithAggregatesFilter | SlicesEnum
    _count?: NestedIntFilter
    _min?: NestedEnumSlicesEnumFilter
    _max?: NestedEnumSlicesEnumFilter
  }

  export type NestedEnuminstallmentStatusTypeEnumNullableFilter = {
    equals?: installmentStatusTypeEnum | null
    in?: Enumerable<installmentStatusTypeEnum> | null
    notIn?: Enumerable<installmentStatusTypeEnum> | null
    not?: NestedEnuminstallmentStatusTypeEnumNullableFilter | installmentStatusTypeEnum | null
  }

  export type NestedEnuminstallmentStatusTypeEnumNullableWithAggregatesFilter = {
    equals?: installmentStatusTypeEnum | null
    in?: Enumerable<installmentStatusTypeEnum> | null
    notIn?: Enumerable<installmentStatusTypeEnum> | null
    not?: NestedEnuminstallmentStatusTypeEnumNullableWithAggregatesFilter | installmentStatusTypeEnum | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnuminstallmentStatusTypeEnumNullableFilter
    _max?: NestedEnuminstallmentStatusTypeEnumNullableFilter
  }

  export type NestedEnumActivityEntityTypeNullableFilter = {
    equals?: ActivityEntityType | null
    in?: Enumerable<ActivityEntityType> | null
    notIn?: Enumerable<ActivityEntityType> | null
    not?: NestedEnumActivityEntityTypeNullableFilter | ActivityEntityType | null
  }

  export type NestedEnumActivityPriorityNullableFilter = {
    equals?: ActivityPriority | null
    in?: Enumerable<ActivityPriority> | null
    notIn?: Enumerable<ActivityPriority> | null
    not?: NestedEnumActivityPriorityNullableFilter | ActivityPriority | null
  }

  export type NestedEnumActivityEntityTypeNullableWithAggregatesFilter = {
    equals?: ActivityEntityType | null
    in?: Enumerable<ActivityEntityType> | null
    notIn?: Enumerable<ActivityEntityType> | null
    not?: NestedEnumActivityEntityTypeNullableWithAggregatesFilter | ActivityEntityType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumActivityEntityTypeNullableFilter
    _max?: NestedEnumActivityEntityTypeNullableFilter
  }

  export type NestedEnumActivityPriorityNullableWithAggregatesFilter = {
    equals?: ActivityPriority | null
    in?: Enumerable<ActivityPriority> | null
    notIn?: Enumerable<ActivityPriority> | null
    not?: NestedEnumActivityPriorityNullableWithAggregatesFilter | ActivityPriority | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumActivityPriorityNullableFilter
    _max?: NestedEnumActivityPriorityNullableFilter
  }

  export type NestedEnumlanguageFilter = {
    equals?: language
    in?: Enumerable<language>
    notIn?: Enumerable<language>
    not?: NestedEnumlanguageFilter | language
  }

  export type NestedEnumlanguageWithAggregatesFilter = {
    equals?: language
    in?: Enumerable<language>
    notIn?: Enumerable<language>
    not?: NestedEnumlanguageWithAggregatesFilter | language
    _count?: NestedIntFilter
    _min?: NestedEnumlanguageFilter
    _max?: NestedEnumlanguageFilter
  }

  export type NestedEnumJobStatusFilter = {
    equals?: JobStatus
    in?: Enumerable<JobStatus>
    notIn?: Enumerable<JobStatus>
    not?: NestedEnumJobStatusFilter | JobStatus
  }

  export type NestedEnumJobStatusWithAggregatesFilter = {
    equals?: JobStatus
    in?: Enumerable<JobStatus>
    notIn?: Enumerable<JobStatus>
    not?: NestedEnumJobStatusWithAggregatesFilter | JobStatus
    _count?: NestedIntFilter
    _min?: NestedEnumJobStatusFilter
    _max?: NestedEnumJobStatusFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedEnumCreditConfigurationStatusFilter = {
    equals?: CreditConfigurationStatus
    in?: Enumerable<CreditConfigurationStatus>
    notIn?: Enumerable<CreditConfigurationStatus>
    not?: NestedEnumCreditConfigurationStatusFilter | CreditConfigurationStatus
  }

  export type NestedEnumCreditConfigurationStatusWithAggregatesFilter = {
    equals?: CreditConfigurationStatus
    in?: Enumerable<CreditConfigurationStatus>
    notIn?: Enumerable<CreditConfigurationStatus>
    not?: NestedEnumCreditConfigurationStatusWithAggregatesFilter | CreditConfigurationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumCreditConfigurationStatusFilter
    _max?: NestedEnumCreditConfigurationStatusFilter
  }

  export type NestedEnumTransactionMethodEnumFilter = {
    equals?: TransactionMethodEnum
    in?: Enumerable<TransactionMethodEnum>
    notIn?: Enumerable<TransactionMethodEnum>
    not?: NestedEnumTransactionMethodEnumFilter | TransactionMethodEnum
  }

  export type NestedEnumTransactionMethodEnumWithAggregatesFilter = {
    equals?: TransactionMethodEnum
    in?: Enumerable<TransactionMethodEnum>
    notIn?: Enumerable<TransactionMethodEnum>
    not?: NestedEnumTransactionMethodEnumWithAggregatesFilter | TransactionMethodEnum
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionMethodEnumFilter
    _max?: NestedEnumTransactionMethodEnumFilter
  }

  export type NestedEnumanswerTypeEnumFilter = {
    equals?: answerTypeEnum
    in?: Enumerable<answerTypeEnum>
    notIn?: Enumerable<answerTypeEnum>
    not?: NestedEnumanswerTypeEnumFilter | answerTypeEnum
  }

  export type NestedEnumQuestionCategoryEnumFilter = {
    equals?: QuestionCategoryEnum
    in?: Enumerable<QuestionCategoryEnum>
    notIn?: Enumerable<QuestionCategoryEnum>
    not?: NestedEnumQuestionCategoryEnumFilter | QuestionCategoryEnum
  }

  export type NestedEnumanswerTypeEnumWithAggregatesFilter = {
    equals?: answerTypeEnum
    in?: Enumerable<answerTypeEnum>
    notIn?: Enumerable<answerTypeEnum>
    not?: NestedEnumanswerTypeEnumWithAggregatesFilter | answerTypeEnum
    _count?: NestedIntFilter
    _min?: NestedEnumanswerTypeEnumFilter
    _max?: NestedEnumanswerTypeEnumFilter
  }

  export type NestedEnumQuestionCategoryEnumWithAggregatesFilter = {
    equals?: QuestionCategoryEnum
    in?: Enumerable<QuestionCategoryEnum>
    notIn?: Enumerable<QuestionCategoryEnum>
    not?: NestedEnumQuestionCategoryEnumWithAggregatesFilter | QuestionCategoryEnum
    _count?: NestedIntFilter
    _min?: NestedEnumQuestionCategoryEnumFilter
    _max?: NestedEnumQuestionCategoryEnumFilter
  }

  export type NestedEnumCreditRequestStatusFilter = {
    equals?: CreditRequestStatus
    in?: Enumerable<CreditRequestStatus>
    notIn?: Enumerable<CreditRequestStatus>
    not?: NestedEnumCreditRequestStatusFilter | CreditRequestStatus
  }

  export type NestedEnumCreditRequestStatusWithAggregatesFilter = {
    equals?: CreditRequestStatus
    in?: Enumerable<CreditRequestStatus>
    notIn?: Enumerable<CreditRequestStatus>
    not?: NestedEnumCreditRequestStatusWithAggregatesFilter | CreditRequestStatus
    _count?: NestedIntFilter
    _min?: NestedEnumCreditRequestStatusFilter
    _max?: NestedEnumCreditRequestStatusFilter
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    entityId?: string | null
    entityType?: ActivityEntityType | null
    priority?: ActivityPriority | null
    phoneNumber?: string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean | null
    createdAt?: Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    entityId?: string | null
    entityType?: ActivityEntityType | null
    priority?: ActivityPriority | null
    phoneNumber?: string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean | null
    createdAt?: Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: Enumerable<ActivityCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AnswerCreateWithoutAnsweredInput = {
    id?: string
    createdAt?: Date | string
    answer: string
    answeredByReference?: string | null
    wallet: WalletCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutAnsweredInput = {
    id?: string
    questionId: string
    createdAt?: Date | string
    answer: string
    answeredByReference?: string | null
    account: string
  }

  export type AnswerCreateOrConnectWithoutAnsweredInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutAnsweredInput, AnswerUncheckedCreateWithoutAnsweredInput>
  }

  export type AnswerCreateManyAnsweredInputEnvelope = {
    data: Enumerable<AnswerCreateManyAnsweredInput>
    skipDuplicates?: boolean
  }

  export type CreditCreateWithoutAffiliateInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutCreditInput
    creditor?: WalletCreateNestedOneWithoutCreditorCreditInput
    debtor?: WalletCreateNestedOneWithoutDebtorCreditInput
    order?: OrderCreateNestedOneWithoutCreditInput
    user?: UserCreateNestedOneWithoutCreditsInput
    installments?: InstallmentCreateNestedManyWithoutCreditInput
  }

  export type CreditUncheckedCreateWithoutAffiliateInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditCreateOrConnectWithoutAffiliateInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutAffiliateInput, CreditUncheckedCreateWithoutAffiliateInput>
  }

  export type CreditCreateManyAffiliateInputEnvelope = {
    data: Enumerable<CreditCreateManyAffiliateInput>
    skipDuplicates?: boolean
  }

  export type CreditCreateWithoutUserInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    affiliate?: UserCreateNestedOneWithoutCreditsAffilateInput
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutCreditInput
    creditor?: WalletCreateNestedOneWithoutCreditorCreditInput
    debtor?: WalletCreateNestedOneWithoutDebtorCreditInput
    order?: OrderCreateNestedOneWithoutCreditInput
    installments?: InstallmentCreateNestedManyWithoutCreditInput
  }

  export type CreditUncheckedCreateWithoutUserInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditCreateOrConnectWithoutUserInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutUserInput, CreditUncheckedCreateWithoutUserInput>
  }

  export type CreditCreateManyUserInputEnvelope = {
    data: Enumerable<CreditCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type InstallmentCreateWithoutUserInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutInstallmentInput
    credit?: CreditCreateNestedOneWithoutInstallmentsInput
    creditor?: WalletCreateNestedOneWithoutCreditorInstallmentsInput
    debtor?: WalletCreateNestedOneWithoutDebtorInstallmentsInput
    order?: OrderCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentUncheckedCreateWithoutUserInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentCreateOrConnectWithoutUserInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutUserInput, InstallmentUncheckedCreateWithoutUserInput>
  }

  export type InstallmentCreateManyUserInputEnvelope = {
    data: Enumerable<InstallmentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LoginCreateWithoutUserInput = {
    id?: string
    qrKey?: string | null
    jwt?: string | null
    createdAt?: Date | string
  }

  export type LoginUncheckedCreateWithoutUserInput = {
    id?: string
    qrKey?: string | null
    jwt?: string | null
    createdAt?: Date | string
  }

  export type LoginCreateOrConnectWithoutUserInput = {
    where: LoginWhereUniqueInput
    create: XOR<LoginCreateWithoutUserInput, LoginUncheckedCreateWithoutUserInput>
  }

  export type LoginCreateManyUserInputEnvelope = {
    data: Enumerable<LoginCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutAffiliateInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    billing?: BillingCreateNestedOneWithoutOrderInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutAffiliateInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutAffiliateInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutAffiliateInput, OrderUncheckedCreateWithoutAffiliateInput>
  }

  export type OrderCreateManyAffiliateInputEnvelope = {
    data: Enumerable<OrderCreateManyAffiliateInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    billing?: BillingCreateNestedOneWithoutOrderInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: Enumerable<OrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OtherMemberKYCCreateWithoutCreatedByInput = {
    id?: string
    name: string
    documentId: string
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    profilePictureURL: string
    idCardURL: string
    createdAt?: Date | string
    userIdToKYC: string
    OTP: string
  }

  export type OtherMemberKYCUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    documentId: string
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    profilePictureURL: string
    idCardURL: string
    createdAt?: Date | string
    userIdToKYC: string
    OTP: string
  }

  export type OtherMemberKYCCreateOrConnectWithoutCreatedByInput = {
    where: OtherMemberKYCWhereUniqueInput
    create: XOR<OtherMemberKYCCreateWithoutCreatedByInput, OtherMemberKYCUncheckedCreateWithoutCreatedByInput>
  }

  export type OtherMemberKYCCreateManyCreatedByInputEnvelope = {
    data: Enumerable<OtherMemberKYCCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutAffiliateInput = {
    id?: string
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
    vendorWallet?: WalletCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAffiliateInput = {
    id?: string
    vendorId?: string | null
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
  }

  export type ProductCreateOrConnectWithoutAffiliateInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAffiliateInput, ProductUncheckedCreateWithoutAffiliateInput>
  }

  export type ProductCreateManyAffiliateInputEnvelope = {
    data: Enumerable<ProductCreateManyAffiliateInput>
    skipDuplicates?: boolean
  }

  export type SettlementCreateWithoutSettlementCreatorInput = {
    id?: string
    type: TransactionMethodEnum
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    createdAt?: Date | string
    createdByAgent: boolean
    wallet: WalletCreateNestedOneWithoutSettlementInput
    settlementVerifier?: UserCreateNestedOneWithoutSettlementInput
    Wallet?: WalletCreateNestedManyWithoutSettlementDefaultInput
  }

  export type SettlementUncheckedCreateWithoutSettlementCreatorInput = {
    id?: string
    type: TransactionMethodEnum
    account: string
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    verifiedByUser?: string | null
    createdAt?: Date | string
    createdByAgent: boolean
    Wallet?: WalletUncheckedCreateNestedManyWithoutSettlementDefaultInput
  }

  export type SettlementCreateOrConnectWithoutSettlementCreatorInput = {
    where: SettlementWhereUniqueInput
    create: XOR<SettlementCreateWithoutSettlementCreatorInput, SettlementUncheckedCreateWithoutSettlementCreatorInput>
  }

  export type SettlementCreateManySettlementCreatorInputEnvelope = {
    data: Enumerable<SettlementCreateManySettlementCreatorInput>
    skipDuplicates?: boolean
  }

  export type UsersWalletsCreateWithoutUserInput = {
    role?: WalletRole
    wallet: WalletCreateNestedOneWithoutUsersWalletsInput
  }

  export type UsersWalletsUncheckedCreateWithoutUserInput = {
    walletId: string
    role?: WalletRole
  }

  export type UsersWalletsCreateOrConnectWithoutUserInput = {
    where: UsersWalletsWhereUniqueInput
    create: XOR<UsersWalletsCreateWithoutUserInput, UsersWalletsUncheckedCreateWithoutUserInput>
  }

  export type UsersWalletsCreateManyUserInputEnvelope = {
    data: Enumerable<UsersWalletsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type VerifyCreateWithoutUserInput = {
    id?: string
    UID?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    createdAt?: Date | string | null
    creditConfigId?: string | null
    OTP?: string | null
    email?: string | null
    orderPaymentMethod?: OrderPaymentMethodsEnum | null
  }

  export type VerifyUncheckedCreateWithoutUserInput = {
    id?: string
    UID?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    createdAt?: Date | string | null
    creditConfigId?: string | null
    OTP?: string | null
    email?: string | null
    orderPaymentMethod?: OrderPaymentMethodsEnum | null
  }

  export type VerifyCreateOrConnectWithoutUserInput = {
    where: VerifyWhereUniqueInput
    create: XOR<VerifyCreateWithoutUserInput, VerifyUncheckedCreateWithoutUserInput>
  }

  export type VerifyCreateManyUserInputEnvelope = {
    data: Enumerable<VerifyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type VisitCreateWithoutVisitedInput = {
    id?: string
    createdAt?: Date | string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
    wallet: WalletCreateNestedOneWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutVisitedInput = {
    id?: string
    account: string
    createdAt?: Date | string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
  }

  export type VisitCreateOrConnectWithoutVisitedInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutVisitedInput, VisitUncheckedCreateWithoutVisitedInput>
  }

  export type VisitCreateManyVisitedInputEnvelope = {
    data: Enumerable<VisitCreateManyVisitedInput>
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutUsersInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutUsersInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutUsersInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUsersInput, WalletUncheckedCreateWithoutUsersInput>
  }

  export type SettlementCreateWithoutSettlementVerifierInput = {
    id?: string
    type: TransactionMethodEnum
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    createdAt?: Date | string
    createdByAgent: boolean
    wallet: WalletCreateNestedOneWithoutSettlementInput
    settlementCreator: UserCreateNestedOneWithoutSettlementInput
    Wallet?: WalletCreateNestedManyWithoutSettlementDefaultInput
  }

  export type SettlementUncheckedCreateWithoutSettlementVerifierInput = {
    id?: string
    type: TransactionMethodEnum
    account: string
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    createdAt?: Date | string
    createdBy: string
    createdByAgent: boolean
    Wallet?: WalletUncheckedCreateNestedManyWithoutSettlementDefaultInput
  }

  export type SettlementCreateOrConnectWithoutSettlementVerifierInput = {
    where: SettlementWhereUniqueInput
    create: XOR<SettlementCreateWithoutSettlementVerifierInput, SettlementUncheckedCreateWithoutSettlementVerifierInput>
  }

  export type SettlementCreateManySettlementVerifierInputEnvelope = {
    data: Enumerable<SettlementCreateManySettlementVerifierInput>
    skipDuplicates?: boolean
  }

  export type CreditRequestCreateWithoutUserInput = {
    id?: string
    status?: CreditRequestStatus
    wallet: string
    order?: OrderCreateNestedOneWithoutCreditRequestInput
    creditConfiguration?: CreditConfigurationCreateNestedOneWithoutCreditRequestsInput
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestUncheckedCreateWithoutUserInput = {
    id?: string
    status?: CreditRequestStatus
    orderId: string
    wallet: string
    creditConfigurationId: string
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestCreateOrConnectWithoutUserInput = {
    where: CreditRequestWhereUniqueInput
    create: XOR<CreditRequestCreateWithoutUserInput, CreditRequestUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: Enumerable<ActivityScalarWhereInput>
    OR?: Enumerable<ActivityScalarWhereInput>
    NOT?: Enumerable<ActivityScalarWhereInput>
    id?: StringFilter | string
    entityId?: StringNullableFilter | string | null
    entityType?: EnumActivityEntityTypeNullableFilter | ActivityEntityType | null
    priority?: EnumActivityPriorityNullableFilter | ActivityPriority | null
    phoneNumber?: StringNullableFilter | string | null
    message?: JsonNullableFilter
    isRead?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    entity?: JsonNullableFilter
    userId?: StringNullableFilter | string | null
  }

  export type AnswerUpsertWithWhereUniqueWithoutAnsweredInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutAnsweredInput, AnswerUncheckedUpdateWithoutAnsweredInput>
    create: XOR<AnswerCreateWithoutAnsweredInput, AnswerUncheckedCreateWithoutAnsweredInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutAnsweredInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutAnsweredInput, AnswerUncheckedUpdateWithoutAnsweredInput>
  }

  export type AnswerUpdateManyWithWhereWithoutAnsweredInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAnswersInput>
  }

  export type AnswerScalarWhereInput = {
    AND?: Enumerable<AnswerScalarWhereInput>
    OR?: Enumerable<AnswerScalarWhereInput>
    NOT?: Enumerable<AnswerScalarWhereInput>
    id?: StringFilter | string
    questionId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    answer?: StringFilter | string
    answeredBy?: StringNullableFilter | string | null
    answeredByReference?: StringNullableFilter | string | null
    account?: StringFilter | string
  }

  export type CreditUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: CreditWhereUniqueInput
    update: XOR<CreditUpdateWithoutAffiliateInput, CreditUncheckedUpdateWithoutAffiliateInput>
    create: XOR<CreditCreateWithoutAffiliateInput, CreditUncheckedCreateWithoutAffiliateInput>
  }

  export type CreditUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: CreditWhereUniqueInput
    data: XOR<CreditUpdateWithoutAffiliateInput, CreditUncheckedUpdateWithoutAffiliateInput>
  }

  export type CreditUpdateManyWithWhereWithoutAffiliateInput = {
    where: CreditScalarWhereInput
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyWithoutCreditsAffilateInput>
  }

  export type CreditScalarWhereInput = {
    AND?: Enumerable<CreditScalarWhereInput>
    OR?: Enumerable<CreditScalarWhereInput>
    NOT?: Enumerable<CreditScalarWhereInput>
    id?: StringFilter | string
    typeId?: StringNullableFilter | string | null
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    orderId?: StringNullableFilter | string | null
    type?: EnumcreditRefTypeNullableFilter | creditRefType | null
    amount?: FloatNullableFilter | number | null
    debtorId?: StringNullableFilter | string | null
    creditorId?: StringNullableFilter | string | null
    installmentsCount?: IntNullableFilter | number | null
    installmentsCountPaid?: IntNullableFilter | number | null
    status?: EnumcreditStatusEnumNullableFilter | creditStatusEnum | null
    description?: StringNullableFilter | string | null
    totalPaid?: FloatNullableFilter | number | null
    totalToPay?: FloatNullableFilter | number | null
    agreedDate?: DateTimeNullableFilter | Date | string | null
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    referenceNumber?: StringFilter | string
    creditConfigurationId?: StringFilter | string
    endDate?: DateTimeNullableFilter | Date | string | null
    paidAt?: DateTimeNullableFilter | Date | string | null
    duration?: IntNullableFilter | number | null
    durationSlices?: EnumSlicesEnumFilter | SlicesEnum
    affiliateId?: StringNullableFilter | string | null
    defaultAt?: DateTimeNullableFilter | Date | string | null
    fundUpfrontAmount?: FloatNullableFilter | number | null
    orderWalletId?: StringNullableFilter | string | null
    fundFeesAmount?: FloatNullableFilter | number | null
    amountWithFees?: FloatNullableFilter | number | null
    seviFeesAmount?: FloatNullableFilter | number | null
    orderWalletShareFeesAmount?: FloatNullableFilter | number | null
    fundPostDeliveryAmount?: FloatNullableFilter | number | null
  }

  export type CreditUpsertWithWhereUniqueWithoutUserInput = {
    where: CreditWhereUniqueInput
    update: XOR<CreditUpdateWithoutUserInput, CreditUncheckedUpdateWithoutUserInput>
    create: XOR<CreditCreateWithoutUserInput, CreditUncheckedCreateWithoutUserInput>
  }

  export type CreditUpdateWithWhereUniqueWithoutUserInput = {
    where: CreditWhereUniqueInput
    data: XOR<CreditUpdateWithoutUserInput, CreditUncheckedUpdateWithoutUserInput>
  }

  export type CreditUpdateManyWithWhereWithoutUserInput = {
    where: CreditScalarWhereInput
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyWithoutCreditsInput>
  }

  export type InstallmentUpsertWithWhereUniqueWithoutUserInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutUserInput, InstallmentUncheckedUpdateWithoutUserInput>
    create: XOR<InstallmentCreateWithoutUserInput, InstallmentUncheckedCreateWithoutUserInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutUserInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutUserInput, InstallmentUncheckedUpdateWithoutUserInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutUserInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutInstallmentInput>
  }

  export type InstallmentScalarWhereInput = {
    AND?: Enumerable<InstallmentScalarWhereInput>
    OR?: Enumerable<InstallmentScalarWhereInput>
    NOT?: Enumerable<InstallmentScalarWhereInput>
    id?: StringFilter | string
    installmentCount?: IntNullableFilter | number | null
    startDate?: DateTimeNullableFilter | Date | string | null
    endDate?: DateTimeNullableFilter | Date | string | null
    referenceNumber?: StringNullableFilter | string | null
    amount?: FloatFilter | number
    paidAmount?: FloatFilter | number
    debtorId?: StringNullableFilter | string | null
    creditorId?: StringNullableFilter | string | null
    orderId?: StringNullableFilter | string | null
    status?: EnuminstallmentStatusTypeEnumNullableFilter | installmentStatusTypeEnum | null
    firstTryFailedAt?: DateTimeNullableFilter | Date | string | null
    creditId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    userId?: StringNullableFilter | string | null
    amountWithPenalty?: FloatFilter | number
    seviFees?: FloatFilter | number
    penalty?: FloatFilter | number
    paidAt?: DateTimeNullableFilter | Date | string | null
    creditConfigurationId?: StringFilter | string
    affiliateFees?: FloatFilter | number
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
  }

  export type LoginUpsertWithWhereUniqueWithoutUserInput = {
    where: LoginWhereUniqueInput
    update: XOR<LoginUpdateWithoutUserInput, LoginUncheckedUpdateWithoutUserInput>
    create: XOR<LoginCreateWithoutUserInput, LoginUncheckedCreateWithoutUserInput>
  }

  export type LoginUpdateWithWhereUniqueWithoutUserInput = {
    where: LoginWhereUniqueInput
    data: XOR<LoginUpdateWithoutUserInput, LoginUncheckedUpdateWithoutUserInput>
  }

  export type LoginUpdateManyWithWhereWithoutUserInput = {
    where: LoginScalarWhereInput
    data: XOR<LoginUpdateManyMutationInput, LoginUncheckedUpdateManyWithoutLoginInput>
  }

  export type LoginScalarWhereInput = {
    AND?: Enumerable<LoginScalarWhereInput>
    OR?: Enumerable<LoginScalarWhereInput>
    NOT?: Enumerable<LoginScalarWhereInput>
    id?: StringFilter | string
    qrKey?: StringNullableFilter | string | null
    jwt?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutAffiliateInput, OrderUncheckedUpdateWithoutAffiliateInput>
    create: XOR<OrderCreateWithoutAffiliateInput, OrderUncheckedCreateWithoutAffiliateInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutAffiliateInput, OrderUncheckedUpdateWithoutAffiliateInput>
  }

  export type OrderUpdateManyWithWhereWithoutAffiliateInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersAffiliateInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    vendorId?: StringNullableFilter | string | null
    status?: EnumOrderStatusEnumNullableFilter | OrderStatusEnum | null
    notes?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    affiliateId?: StringNullableFilter | string | null
    products?: JsonNullableFilter
    items?: JsonNullableFilter
    deliveryCode?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    paymentStatus?: EnumPaymentStatusEnumFilter | PaymentStatusEnum
    amount?: FloatFilter | number
    paymentMethod?: EnumOrderPaymentMethodsEnumNullableFilter | OrderPaymentMethodsEnum | null
    billingId?: StringNullableFilter | string | null
    shippingId?: StringNullableFilter | string | null
    ecommercePlatform?: EnumEcommercePlatformEnumNullableFilter | EcommercePlatformEnum | null
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    platformId?: StringNullableFilter | string | null
    customerId?: StringNullableFilter | string | null
    referenceNumber?: StringNullableFilter | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OtherMemberKYCUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OtherMemberKYCWhereUniqueInput
    update: XOR<OtherMemberKYCUpdateWithoutCreatedByInput, OtherMemberKYCUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OtherMemberKYCCreateWithoutCreatedByInput, OtherMemberKYCUncheckedCreateWithoutCreatedByInput>
  }

  export type OtherMemberKYCUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OtherMemberKYCWhereUniqueInput
    data: XOR<OtherMemberKYCUpdateWithoutCreatedByInput, OtherMemberKYCUncheckedUpdateWithoutCreatedByInput>
  }

  export type OtherMemberKYCUpdateManyWithWhereWithoutCreatedByInput = {
    where: OtherMemberKYCScalarWhereInput
    data: XOR<OtherMemberKYCUpdateManyMutationInput, OtherMemberKYCUncheckedUpdateManyWithoutOtherMemberKYCInput>
  }

  export type OtherMemberKYCScalarWhereInput = {
    AND?: Enumerable<OtherMemberKYCScalarWhereInput>
    OR?: Enumerable<OtherMemberKYCScalarWhereInput>
    NOT?: Enumerable<OtherMemberKYCScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    documentId?: StringFilter | string
    documentCountry?: EnumCountryCodeNullableFilter | CountryCode | null
    documentData?: JsonNullableFilter
    documentFirstName?: StringNullableFilter | string | null
    documentLastName?: StringNullableFilter | string | null
    documentImage?: StringNullableFilter | string | null
    documentGender?: EnumGenderEnumNullableFilter | GenderEnum | null
    documentDateOfBirth?: DateTimeNullableFilter | Date | string | null
    documentDateOfIssue?: DateTimeNullableFilter | Date | string | null
    documentSerialNumber?: StringNullableFilter | string | null
    documentCreatedAt?: DateTimeNullableFilter | Date | string | null
    profilePictureURL?: StringFilter | string
    idCardURL?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    createdByUserId?: StringFilter | string
    userIdToKYC?: StringFilter | string
    OTP?: StringFilter | string
  }

  export type ProductUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutAffiliateInput, ProductUncheckedUpdateWithoutAffiliateInput>
    create: XOR<ProductCreateWithoutAffiliateInput, ProductUncheckedCreateWithoutAffiliateInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutAffiliateInput, ProductUncheckedUpdateWithoutAffiliateInput>
  }

  export type ProductUpdateManyWithWhereWithoutAffiliateInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    vendorId?: StringNullableFilter | string | null
    quantity?: IntNullableFilter | number | null
    vendorName?: StringNullableFilter | string | null
    vendorType?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    price?: FloatNullableFilter | number | null
    unitPrice?: FloatNullableFilter | number | null
    listedPublic?: BoolNullableFilter | boolean | null
    description?: StringNullableFilter | string | null
    gallery?: JsonNullableFilter
    categories?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    ecommercePlatform?: EnumEcommercePlatformEnumNullableFilter | EcommercePlatformEnum | null
    platformId?: StringNullableFilter | string | null
    affiliateId?: StringNullableFilter | string | null
  }

  export type SettlementUpsertWithWhereUniqueWithoutSettlementCreatorInput = {
    where: SettlementWhereUniqueInput
    update: XOR<SettlementUpdateWithoutSettlementCreatorInput, SettlementUncheckedUpdateWithoutSettlementCreatorInput>
    create: XOR<SettlementCreateWithoutSettlementCreatorInput, SettlementUncheckedCreateWithoutSettlementCreatorInput>
  }

  export type SettlementUpdateWithWhereUniqueWithoutSettlementCreatorInput = {
    where: SettlementWhereUniqueInput
    data: XOR<SettlementUpdateWithoutSettlementCreatorInput, SettlementUncheckedUpdateWithoutSettlementCreatorInput>
  }

  export type SettlementUpdateManyWithWhereWithoutSettlementCreatorInput = {
    where: SettlementScalarWhereInput
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyWithoutSettlementInput>
  }

  export type SettlementScalarWhereInput = {
    AND?: Enumerable<SettlementScalarWhereInput>
    OR?: Enumerable<SettlementScalarWhereInput>
    NOT?: Enumerable<SettlementScalarWhereInput>
    id?: StringFilter | string
    type?: EnumTransactionMethodEnumFilter | TransactionMethodEnum
    account?: StringFilter | string
    bankAccount?: StringNullableFilter | string | null
    bankAccountName?: StringNullableFilter | string | null
    bankBranch?: StringNullableFilter | string | null
    bankName?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    tillNumber?: StringNullableFilter | string | null
    paybillNumber?: StringNullableFilter | string | null
    verified?: BoolNullableFilter | boolean | null
    verifiedByUser?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    createdBy?: StringFilter | string
    createdByAgent?: BoolFilter | boolean
  }

  export type UsersWalletsUpsertWithWhereUniqueWithoutUserInput = {
    where: UsersWalletsWhereUniqueInput
    update: XOR<UsersWalletsUpdateWithoutUserInput, UsersWalletsUncheckedUpdateWithoutUserInput>
    create: XOR<UsersWalletsCreateWithoutUserInput, UsersWalletsUncheckedCreateWithoutUserInput>
  }

  export type UsersWalletsUpdateWithWhereUniqueWithoutUserInput = {
    where: UsersWalletsWhereUniqueInput
    data: XOR<UsersWalletsUpdateWithoutUserInput, UsersWalletsUncheckedUpdateWithoutUserInput>
  }

  export type UsersWalletsUpdateManyWithWhereWithoutUserInput = {
    where: UsersWalletsScalarWhereInput
    data: XOR<UsersWalletsUpdateManyMutationInput, UsersWalletsUncheckedUpdateManyWithoutUsersWalletsInput>
  }

  export type UsersWalletsScalarWhereInput = {
    AND?: Enumerable<UsersWalletsScalarWhereInput>
    OR?: Enumerable<UsersWalletsScalarWhereInput>
    NOT?: Enumerable<UsersWalletsScalarWhereInput>
    userId?: StringFilter | string
    walletId?: StringFilter | string
    role?: EnumWalletRoleFilter | WalletRole
  }

  export type VerifyUpsertWithWhereUniqueWithoutUserInput = {
    where: VerifyWhereUniqueInput
    update: XOR<VerifyUpdateWithoutUserInput, VerifyUncheckedUpdateWithoutUserInput>
    create: XOR<VerifyCreateWithoutUserInput, VerifyUncheckedCreateWithoutUserInput>
  }

  export type VerifyUpdateWithWhereUniqueWithoutUserInput = {
    where: VerifyWhereUniqueInput
    data: XOR<VerifyUpdateWithoutUserInput, VerifyUncheckedUpdateWithoutUserInput>
  }

  export type VerifyUpdateManyWithWhereWithoutUserInput = {
    where: VerifyScalarWhereInput
    data: XOR<VerifyUpdateManyMutationInput, VerifyUncheckedUpdateManyWithoutVerifyInput>
  }

  export type VerifyScalarWhereInput = {
    AND?: Enumerable<VerifyScalarWhereInput>
    OR?: Enumerable<VerifyScalarWhereInput>
    NOT?: Enumerable<VerifyScalarWhereInput>
    id?: StringFilter | string
    UID?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    countryCode?: EnumCountryCodeNullableFilter | CountryCode | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    creditConfigId?: StringNullableFilter | string | null
    OTP?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    userId?: StringNullableFilter | string | null
    orderPaymentMethod?: EnumOrderPaymentMethodsEnumNullableFilter | OrderPaymentMethodsEnum | null
  }

  export type VisitUpsertWithWhereUniqueWithoutVisitedInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutVisitedInput, VisitUncheckedUpdateWithoutVisitedInput>
    create: XOR<VisitCreateWithoutVisitedInput, VisitUncheckedCreateWithoutVisitedInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutVisitedInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutVisitedInput, VisitUncheckedUpdateWithoutVisitedInput>
  }

  export type VisitUpdateManyWithWhereWithoutVisitedInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutVisitInput>
  }

  export type VisitScalarWhereInput = {
    AND?: Enumerable<VisitScalarWhereInput>
    OR?: Enumerable<VisitScalarWhereInput>
    NOT?: Enumerable<VisitScalarWhereInput>
    id?: StringFilter | string
    account?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    visitedBy?: StringNullableFilter | string | null
    visitedByReference?: StringNullableFilter | string | null
    whenVisitTookPlace?: DateTimeNullableFilter | Date | string | null
  }

  export type WalletUpsertWithWhereUniqueWithoutUsersInput = {
    where: WalletWhereUniqueInput
    update: XOR<WalletUpdateWithoutUsersInput, WalletUncheckedUpdateWithoutUsersInput>
    create: XOR<WalletCreateWithoutUsersInput, WalletUncheckedCreateWithoutUsersInput>
  }

  export type WalletUpdateWithWhereUniqueWithoutUsersInput = {
    where: WalletWhereUniqueInput
    data: XOR<WalletUpdateWithoutUsersInput, WalletUncheckedUpdateWithoutUsersInput>
  }

  export type WalletUpdateManyWithWhereWithoutUsersInput = {
    where: WalletScalarWhereInput
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyWithoutWalletsInput>
  }

  export type WalletScalarWhereInput = {
    AND?: Enumerable<WalletScalarWhereInput>
    OR?: Enumerable<WalletScalarWhereInput>
    NOT?: Enumerable<WalletScalarWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    category?: StringNullableFilter | string | null
    type?: EnumWalletTypesEnumFilter | WalletTypesEnum
    balance?: FloatFilter | number
    account?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    currency?: EnumCurrencyEnumNullableFilter | CurrencyEnum | null
    settlementAutomatic?: BoolNullableFilter | boolean | null
    settlementDefaultId?: StringNullableFilter | string | null
    verificationStartedAt?: DateTimeNullableFilter | Date | string | null
    shippingId?: StringNullableFilter | string | null
    picture?: StringNullableFilter | string | null
  }

  export type SettlementUpsertWithWhereUniqueWithoutSettlementVerifierInput = {
    where: SettlementWhereUniqueInput
    update: XOR<SettlementUpdateWithoutSettlementVerifierInput, SettlementUncheckedUpdateWithoutSettlementVerifierInput>
    create: XOR<SettlementCreateWithoutSettlementVerifierInput, SettlementUncheckedCreateWithoutSettlementVerifierInput>
  }

  export type SettlementUpdateWithWhereUniqueWithoutSettlementVerifierInput = {
    where: SettlementWhereUniqueInput
    data: XOR<SettlementUpdateWithoutSettlementVerifierInput, SettlementUncheckedUpdateWithoutSettlementVerifierInput>
  }

  export type SettlementUpdateManyWithWhereWithoutSettlementVerifierInput = {
    where: SettlementScalarWhereInput
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyWithoutSettlementInput>
  }

  export type CreditRequestUpsertWithoutUserInput = {
    update: XOR<CreditRequestUpdateWithoutUserInput, CreditRequestUncheckedUpdateWithoutUserInput>
    create: XOR<CreditRequestCreateWithoutUserInput, CreditRequestUncheckedCreateWithoutUserInput>
  }

  export type CreditRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    wallet?: StringFieldUpdateOperationsInput | string
    order?: OrderUpdateOneWithoutCreditRequestInput
    creditConfiguration?: CreditConfigurationUpdateOneWithoutCreditRequestsInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    orderId?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUsersWalletsInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsersWalletsInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsersWalletsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsersWalletsInput, UserUncheckedCreateWithoutUsersWalletsInput>
  }

  export type WalletCreateWithoutUsersWalletsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutUsersWalletsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutUsersWalletsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUsersWalletsInput, WalletUncheckedCreateWithoutUsersWalletsInput>
  }

  export type UserUpsertWithoutUsersWalletsInput = {
    update: XOR<UserUpdateWithoutUsersWalletsInput, UserUncheckedUpdateWithoutUsersWalletsInput>
    create: XOR<UserCreateWithoutUsersWalletsInput, UserUncheckedCreateWithoutUsersWalletsInput>
  }

  export type UserUpdateWithoutUsersWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUsersWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type WalletUpsertWithoutUsersWalletsInput = {
    update: XOR<WalletUpdateWithoutUsersWalletsInput, WalletUncheckedUpdateWithoutUsersWalletsInput>
    create: XOR<WalletCreateWithoutUsersWalletsInput, WalletUncheckedCreateWithoutUsersWalletsInput>
  }

  export type WalletUpdateWithoutUsersWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutUsersWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletCreateWithoutCustomerInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutCustomerInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutCustomerInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutCustomerInput, WalletUncheckedCreateWithoutCustomerInput>
  }

  export type WalletCreateWithoutVendorInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutVendorInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutVendorInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutVendorInput, WalletUncheckedCreateWithoutVendorInput>
  }

  export type WalletUpsertWithoutCustomerInput = {
    update: XOR<WalletUpdateWithoutCustomerInput, WalletUncheckedUpdateWithoutCustomerInput>
    create: XOR<WalletCreateWithoutCustomerInput, WalletUncheckedCreateWithoutCustomerInput>
  }

  export type WalletUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletUpsertWithoutVendorInput = {
    update: XOR<WalletUpdateWithoutVendorInput, WalletUncheckedUpdateWithoutVendorInput>
    create: XOR<WalletCreateWithoutVendorInput, WalletUncheckedCreateWithoutVendorInput>
  }

  export type WalletUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletCreateWithoutSupplierInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutSupplierInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutSupplierInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutSupplierInput, WalletUncheckedCreateWithoutSupplierInput>
  }

  export type WalletCreateWithoutVendorSupplierInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutVendorSupplierInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutVendorSupplierInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutVendorSupplierInput, WalletUncheckedCreateWithoutVendorSupplierInput>
  }

  export type WalletUpsertWithoutSupplierInput = {
    update: XOR<WalletUpdateWithoutSupplierInput, WalletUncheckedUpdateWithoutSupplierInput>
    create: XOR<WalletCreateWithoutSupplierInput, WalletUncheckedCreateWithoutSupplierInput>
  }

  export type WalletUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletUpsertWithoutVendorSupplierInput = {
    update: XOR<WalletUpdateWithoutVendorSupplierInput, WalletUncheckedUpdateWithoutVendorSupplierInput>
    create: XOR<WalletCreateWithoutVendorSupplierInput, WalletUncheckedCreateWithoutVendorSupplierInput>
  }

  export type WalletUpdateWithoutVendorSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutVendorSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletCreateWithoutBadgesInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutBadgesInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutBadgesInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutBadgesInput, WalletUncheckedCreateWithoutBadgesInput>
  }

  export type WalletUpsertWithoutBadgesInput = {
    update: XOR<WalletUpdateWithoutBadgesInput, WalletUncheckedUpdateWithoutBadgesInput>
    create: XOR<WalletCreateWithoutBadgesInput, WalletUncheckedCreateWithoutBadgesInput>
  }

  export type WalletUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type SettlementCreateWithoutWalletInput = {
    id?: string
    type: TransactionMethodEnum
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    createdAt?: Date | string
    createdByAgent: boolean
    wallet: WalletCreateNestedOneWithoutSettlementInput
    settlementCreator: UserCreateNestedOneWithoutSettlementInput
    settlementVerifier?: UserCreateNestedOneWithoutSettlementInput
  }

  export type SettlementUncheckedCreateWithoutWalletInput = {
    id?: string
    type: TransactionMethodEnum
    account: string
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    verifiedByUser?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByAgent: boolean
  }

  export type SettlementCreateOrConnectWithoutWalletInput = {
    where: SettlementWhereUniqueInput
    create: XOR<SettlementCreateWithoutWalletInput, SettlementUncheckedCreateWithoutWalletInput>
  }

  export type AnswerCreateWithoutWalletInput = {
    id?: string
    createdAt?: Date | string
    answer: string
    answeredByReference?: string | null
    answered?: UserCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutWalletInput = {
    id?: string
    questionId: string
    createdAt?: Date | string
    answer: string
    answeredBy?: string | null
    answeredByReference?: string | null
  }

  export type AnswerCreateOrConnectWithoutWalletInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutWalletInput, AnswerUncheckedCreateWithoutWalletInput>
  }

  export type AnswerCreateManyWalletInputEnvelope = {
    data: Enumerable<AnswerCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type BadgeCreateWithoutWalletInput = {
    id?: string
    active?: boolean | null
    createdAt?: Date | string | null
    type?: BadgeType | null
    count?: number | null
    level?: number | null
  }

  export type BadgeUncheckedCreateWithoutWalletInput = {
    id?: string
    active?: boolean | null
    createdAt?: Date | string | null
    type?: BadgeType | null
    count?: number | null
    level?: number | null
  }

  export type BadgeCreateOrConnectWithoutWalletInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutWalletInput, BadgeUncheckedCreateWithoutWalletInput>
  }

  export type BadgeCreateManyWalletInputEnvelope = {
    data: Enumerable<BadgeCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type BillingCreateWithoutWalletInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    phoneNumber?: string | null
    order?: OrderCreateNestedManyWithoutBillingInput
  }

  export type BillingUncheckedCreateWithoutWalletInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    phoneNumber?: string | null
    order?: OrderUncheckedCreateNestedManyWithoutBillingInput
  }

  export type BillingCreateOrConnectWithoutWalletInput = {
    where: BillingWhereUniqueInput
    create: XOR<BillingCreateWithoutWalletInput, BillingUncheckedCreateWithoutWalletInput>
  }

  export type BillingCreateManyWalletInputEnvelope = {
    data: Enumerable<BillingCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type CreditCreateWithoutCreditorInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    affiliate?: UserCreateNestedOneWithoutCreditsAffilateInput
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutCreditInput
    debtor?: WalletCreateNestedOneWithoutDebtorCreditInput
    order?: OrderCreateNestedOneWithoutCreditInput
    user?: UserCreateNestedOneWithoutCreditsInput
    installments?: InstallmentCreateNestedManyWithoutCreditInput
  }

  export type CreditUncheckedCreateWithoutCreditorInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditCreateOrConnectWithoutCreditorInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutCreditorInput, CreditUncheckedCreateWithoutCreditorInput>
  }

  export type CreditCreateManyCreditorInputEnvelope = {
    data: Enumerable<CreditCreateManyCreditorInput>
    skipDuplicates?: boolean
  }

  export type CreditCreateWithoutDebtorInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    affiliate?: UserCreateNestedOneWithoutCreditsAffilateInput
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutCreditInput
    creditor?: WalletCreateNestedOneWithoutCreditorCreditInput
    order?: OrderCreateNestedOneWithoutCreditInput
    user?: UserCreateNestedOneWithoutCreditsInput
    installments?: InstallmentCreateNestedManyWithoutCreditInput
  }

  export type CreditUncheckedCreateWithoutDebtorInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditCreateOrConnectWithoutDebtorInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutDebtorInput, CreditUncheckedCreateWithoutDebtorInput>
  }

  export type CreditCreateManyDebtorInputEnvelope = {
    data: Enumerable<CreditCreateManyDebtorInput>
    skipDuplicates?: boolean
  }

  export type CreditConfigurationCreateWithoutWalletInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    credit?: CreditCreateNestedManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsCreateNestedManyWithoutConfigurationInput
    Installment?: InstallmentCreateNestedManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedCreateWithoutWalletInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    credit?: CreditUncheckedCreateNestedManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUncheckedCreateNestedManyWithoutConfigurationInput
    Installment?: InstallmentUncheckedCreateNestedManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationCreateOrConnectWithoutWalletInput = {
    where: CreditConfigurationWhereUniqueInput
    create: XOR<CreditConfigurationCreateWithoutWalletInput, CreditConfigurationUncheckedCreateWithoutWalletInput>
  }

  export type CreditConfigurationCreateManyWalletInputEnvelope = {
    data: Enumerable<CreditConfigurationCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutCustomerInput = {
    vendor: WalletCreateNestedOneWithoutVendorInput
  }

  export type CustomerUncheckedCreateWithoutCustomerInput = {
    vendorId: string
  }

  export type CustomerCreateOrConnectWithoutCustomerInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerInput, CustomerUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutVendorInput = {
    customer: WalletCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutVendorInput = {
    customerId: string
  }

  export type CustomerCreateOrConnectWithoutVendorInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutVendorInput, CustomerUncheckedCreateWithoutVendorInput>
  }

  export type CustomerCreateManyVendorInputEnvelope = {
    data: Enumerable<CustomerCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type InstallmentCreateWithoutCreditorInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutInstallmentInput
    credit?: CreditCreateNestedOneWithoutInstallmentsInput
    debtor?: WalletCreateNestedOneWithoutDebtorInstallmentsInput
    order?: OrderCreateNestedOneWithoutInstallmentsInput
    user?: UserCreateNestedOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateWithoutCreditorInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentCreateOrConnectWithoutCreditorInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutCreditorInput, InstallmentUncheckedCreateWithoutCreditorInput>
  }

  export type InstallmentCreateManyCreditorInputEnvelope = {
    data: Enumerable<InstallmentCreateManyCreditorInput>
    skipDuplicates?: boolean
  }

  export type InstallmentCreateWithoutDebtorInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutInstallmentInput
    credit?: CreditCreateNestedOneWithoutInstallmentsInput
    creditor?: WalletCreateNestedOneWithoutCreditorInstallmentsInput
    order?: OrderCreateNestedOneWithoutInstallmentsInput
    user?: UserCreateNestedOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateWithoutDebtorInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentCreateOrConnectWithoutDebtorInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutDebtorInput, InstallmentUncheckedCreateWithoutDebtorInput>
  }

  export type InstallmentCreateManyDebtorInputEnvelope = {
    data: Enumerable<InstallmentCreateManyDebtorInput>
    skipDuplicates?: boolean
  }

  export type MetaDataCreateWithoutWalletInput = {
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    taxName?: string | null
    seller?: boolean | null
    sellerPhase?: phaseEnum | null
    buyerPhase?: phaseEnum | null
    partnerRole?: partnerRoleEnum | null
    documentCOI?: string | null
    documentCR12?: string | null
    documentSCF?: string | null
    documentSCA?: string | null
    documentStore?: string | null
    documentKRAcert?: string | null
    legalStatus?: legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: boolean | null
    maxBuyerOrderAmount?: number | null
  }

  export type MetaDataUncheckedCreateWithoutWalletInput = {
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: string | null
    taxName?: string | null
    seller?: boolean | null
    sellerPhase?: phaseEnum | null
    buyerPhase?: phaseEnum | null
    partnerRole?: partnerRoleEnum | null
    documentCOI?: string | null
    documentCR12?: string | null
    documentSCF?: string | null
    documentSCA?: string | null
    documentStore?: string | null
    documentKRAcert?: string | null
    legalStatus?: legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: boolean | null
    maxBuyerOrderAmount?: number | null
  }

  export type MetaDataCreateOrConnectWithoutWalletInput = {
    where: MetaDataWhereUniqueInput
    create: XOR<MetaDataCreateWithoutWalletInput, MetaDataUncheckedCreateWithoutWalletInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    billing?: BillingCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: Enumerable<OrderCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutVendorWalletInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    billing?: BillingCreateNestedOneWithoutOrderInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutVendorWalletInput = {
    id?: string
    userId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutVendorWalletInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutVendorWalletInput, OrderUncheckedCreateWithoutVendorWalletInput>
  }

  export type OrderCreateManyVendorWalletInputEnvelope = {
    data: Enumerable<OrderCreateManyVendorWalletInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutVendorWalletInput = {
    id?: string
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
    affiliate?: UserCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVendorWalletInput = {
    id?: string
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
    affiliateId?: string | null
  }

  export type ProductCreateOrConnectWithoutVendorWalletInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVendorWalletInput, ProductUncheckedCreateWithoutVendorWalletInput>
  }

  export type ProductCreateManyVendorWalletInputEnvelope = {
    data: Enumerable<ProductCreateManyVendorWalletInput>
    skipDuplicates?: boolean
  }

  export type SettingsCreateWithoutWalletInput = {
    woocommerceUrl?: string | null
    woocommerceConsumerKey?: string | null
    woocommerceActive?: boolean | null
    woocommerceConsumerSecret?: string | null
  }

  export type SettingsUncheckedCreateWithoutWalletInput = {
    woocommerceUrl?: string | null
    woocommerceConsumerKey?: string | null
    woocommerceActive?: boolean | null
    woocommerceConsumerSecret?: string | null
  }

  export type SettingsCreateOrConnectWithoutWalletInput = {
    where: SettingsWhereUniqueInput
    create: XOR<SettingsCreateWithoutWalletInput, SettingsUncheckedCreateWithoutWalletInput>
  }

  export type SettlementCreateManyWalletInputEnvelope = {
    data: Enumerable<SettlementCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type ShippingCreateWithoutWalletInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    longitude?: string | null
    shippingType?: ShippingTypeEnum | null
    shippingFee?: number | null
    latitude?: string | null
    phoneNumber?: string | null
    isDefault?: boolean | null
    seviVerified?: boolean | null
    createdAt?: Date | string | null
    Order?: OrderCreateNestedManyWithoutShippingInput
  }

  export type ShippingUncheckedCreateWithoutWalletInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    longitude?: string | null
    shippingType?: ShippingTypeEnum | null
    shippingFee?: number | null
    latitude?: string | null
    phoneNumber?: string | null
    isDefault?: boolean | null
    seviVerified?: boolean | null
    createdAt?: Date | string | null
    Order?: OrderUncheckedCreateNestedManyWithoutShippingInput
  }

  export type ShippingCreateOrConnectWithoutWalletInput = {
    where: ShippingWhereUniqueInput
    create: XOR<ShippingCreateWithoutWalletInput, ShippingUncheckedCreateWithoutWalletInput>
  }

  export type ShippingCreateManyWalletInputEnvelope = {
    data: Enumerable<ShippingCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutSupplierInput = {
    vendor: WalletCreateNestedOneWithoutVendorSupplierInput
  }

  export type SupplierUncheckedCreateWithoutSupplierInput = {
    vendorId: string
  }

  export type SupplierCreateOrConnectWithoutSupplierInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutSupplierInput, SupplierUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierCreateManySupplierInputEnvelope = {
    data: Enumerable<SupplierCreateManySupplierInput>
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutVendorInput = {
    supplier: WalletCreateNestedOneWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutVendorInput = {
    supplierId: string
  }

  export type SupplierCreateOrConnectWithoutVendorInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutVendorInput, SupplierUncheckedCreateWithoutVendorInput>
  }

  export type SupplierCreateManyVendorInputEnvelope = {
    data: Enumerable<SupplierCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutWalletInput = {
    id?: string
    amount: number
    fee: number
    totalAmount: number
    description?: string | null
    paymentType: PaymentTypesEnum
    paymentTypeId?: string | null
    currency?: CurrencyEnum
    transactionType?: TransactionTypeEnum | null
    method?: TransactionMethodEnum | null
    createdAt?: Date | string
    name?: string | null
    balanceAfter?: number | null
    balanceBefore?: number | null
  }

  export type TransactionUncheckedCreateWithoutWalletInput = {
    id?: string
    amount: number
    fee: number
    totalAmount: number
    description?: string | null
    paymentType: PaymentTypesEnum
    paymentTypeId?: string | null
    currency?: CurrencyEnum
    transactionType?: TransactionTypeEnum | null
    method?: TransactionMethodEnum | null
    createdAt?: Date | string
    name?: string | null
    balanceAfter?: number | null
    balanceBefore?: number | null
  }

  export type TransactionCreateOrConnectWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput>
  }

  export type TransactionCreateManyWalletInputEnvelope = {
    data: Enumerable<TransactionCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type UsersWalletsCreateWithoutWalletInput = {
    role?: WalletRole
    user: UserCreateNestedOneWithoutUsersWalletsInput
  }

  export type UsersWalletsUncheckedCreateWithoutWalletInput = {
    userId: string
    role?: WalletRole
  }

  export type UsersWalletsCreateOrConnectWithoutWalletInput = {
    where: UsersWalletsWhereUniqueInput
    create: XOR<UsersWalletsCreateWithoutWalletInput, UsersWalletsUncheckedCreateWithoutWalletInput>
  }

  export type UsersWalletsCreateManyWalletInputEnvelope = {
    data: Enumerable<UsersWalletsCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type VisitCreateWithoutWalletInput = {
    id?: string
    createdAt?: Date | string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
    visited?: UserCreateNestedOneWithoutVisitInput
  }

  export type VisitUncheckedCreateWithoutWalletInput = {
    id?: string
    createdAt?: Date | string | null
    visitedBy?: string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
  }

  export type VisitCreateOrConnectWithoutWalletInput = {
    where: VisitWhereUniqueInput
    create: XOR<VisitCreateWithoutWalletInput, VisitUncheckedCreateWithoutWalletInput>
  }

  export type VisitCreateManyWalletInputEnvelope = {
    data: Enumerable<VisitCreateManyWalletInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWalletsInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletsInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
  }

  export type TrustCreateWithoutWalletInput = {
    trustRating?: number | null
    score?: number | null
    createdAt?: Date | string
  }

  export type TrustUncheckedCreateWithoutWalletInput = {
    trustRating?: number | null
    score?: number | null
    createdAt?: Date | string
  }

  export type TrustCreateOrConnectWithoutWalletInput = {
    where: TrustWhereUniqueInput
    create: XOR<TrustCreateWithoutWalletInput, TrustUncheckedCreateWithoutWalletInput>
  }

  export type SettlementUpsertWithoutWalletInput = {
    update: XOR<SettlementUpdateWithoutWalletInput, SettlementUncheckedUpdateWithoutWalletInput>
    create: XOR<SettlementCreateWithoutWalletInput, SettlementUncheckedCreateWithoutWalletInput>
  }

  export type SettlementUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
    wallet?: WalletUpdateOneRequiredWithoutSettlementInput
    settlementCreator?: UserUpdateOneRequiredWithoutSettlementInput
    settlementVerifier?: UserUpdateOneWithoutSettlementInput
  }

  export type SettlementUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    account?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedByUser?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AnswerUpsertWithWhereUniqueWithoutWalletInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutWalletInput, AnswerUncheckedUpdateWithoutWalletInput>
    create: XOR<AnswerCreateWithoutWalletInput, AnswerUncheckedCreateWithoutWalletInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutWalletInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutWalletInput, AnswerUncheckedUpdateWithoutWalletInput>
  }

  export type AnswerUpdateManyWithWhereWithoutWalletInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAnswersInput>
  }

  export type BadgeUpsertWithWhereUniqueWithoutWalletInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutWalletInput, BadgeUncheckedUpdateWithoutWalletInput>
    create: XOR<BadgeCreateWithoutWalletInput, BadgeUncheckedCreateWithoutWalletInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutWalletInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutWalletInput, BadgeUncheckedUpdateWithoutWalletInput>
  }

  export type BadgeUpdateManyWithWhereWithoutWalletInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutBadgesInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: Enumerable<BadgeScalarWhereInput>
    OR?: Enumerable<BadgeScalarWhereInput>
    NOT?: Enumerable<BadgeScalarWhereInput>
    id?: StringFilter | string
    account?: StringFilter | string
    active?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    type?: EnumBadgeTypeNullableFilter | BadgeType | null
    count?: IntNullableFilter | number | null
    level?: IntNullableFilter | number | null
  }

  export type BillingUpsertWithWhereUniqueWithoutWalletInput = {
    where: BillingWhereUniqueInput
    update: XOR<BillingUpdateWithoutWalletInput, BillingUncheckedUpdateWithoutWalletInput>
    create: XOR<BillingCreateWithoutWalletInput, BillingUncheckedCreateWithoutWalletInput>
  }

  export type BillingUpdateWithWhereUniqueWithoutWalletInput = {
    where: BillingWhereUniqueInput
    data: XOR<BillingUpdateWithoutWalletInput, BillingUncheckedUpdateWithoutWalletInput>
  }

  export type BillingUpdateManyWithWhereWithoutWalletInput = {
    where: BillingScalarWhereInput
    data: XOR<BillingUpdateManyMutationInput, BillingUncheckedUpdateManyWithoutBillingInput>
  }

  export type BillingScalarWhereInput = {
    AND?: Enumerable<BillingScalarWhereInput>
    OR?: Enumerable<BillingScalarWhereInput>
    NOT?: Enumerable<BillingScalarWhereInput>
    id?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    company?: StringNullableFilter | string | null
    address1?: StringNullableFilter | string | null
    address2?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    postcode?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    walletId?: StringNullableFilter | string | null
  }

  export type CreditUpsertWithWhereUniqueWithoutCreditorInput = {
    where: CreditWhereUniqueInput
    update: XOR<CreditUpdateWithoutCreditorInput, CreditUncheckedUpdateWithoutCreditorInput>
    create: XOR<CreditCreateWithoutCreditorInput, CreditUncheckedCreateWithoutCreditorInput>
  }

  export type CreditUpdateWithWhereUniqueWithoutCreditorInput = {
    where: CreditWhereUniqueInput
    data: XOR<CreditUpdateWithoutCreditorInput, CreditUncheckedUpdateWithoutCreditorInput>
  }

  export type CreditUpdateManyWithWhereWithoutCreditorInput = {
    where: CreditScalarWhereInput
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyWithoutCreditorCreditInput>
  }

  export type CreditUpsertWithWhereUniqueWithoutDebtorInput = {
    where: CreditWhereUniqueInput
    update: XOR<CreditUpdateWithoutDebtorInput, CreditUncheckedUpdateWithoutDebtorInput>
    create: XOR<CreditCreateWithoutDebtorInput, CreditUncheckedCreateWithoutDebtorInput>
  }

  export type CreditUpdateWithWhereUniqueWithoutDebtorInput = {
    where: CreditWhereUniqueInput
    data: XOR<CreditUpdateWithoutDebtorInput, CreditUncheckedUpdateWithoutDebtorInput>
  }

  export type CreditUpdateManyWithWhereWithoutDebtorInput = {
    where: CreditScalarWhereInput
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyWithoutDebtorCreditInput>
  }

  export type CreditConfigurationUpsertWithWhereUniqueWithoutWalletInput = {
    where: CreditConfigurationWhereUniqueInput
    update: XOR<CreditConfigurationUpdateWithoutWalletInput, CreditConfigurationUncheckedUpdateWithoutWalletInput>
    create: XOR<CreditConfigurationCreateWithoutWalletInput, CreditConfigurationUncheckedCreateWithoutWalletInput>
  }

  export type CreditConfigurationUpdateWithWhereUniqueWithoutWalletInput = {
    where: CreditConfigurationWhereUniqueInput
    data: XOR<CreditConfigurationUpdateWithoutWalletInput, CreditConfigurationUncheckedUpdateWithoutWalletInput>
  }

  export type CreditConfigurationUpdateManyWithWhereWithoutWalletInput = {
    where: CreditConfigurationScalarWhereInput
    data: XOR<CreditConfigurationUpdateManyMutationInput, CreditConfigurationUncheckedUpdateManyWithoutCreditConfigurationsInput>
  }

  export type CreditConfigurationScalarWhereInput = {
    AND?: Enumerable<CreditConfigurationScalarWhereInput>
    OR?: Enumerable<CreditConfigurationScalarWhereInput>
    NOT?: Enumerable<CreditConfigurationScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    shouldPayDeposit?: BoolNullableFilter | boolean | null
    depositPercentage?: FloatFilter | number
    duration?: IntFilter | number
    slices?: EnumSlicesEnumFilter | SlicesEnum
    seviFeesPercentage?: FloatFilter | number
    daysToStartAfterDelivery?: IntFilter | number
    lateInstallmentFeesPercentage?: FloatFilter | number
    affiliatePercentage?: FloatFilter | number
    creditLateFeesPercentage?: FloatFilter | number
    creditLateDays?: FloatFilter | number
    createdAt?: DateTimeNullableFilter | Date | string | null
    status?: EnumCreditConfigurationStatusFilter | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFilter | number
    fundFeesPercentage?: FloatNullableFilter | number | null
    fundId?: StringFilter | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutCustomerInput, CustomerUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerCreateWithoutCustomerInput, CustomerUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutCustomerInput, CustomerUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: Enumerable<CustomerScalarWhereInput>
    OR?: Enumerable<CustomerScalarWhereInput>
    NOT?: Enumerable<CustomerScalarWhereInput>
    customerId?: StringFilter | string
    vendorId?: StringFilter | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutVendorInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutVendorInput, CustomerUncheckedUpdateWithoutVendorInput>
    create: XOR<CustomerCreateWithoutVendorInput, CustomerUncheckedCreateWithoutVendorInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutVendorInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutVendorInput, CustomerUncheckedUpdateWithoutVendorInput>
  }

  export type CustomerUpdateManyWithWhereWithoutVendorInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutVendorInput>
  }

  export type InstallmentUpsertWithWhereUniqueWithoutCreditorInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutCreditorInput, InstallmentUncheckedUpdateWithoutCreditorInput>
    create: XOR<InstallmentCreateWithoutCreditorInput, InstallmentUncheckedCreateWithoutCreditorInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutCreditorInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutCreditorInput, InstallmentUncheckedUpdateWithoutCreditorInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutCreditorInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutCreditorInstallmentsInput>
  }

  export type InstallmentUpsertWithWhereUniqueWithoutDebtorInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutDebtorInput, InstallmentUncheckedUpdateWithoutDebtorInput>
    create: XOR<InstallmentCreateWithoutDebtorInput, InstallmentUncheckedCreateWithoutDebtorInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutDebtorInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutDebtorInput, InstallmentUncheckedUpdateWithoutDebtorInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutDebtorInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutDebtorInstallmentsInput>
  }

  export type MetaDataUpsertWithoutWalletInput = {
    update: XOR<MetaDataUpdateWithoutWalletInput, MetaDataUncheckedUpdateWithoutWalletInput>
    create: XOR<MetaDataCreateWithoutWalletInput, MetaDataUncheckedCreateWithoutWalletInput>
  }

  export type MetaDataUpdateWithoutWalletInput = {
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sellerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    buyerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    partnerRole?: NullableEnumpartnerRoleEnumFieldUpdateOperationsInput | partnerRoleEnum | null
    documentCOI?: NullableStringFieldUpdateOperationsInput | string | null
    documentCR12?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCF?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCA?: NullableStringFieldUpdateOperationsInput | string | null
    documentStore?: NullableStringFieldUpdateOperationsInput | string | null
    documentKRAcert?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableEnumlegalStatusEnumFieldUpdateOperationsInput | legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    maxBuyerOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MetaDataUncheckedUpdateWithoutWalletInput = {
    CRB?: NullableJsonNullValueInput | InputJsonValue
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sellerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    buyerPhase?: NullableEnumphaseEnumFieldUpdateOperationsInput | phaseEnum | null
    partnerRole?: NullableEnumpartnerRoleEnumFieldUpdateOperationsInput | partnerRoleEnum | null
    documentCOI?: NullableStringFieldUpdateOperationsInput | string | null
    documentCR12?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCF?: NullableStringFieldUpdateOperationsInput | string | null
    documentSCA?: NullableStringFieldUpdateOperationsInput | string | null
    documentStore?: NullableStringFieldUpdateOperationsInput | string | null
    documentKRAcert?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableEnumlegalStatusEnumFieldUpdateOperationsInput | legalStatusEnum | null
    metaBaseURL?: NullableJsonNullValueInput | InputJsonValue
    buyer?: NullableBoolFieldUpdateOperationsInput | boolean | null
    maxBuyerOrderAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutVendorWalletInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutVendorWalletInput, OrderUncheckedUpdateWithoutVendorWalletInput>
    create: XOR<OrderCreateWithoutVendorWalletInput, OrderUncheckedCreateWithoutVendorWalletInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutVendorWalletInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutVendorWalletInput, OrderUncheckedUpdateWithoutVendorWalletInput>
  }

  export type OrderUpdateManyWithWhereWithoutVendorWalletInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutVendorWalletInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutVendorWalletInput, ProductUncheckedUpdateWithoutVendorWalletInput>
    create: XOR<ProductCreateWithoutVendorWalletInput, ProductUncheckedCreateWithoutVendorWalletInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutVendorWalletInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutVendorWalletInput, ProductUncheckedUpdateWithoutVendorWalletInput>
  }

  export type ProductUpdateManyWithWhereWithoutVendorWalletInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type SettingsUpsertWithoutWalletInput = {
    update: XOR<SettingsUpdateWithoutWalletInput, SettingsUncheckedUpdateWithoutWalletInput>
    create: XOR<SettingsCreateWithoutWalletInput, SettingsUncheckedCreateWithoutWalletInput>
  }

  export type SettingsUpdateWithoutWalletInput = {
    woocommerceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceConsumerKey?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    woocommerceConsumerSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingsUncheckedUpdateWithoutWalletInput = {
    woocommerceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceConsumerKey?: NullableStringFieldUpdateOperationsInput | string | null
    woocommerceActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    woocommerceConsumerSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettlementUpsertWithWhereUniqueWithoutWalletInput = {
    where: SettlementWhereUniqueInput
    update: XOR<SettlementUpdateWithoutWalletInput, SettlementUncheckedUpdateWithoutWalletInput>
    create: XOR<SettlementCreateWithoutWalletInput, SettlementUncheckedCreateWithoutWalletInput>
  }

  export type SettlementUpdateWithWhereUniqueWithoutWalletInput = {
    where: SettlementWhereUniqueInput
    data: XOR<SettlementUpdateWithoutWalletInput, SettlementUncheckedUpdateWithoutWalletInput>
  }

  export type SettlementUpdateManyWithWhereWithoutWalletInput = {
    where: SettlementScalarWhereInput
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyWithoutSettlementInput>
  }

  export type ShippingUpsertWithWhereUniqueWithoutWalletInput = {
    where: ShippingWhereUniqueInput
    update: XOR<ShippingUpdateWithoutWalletInput, ShippingUncheckedUpdateWithoutWalletInput>
    create: XOR<ShippingCreateWithoutWalletInput, ShippingUncheckedCreateWithoutWalletInput>
  }

  export type ShippingUpdateWithWhereUniqueWithoutWalletInput = {
    where: ShippingWhereUniqueInput
    data: XOR<ShippingUpdateWithoutWalletInput, ShippingUncheckedUpdateWithoutWalletInput>
  }

  export type ShippingUpdateManyWithWhereWithoutWalletInput = {
    where: ShippingScalarWhereInput
    data: XOR<ShippingUpdateManyMutationInput, ShippingUncheckedUpdateManyWithoutShippingInput>
  }

  export type ShippingScalarWhereInput = {
    AND?: Enumerable<ShippingScalarWhereInput>
    OR?: Enumerable<ShippingScalarWhereInput>
    NOT?: Enumerable<ShippingScalarWhereInput>
    id?: StringFilter | string
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    company?: StringNullableFilter | string | null
    address1?: StringNullableFilter | string | null
    address2?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    postcode?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    longitude?: StringNullableFilter | string | null
    shippingType?: EnumShippingTypeEnumNullableFilter | ShippingTypeEnum | null
    shippingFee?: FloatNullableFilter | number | null
    latitude?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    walletId?: StringNullableFilter | string | null
    isDefault?: BoolNullableFilter | boolean | null
    seviVerified?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SupplierUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutSupplierInput, SupplierUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierCreateWithoutSupplierInput, SupplierUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutSupplierInput, SupplierUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: Enumerable<SupplierScalarWhereInput>
    OR?: Enumerable<SupplierScalarWhereInput>
    NOT?: Enumerable<SupplierScalarWhereInput>
    supplierId?: StringFilter | string
    vendorId?: StringFilter | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutVendorInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutVendorInput, SupplierUncheckedUpdateWithoutVendorInput>
    create: XOR<SupplierCreateWithoutVendorInput, SupplierUncheckedCreateWithoutVendorInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutVendorInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutVendorInput, SupplierUncheckedUpdateWithoutVendorInput>
  }

  export type SupplierUpdateManyWithWhereWithoutVendorInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutVendorSupplierInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutWalletInput, TransactionUncheckedUpdateWithoutWalletInput>
    create: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutWalletInput, TransactionUncheckedUpdateWithoutWalletInput>
  }

  export type TransactionUpdateManyWithWhereWithoutWalletInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: Enumerable<TransactionScalarWhereInput>
    OR?: Enumerable<TransactionScalarWhereInput>
    NOT?: Enumerable<TransactionScalarWhereInput>
    id?: StringFilter | string
    amount?: FloatFilter | number
    fee?: FloatFilter | number
    totalAmount?: FloatFilter | number
    description?: StringNullableFilter | string | null
    paymentType?: EnumPaymentTypesEnumFilter | PaymentTypesEnum
    paymentTypeId?: StringNullableFilter | string | null
    currency?: EnumCurrencyEnumFilter | CurrencyEnum
    transactionType?: EnumTransactionTypeEnumNullableFilter | TransactionTypeEnum | null
    method?: EnumTransactionMethodEnumNullableFilter | TransactionMethodEnum | null
    walletId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
    balanceAfter?: FloatNullableFilter | number | null
    balanceBefore?: FloatNullableFilter | number | null
  }

  export type UsersWalletsUpsertWithWhereUniqueWithoutWalletInput = {
    where: UsersWalletsWhereUniqueInput
    update: XOR<UsersWalletsUpdateWithoutWalletInput, UsersWalletsUncheckedUpdateWithoutWalletInput>
    create: XOR<UsersWalletsCreateWithoutWalletInput, UsersWalletsUncheckedCreateWithoutWalletInput>
  }

  export type UsersWalletsUpdateWithWhereUniqueWithoutWalletInput = {
    where: UsersWalletsWhereUniqueInput
    data: XOR<UsersWalletsUpdateWithoutWalletInput, UsersWalletsUncheckedUpdateWithoutWalletInput>
  }

  export type UsersWalletsUpdateManyWithWhereWithoutWalletInput = {
    where: UsersWalletsScalarWhereInput
    data: XOR<UsersWalletsUpdateManyMutationInput, UsersWalletsUncheckedUpdateManyWithoutUsersWalletsInput>
  }

  export type VisitUpsertWithWhereUniqueWithoutWalletInput = {
    where: VisitWhereUniqueInput
    update: XOR<VisitUpdateWithoutWalletInput, VisitUncheckedUpdateWithoutWalletInput>
    create: XOR<VisitCreateWithoutWalletInput, VisitUncheckedCreateWithoutWalletInput>
  }

  export type VisitUpdateWithWhereUniqueWithoutWalletInput = {
    where: VisitWhereUniqueInput
    data: XOR<VisitUpdateWithoutWalletInput, VisitUncheckedUpdateWithoutWalletInput>
  }

  export type VisitUpdateManyWithWhereWithoutWalletInput = {
    where: VisitScalarWhereInput
    data: XOR<VisitUpdateManyMutationInput, VisitUncheckedUpdateManyWithoutVisitInput>
  }

  export type UserUpsertWithWhereUniqueWithoutWalletsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutWalletsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
  }

  export type UserUpdateManyWithWhereWithoutWalletsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    userPhoto?: StringNullableFilter | string | null
    phoneNumber?: StringNullableFilter | string | null
    countryCode?: EnumCountryCodeNullableFilter | CountryCode | null
    documentId?: StringNullableFilter | string | null
    url?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    pin?: StringNullableFilter | string | null
    deviceToken?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    verified?: BoolFilter | boolean
    expoPushToken?: StringNullableFilter | string | null
    inviterId?: StringNullableFilter | string | null
    faceIdImage?: StringNullableFilter | string | null
    documentCountry?: EnumCountryCodeNullableFilter | CountryCode | null
    documentData?: JsonNullableFilter
    documentFirstName?: StringNullableFilter | string | null
    documentLastName?: StringNullableFilter | string | null
    documentImage?: StringNullableFilter | string | null
    documentGender?: EnumGenderEnumNullableFilter | GenderEnum | null
    documentDateOfBirth?: DateTimeNullableFilter | Date | string | null
    documentDateOfIssue?: DateTimeNullableFilter | Date | string | null
    documentSerialNumber?: StringNullableFilter | string | null
    documentCreatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TrustUpsertWithoutWalletInput = {
    update: XOR<TrustUpdateWithoutWalletInput, TrustUncheckedUpdateWithoutWalletInput>
    create: XOR<TrustCreateWithoutWalletInput, TrustUncheckedCreateWithoutWalletInput>
  }

  export type TrustUpdateWithoutWalletInput = {
    trustRating?: NullableFloatFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustUncheckedUpdateWithoutWalletInput = {
    trustRating?: NullableFloatFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateWithoutTrustInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
  }

  export type WalletUncheckedCreateWithoutTrustInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
  }

  export type WalletCreateOrConnectWithoutTrustInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTrustInput, WalletUncheckedCreateWithoutTrustInput>
  }

  export type WalletUpsertWithoutTrustInput = {
    update: XOR<WalletUpdateWithoutTrustInput, WalletUncheckedUpdateWithoutTrustInput>
    create: XOR<WalletCreateWithoutTrustInput, WalletUncheckedCreateWithoutTrustInput>
  }

  export type WalletUpdateWithoutTrustInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
  }

  export type WalletUncheckedUpdateWithoutTrustInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
  }

  export type WalletCreateWithoutMetaDataInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutMetaDataInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutMetaDataInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutMetaDataInput, WalletUncheckedCreateWithoutMetaDataInput>
  }

  export type WalletUpsertWithoutMetaDataInput = {
    update: XOR<WalletUpdateWithoutMetaDataInput, WalletUncheckedUpdateWithoutMetaDataInput>
    create: XOR<WalletCreateWithoutMetaDataInput, WalletUncheckedCreateWithoutMetaDataInput>
  }

  export type WalletUpdateWithoutMetaDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutMetaDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletCreateWithoutTransactionInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutTransactionInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
  }

  export type WalletUpsertWithoutTransactionInput = {
    update: XOR<WalletUpdateWithoutTransactionInput, WalletUncheckedUpdateWithoutTransactionInput>
    create: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
  }

  export type WalletUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type UserCreateWithoutProductInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
  }

  export type WalletCreateWithoutProductInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutProductInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutProductInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutProductInput, WalletUncheckedCreateWithoutProductInput>
  }

  export type UserUpsertWithoutProductInput = {
    update: XOR<UserUpdateWithoutProductInput, UserUncheckedUpdateWithoutProductInput>
    create: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
  }

  export type UserUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type WalletUpsertWithoutProductInput = {
    update: XOR<WalletUpdateWithoutProductInput, WalletUncheckedUpdateWithoutProductInput>
    create: XOR<WalletCreateWithoutProductInput, WalletUncheckedCreateWithoutProductInput>
  }

  export type WalletUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type UserCreateWithoutOrdersAffiliateInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersAffiliateInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersAffiliateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersAffiliateInput, UserUncheckedCreateWithoutOrdersAffiliateInput>
  }

  export type BillingCreateWithoutOrderInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    phoneNumber?: string | null
    wallet?: WalletCreateNestedOneWithoutBillingInput
  }

  export type BillingUncheckedCreateWithoutOrderInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    phoneNumber?: string | null
    walletId?: string | null
  }

  export type BillingCreateOrConnectWithoutOrderInput = {
    where: BillingWhereUniqueInput
    create: XOR<BillingCreateWithoutOrderInput, BillingUncheckedCreateWithoutOrderInput>
  }

  export type WalletCreateWithoutOrderInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutOrderInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutOrderInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutOrderInput, WalletUncheckedCreateWithoutOrderInput>
  }

  export type ShippingCreateWithoutOrderInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    longitude?: string | null
    shippingType?: ShippingTypeEnum | null
    shippingFee?: number | null
    latitude?: string | null
    phoneNumber?: string | null
    isDefault?: boolean | null
    seviVerified?: boolean | null
    createdAt?: Date | string | null
    wallet?: WalletCreateNestedOneWithoutShippingInput
  }

  export type ShippingUncheckedCreateWithoutOrderInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    longitude?: string | null
    shippingType?: ShippingTypeEnum | null
    shippingFee?: number | null
    latitude?: string | null
    phoneNumber?: string | null
    walletId?: string | null
    isDefault?: boolean | null
    seviVerified?: boolean | null
    createdAt?: Date | string | null
  }

  export type ShippingCreateOrConnectWithoutOrderInput = {
    where: ShippingWhereUniqueInput
    create: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type WalletCreateWithoutOrdersInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutOrdersInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutOrdersInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutOrdersInput, WalletUncheckedCreateWithoutOrdersInput>
  }

  export type CreditCreateWithoutOrderInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    affiliate?: UserCreateNestedOneWithoutCreditsAffilateInput
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutCreditInput
    creditor?: WalletCreateNestedOneWithoutCreditorCreditInput
    debtor?: WalletCreateNestedOneWithoutDebtorCreditInput
    user?: UserCreateNestedOneWithoutCreditsInput
    installments?: InstallmentCreateNestedManyWithoutCreditInput
  }

  export type CreditUncheckedCreateWithoutOrderInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditCreateOrConnectWithoutOrderInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutOrderInput, CreditUncheckedCreateWithoutOrderInput>
  }

  export type InstallmentCreateWithoutOrderInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutInstallmentInput
    credit?: CreditCreateNestedOneWithoutInstallmentsInput
    creditor?: WalletCreateNestedOneWithoutCreditorInstallmentsInput
    debtor?: WalletCreateNestedOneWithoutDebtorInstallmentsInput
    user?: UserCreateNestedOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateWithoutOrderInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentCreateOrConnectWithoutOrderInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutOrderInput, InstallmentUncheckedCreateWithoutOrderInput>
  }

  export type InstallmentCreateManyOrderInputEnvelope = {
    data: Enumerable<InstallmentCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type CreditRequestCreateWithoutOrderInput = {
    id?: string
    status?: CreditRequestStatus
    wallet: string
    user?: UserCreateNestedOneWithoutCreditRequestsInput
    creditConfiguration?: CreditConfigurationCreateNestedOneWithoutCreditRequestsInput
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestUncheckedCreateWithoutOrderInput = {
    id?: string
    status?: CreditRequestStatus
    wallet: string
    creditConfigurationId: string
    userId: string
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestCreateOrConnectWithoutOrderInput = {
    where: CreditRequestWhereUniqueInput
    create: XOR<CreditRequestCreateWithoutOrderInput, CreditRequestUncheckedCreateWithoutOrderInput>
  }

  export type UserUpsertWithoutOrdersAffiliateInput = {
    update: XOR<UserUpdateWithoutOrdersAffiliateInput, UserUncheckedUpdateWithoutOrdersAffiliateInput>
    create: XOR<UserCreateWithoutOrdersAffiliateInput, UserUncheckedCreateWithoutOrdersAffiliateInput>
  }

  export type UserUpdateWithoutOrdersAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOrdersAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type BillingUpsertWithoutOrderInput = {
    update: XOR<BillingUpdateWithoutOrderInput, BillingUncheckedUpdateWithoutOrderInput>
    create: XOR<BillingCreateWithoutOrderInput, BillingUncheckedCreateWithoutOrderInput>
  }

  export type BillingUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutBillingInput
  }

  export type BillingUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletUpsertWithoutOrderInput = {
    update: XOR<WalletUpdateWithoutOrderInput, WalletUncheckedUpdateWithoutOrderInput>
    create: XOR<WalletCreateWithoutOrderInput, WalletUncheckedCreateWithoutOrderInput>
  }

  export type WalletUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type ShippingUpsertWithoutOrderInput = {
    update: XOR<ShippingUpdateWithoutOrderInput, ShippingUncheckedUpdateWithoutOrderInput>
    create: XOR<ShippingCreateWithoutOrderInput, ShippingUncheckedCreateWithoutOrderInput>
  }

  export type ShippingUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallet?: WalletUpdateOneWithoutShippingInput
  }

  export type ShippingUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type WalletUpsertWithoutOrdersInput = {
    update: XOR<WalletUpdateWithoutOrdersInput, WalletUncheckedUpdateWithoutOrdersInput>
    create: XOR<WalletCreateWithoutOrdersInput, WalletUncheckedCreateWithoutOrdersInput>
  }

  export type WalletUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type CreditUpsertWithoutOrderInput = {
    update: XOR<CreditUpdateWithoutOrderInput, CreditUncheckedUpdateWithoutOrderInput>
    create: XOR<CreditCreateWithoutOrderInput, CreditUncheckedCreateWithoutOrderInput>
  }

  export type CreditUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    affiliate?: UserUpdateOneWithoutCreditsAffilateInput
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutCreditInput
    creditor?: WalletUpdateOneWithoutCreditorCreditInput
    debtor?: WalletUpdateOneWithoutDebtorCreditInput
    user?: UserUpdateOneWithoutCreditsInput
    installments?: InstallmentUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    installments?: InstallmentUncheckedUpdateManyWithoutCreditInput
  }

  export type InstallmentUpsertWithWhereUniqueWithoutOrderInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutOrderInput, InstallmentUncheckedUpdateWithoutOrderInput>
    create: XOR<InstallmentCreateWithoutOrderInput, InstallmentUncheckedCreateWithoutOrderInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutOrderInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutOrderInput, InstallmentUncheckedUpdateWithoutOrderInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutOrderInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutInstallmentsInput>
  }

  export type CreditRequestUpsertWithoutOrderInput = {
    update: XOR<CreditRequestUpdateWithoutOrderInput, CreditRequestUncheckedUpdateWithoutOrderInput>
    create: XOR<CreditRequestCreateWithoutOrderInput, CreditRequestUncheckedCreateWithoutOrderInput>
  }

  export type CreditRequestUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    wallet?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutCreditRequestsInput
    creditConfiguration?: CreditConfigurationUpdateOneWithoutCreditRequestsInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRequestUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    wallet?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateWithoutBillingInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutBillingInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutBillingInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutBillingInput, WalletUncheckedCreateWithoutBillingInput>
  }

  export type OrderCreateWithoutBillingInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutBillingInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutBillingInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutBillingInput, OrderUncheckedCreateWithoutBillingInput>
  }

  export type OrderCreateManyBillingInputEnvelope = {
    data: Enumerable<OrderCreateManyBillingInput>
    skipDuplicates?: boolean
  }

  export type WalletUpsertWithoutBillingInput = {
    update: XOR<WalletUpdateWithoutBillingInput, WalletUncheckedUpdateWithoutBillingInput>
    create: XOR<WalletCreateWithoutBillingInput, WalletUncheckedCreateWithoutBillingInput>
  }

  export type WalletUpdateWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type OrderUpsertWithWhereUniqueWithoutBillingInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutBillingInput, OrderUncheckedUpdateWithoutBillingInput>
    create: XOR<OrderCreateWithoutBillingInput, OrderUncheckedCreateWithoutBillingInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutBillingInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutBillingInput, OrderUncheckedUpdateWithoutBillingInput>
  }

  export type OrderUpdateManyWithWhereWithoutBillingInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type WalletCreateWithoutShippingInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutShippingInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutShippingInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutShippingInput, WalletUncheckedCreateWithoutShippingInput>
  }

  export type OrderCreateWithoutShippingInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    billing?: BillingCreateNestedOneWithoutOrderInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutShippingInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutShippingInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutShippingInput, OrderUncheckedCreateWithoutShippingInput>
  }

  export type OrderCreateManyShippingInputEnvelope = {
    data: Enumerable<OrderCreateManyShippingInput>
    skipDuplicates?: boolean
  }

  export type WalletUpsertWithoutShippingInput = {
    update: XOR<WalletUpdateWithoutShippingInput, WalletUncheckedUpdateWithoutShippingInput>
    create: XOR<WalletCreateWithoutShippingInput, WalletUncheckedCreateWithoutShippingInput>
  }

  export type WalletUpdateWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type OrderUpsertWithWhereUniqueWithoutShippingInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutShippingInput, OrderUncheckedUpdateWithoutShippingInput>
    create: XOR<OrderCreateWithoutShippingInput, OrderUncheckedCreateWithoutShippingInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutShippingInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutShippingInput, OrderUncheckedUpdateWithoutShippingInput>
  }

  export type OrderUpdateManyWithWhereWithoutShippingInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type UserCreateWithoutCreditsAffilateInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreditsAffilateInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreditsAffilateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditsAffilateInput, UserUncheckedCreateWithoutCreditsAffilateInput>
  }

  export type CreditConfigurationCreateWithoutCreditInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    wallet: WalletCreateNestedOneWithoutCreditConfigurationsInput
    attachedWallets?: CreditConfigurationsWalletsCreateNestedManyWithoutConfigurationInput
    Installment?: InstallmentCreateNestedManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedCreateWithoutCreditInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    fundId: string
    attachedWallets?: CreditConfigurationsWalletsUncheckedCreateNestedManyWithoutConfigurationInput
    Installment?: InstallmentUncheckedCreateNestedManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationCreateOrConnectWithoutCreditInput = {
    where: CreditConfigurationWhereUniqueInput
    create: XOR<CreditConfigurationCreateWithoutCreditInput, CreditConfigurationUncheckedCreateWithoutCreditInput>
  }

  export type WalletCreateWithoutCreditorCreditInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutCreditorCreditInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutCreditorCreditInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutCreditorCreditInput, WalletUncheckedCreateWithoutCreditorCreditInput>
  }

  export type WalletCreateWithoutDebtorCreditInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutDebtorCreditInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutDebtorCreditInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutDebtorCreditInput, WalletUncheckedCreateWithoutDebtorCreditInput>
  }

  export type OrderCreateWithoutCreditInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    billing?: BillingCreateNestedOneWithoutOrderInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCreditInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCreditInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCreditInput, OrderUncheckedCreateWithoutCreditInput>
  }

  export type UserCreateWithoutCreditsInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreditsInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditsInput, UserUncheckedCreateWithoutCreditsInput>
  }

  export type InstallmentCreateWithoutCreditInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutInstallmentInput
    creditor?: WalletCreateNestedOneWithoutCreditorInstallmentsInput
    debtor?: WalletCreateNestedOneWithoutDebtorInstallmentsInput
    order?: OrderCreateNestedOneWithoutInstallmentsInput
    user?: UserCreateNestedOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateWithoutCreditInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentCreateOrConnectWithoutCreditInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutCreditInput, InstallmentUncheckedCreateWithoutCreditInput>
  }

  export type InstallmentCreateManyCreditInputEnvelope = {
    data: Enumerable<InstallmentCreateManyCreditInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreditsAffilateInput = {
    update: XOR<UserUpdateWithoutCreditsAffilateInput, UserUncheckedUpdateWithoutCreditsAffilateInput>
    create: XOR<UserCreateWithoutCreditsAffilateInput, UserUncheckedCreateWithoutCreditsAffilateInput>
  }

  export type UserUpdateWithoutCreditsAffilateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCreditsAffilateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type CreditConfigurationUpsertWithoutCreditInput = {
    update: XOR<CreditConfigurationUpdateWithoutCreditInput, CreditConfigurationUncheckedUpdateWithoutCreditInput>
    create: XOR<CreditConfigurationCreateWithoutCreditInput, CreditConfigurationUncheckedCreateWithoutCreditInput>
  }

  export type CreditConfigurationUpdateWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet?: WalletUpdateOneRequiredWithoutCreditConfigurationsInput
    attachedWallets?: CreditConfigurationsWalletsUpdateManyWithoutConfigurationInput
    Installment?: InstallmentUpdateManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUpdateOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedUpdateWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    fundId?: StringFieldUpdateOperationsInput | string
    attachedWallets?: CreditConfigurationsWalletsUncheckedUpdateManyWithoutConfigurationInput
    Installment?: InstallmentUncheckedUpdateManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutCreditConfigurationInput
  }

  export type WalletUpsertWithoutCreditorCreditInput = {
    update: XOR<WalletUpdateWithoutCreditorCreditInput, WalletUncheckedUpdateWithoutCreditorCreditInput>
    create: XOR<WalletCreateWithoutCreditorCreditInput, WalletUncheckedCreateWithoutCreditorCreditInput>
  }

  export type WalletUpdateWithoutCreditorCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutCreditorCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletUpsertWithoutDebtorCreditInput = {
    update: XOR<WalletUpdateWithoutDebtorCreditInput, WalletUncheckedUpdateWithoutDebtorCreditInput>
    create: XOR<WalletCreateWithoutDebtorCreditInput, WalletUncheckedCreateWithoutDebtorCreditInput>
  }

  export type WalletUpdateWithoutDebtorCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutDebtorCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type OrderUpsertWithoutCreditInput = {
    update: XOR<OrderUpdateWithoutCreditInput, OrderUncheckedUpdateWithoutCreditInput>
    create: XOR<OrderCreateWithoutCreditInput, OrderUncheckedCreateWithoutCreditInput>
  }

  export type OrderUpdateWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    billing?: BillingUpdateOneWithoutOrderInput
    customer?: WalletUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    installments?: InstallmentUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type UserUpsertWithoutCreditsInput = {
    update: XOR<UserUpdateWithoutCreditsInput, UserUncheckedUpdateWithoutCreditsInput>
    create: XOR<UserCreateWithoutCreditsInput, UserUncheckedCreateWithoutCreditsInput>
  }

  export type UserUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type InstallmentUpsertWithWhereUniqueWithoutCreditInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutCreditInput, InstallmentUncheckedUpdateWithoutCreditInput>
    create: XOR<InstallmentCreateWithoutCreditInput, InstallmentUncheckedCreateWithoutCreditInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutCreditInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutCreditInput, InstallmentUncheckedUpdateWithoutCreditInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutCreditInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutInstallmentsInput>
  }

  export type CreditConfigurationCreateWithoutInstallmentInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    wallet: WalletCreateNestedOneWithoutCreditConfigurationsInput
    credit?: CreditCreateNestedManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsCreateNestedManyWithoutConfigurationInput
    creditRequests?: CreditRequestCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedCreateWithoutInstallmentInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    fundId: string
    credit?: CreditUncheckedCreateNestedManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUncheckedCreateNestedManyWithoutConfigurationInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationCreateOrConnectWithoutInstallmentInput = {
    where: CreditConfigurationWhereUniqueInput
    create: XOR<CreditConfigurationCreateWithoutInstallmentInput, CreditConfigurationUncheckedCreateWithoutInstallmentInput>
  }

  export type CreditCreateWithoutInstallmentsInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    affiliate?: UserCreateNestedOneWithoutCreditsAffilateInput
    creditConfiguration: CreditConfigurationCreateNestedOneWithoutCreditInput
    creditor?: WalletCreateNestedOneWithoutCreditorCreditInput
    debtor?: WalletCreateNestedOneWithoutDebtorCreditInput
    order?: OrderCreateNestedOneWithoutCreditInput
    user?: UserCreateNestedOneWithoutCreditsInput
  }

  export type CreditUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
  }

  export type CreditCreateOrConnectWithoutInstallmentsInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutInstallmentsInput, CreditUncheckedCreateWithoutInstallmentsInput>
  }

  export type WalletCreateWithoutCreditorInstallmentsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutCreditorInstallmentsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutCreditorInstallmentsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutCreditorInstallmentsInput, WalletUncheckedCreateWithoutCreditorInstallmentsInput>
  }

  export type WalletCreateWithoutDebtorInstallmentsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutDebtorInstallmentsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutDebtorInstallmentsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutDebtorInstallmentsInput, WalletUncheckedCreateWithoutDebtorInstallmentsInput>
  }

  export type OrderCreateWithoutInstallmentsInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    billing?: BillingCreateNestedOneWithoutOrderInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    creditRequest?: CreditRequestCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    creditRequest?: CreditRequestUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInstallmentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInstallmentsInput, OrderUncheckedCreateWithoutInstallmentsInput>
  }

  export type UserCreateWithoutInstallmentInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstallmentInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstallmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstallmentInput, UserUncheckedCreateWithoutInstallmentInput>
  }

  export type CreditConfigurationUpsertWithoutInstallmentInput = {
    update: XOR<CreditConfigurationUpdateWithoutInstallmentInput, CreditConfigurationUncheckedUpdateWithoutInstallmentInput>
    create: XOR<CreditConfigurationCreateWithoutInstallmentInput, CreditConfigurationUncheckedCreateWithoutInstallmentInput>
  }

  export type CreditConfigurationUpdateWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet?: WalletUpdateOneRequiredWithoutCreditConfigurationsInput
    credit?: CreditUpdateManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUpdateManyWithoutConfigurationInput
    creditRequests?: CreditRequestUpdateOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedUpdateWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    fundId?: StringFieldUpdateOperationsInput | string
    credit?: CreditUncheckedUpdateManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUncheckedUpdateManyWithoutConfigurationInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutCreditConfigurationInput
  }

  export type CreditUpsertWithoutInstallmentsInput = {
    update: XOR<CreditUpdateWithoutInstallmentsInput, CreditUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<CreditCreateWithoutInstallmentsInput, CreditUncheckedCreateWithoutInstallmentsInput>
  }

  export type CreditUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    affiliate?: UserUpdateOneWithoutCreditsAffilateInput
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutCreditInput
    creditor?: WalletUpdateOneWithoutCreditorCreditInput
    debtor?: WalletUpdateOneWithoutDebtorCreditInput
    order?: OrderUpdateOneWithoutCreditInput
    user?: UserUpdateOneWithoutCreditsInput
  }

  export type CreditUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type WalletUpsertWithoutCreditorInstallmentsInput = {
    update: XOR<WalletUpdateWithoutCreditorInstallmentsInput, WalletUncheckedUpdateWithoutCreditorInstallmentsInput>
    create: XOR<WalletCreateWithoutCreditorInstallmentsInput, WalletUncheckedCreateWithoutCreditorInstallmentsInput>
  }

  export type WalletUpdateWithoutCreditorInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutCreditorInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletUpsertWithoutDebtorInstallmentsInput = {
    update: XOR<WalletUpdateWithoutDebtorInstallmentsInput, WalletUncheckedUpdateWithoutDebtorInstallmentsInput>
    create: XOR<WalletCreateWithoutDebtorInstallmentsInput, WalletUncheckedCreateWithoutDebtorInstallmentsInput>
  }

  export type WalletUpdateWithoutDebtorInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutDebtorInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type OrderUpsertWithoutInstallmentsInput = {
    update: XOR<OrderUpdateWithoutInstallmentsInput, OrderUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<OrderCreateWithoutInstallmentsInput, OrderUncheckedCreateWithoutInstallmentsInput>
  }

  export type OrderUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    billing?: BillingUpdateOneWithoutOrderInput
    customer?: WalletUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type UserUpsertWithoutInstallmentInput = {
    update: XOR<UserUpdateWithoutInstallmentInput, UserUncheckedUpdateWithoutInstallmentInput>
    create: XOR<UserCreateWithoutInstallmentInput, UserUncheckedCreateWithoutInstallmentInput>
  }

  export type UserUpdateWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type UserCreateWithoutActivityInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
  }

  export type UserUpsertWithoutActivityInput = {
    update: XOR<UserUpdateWithoutActivityInput, UserUncheckedUpdateWithoutActivityInput>
    create: XOR<UserCreateWithoutActivityInput, UserUncheckedCreateWithoutActivityInput>
  }

  export type UserUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type UserCreateWithoutVerifyInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerifyInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerifyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifyInput, UserUncheckedCreateWithoutVerifyInput>
  }

  export type UserUpsertWithoutVerifyInput = {
    update: XOR<UserUpdateWithoutVerifyInput, UserUncheckedUpdateWithoutVerifyInput>
    create: XOR<UserCreateWithoutVerifyInput, UserUncheckedCreateWithoutVerifyInput>
  }

  export type UserUpdateWithoutVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type UserCreateWithoutLoginInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoginInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
  }

  export type UserUpsertWithoutLoginInput = {
    update: XOR<UserUpdateWithoutLoginInput, UserUncheckedUpdateWithoutLoginInput>
    create: XOR<UserCreateWithoutLoginInput, UserUncheckedCreateWithoutLoginInput>
  }

  export type UserUpdateWithoutLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type WalletCreateWithoutVisitInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutVisitInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutVisitInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutVisitInput, WalletUncheckedCreateWithoutVisitInput>
  }

  export type UserCreateWithoutVisitInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVisitInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVisitInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVisitInput, UserUncheckedCreateWithoutVisitInput>
  }

  export type WalletUpsertWithoutVisitInput = {
    update: XOR<WalletUpdateWithoutVisitInput, WalletUncheckedUpdateWithoutVisitInput>
    create: XOR<WalletCreateWithoutVisitInput, WalletUncheckedCreateWithoutVisitInput>
  }

  export type WalletUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type UserUpsertWithoutVisitInput = {
    update: XOR<UserUpdateWithoutVisitInput, UserUncheckedUpdateWithoutVisitInput>
    create: XOR<UserCreateWithoutVisitInput, UserUncheckedCreateWithoutVisitInput>
  }

  export type UserUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type WalletCreateWithoutCreditConfigurationsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutCreditConfigurationsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutCreditConfigurationsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutCreditConfigurationsInput, WalletUncheckedCreateWithoutCreditConfigurationsInput>
  }

  export type CreditCreateWithoutCreditConfigurationInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    type?: creditRefType | null
    amount?: number | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    affiliate?: UserCreateNestedOneWithoutCreditsAffilateInput
    creditor?: WalletCreateNestedOneWithoutCreditorCreditInput
    debtor?: WalletCreateNestedOneWithoutDebtorCreditInput
    order?: OrderCreateNestedOneWithoutCreditInput
    user?: UserCreateNestedOneWithoutCreditsInput
    installments?: InstallmentCreateNestedManyWithoutCreditInput
  }

  export type CreditUncheckedCreateWithoutCreditConfigurationInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutCreditInput
  }

  export type CreditCreateOrConnectWithoutCreditConfigurationInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutCreditConfigurationInput, CreditUncheckedCreateWithoutCreditConfigurationInput>
  }

  export type CreditCreateManyCreditConfigurationInputEnvelope = {
    data: Enumerable<CreditCreateManyCreditConfigurationInput>
    skipDuplicates?: boolean
  }

  export type CreditConfigurationsWalletsCreateWithoutConfigurationInput = {
    walletId: string
    upfrontPercentage: number
    fundFeesPercentage: number
    maxOrderAmount: number
    maxOutstandingCredit: number
    shareFeesPercentage?: number
    postDeliveryPercentage?: number
  }

  export type CreditConfigurationsWalletsUncheckedCreateWithoutConfigurationInput = {
    walletId: string
    upfrontPercentage: number
    fundFeesPercentage: number
    maxOrderAmount: number
    maxOutstandingCredit: number
    shareFeesPercentage?: number
    postDeliveryPercentage?: number
  }

  export type CreditConfigurationsWalletsCreateOrConnectWithoutConfigurationInput = {
    where: CreditConfigurationsWalletsWhereUniqueInput
    create: XOR<CreditConfigurationsWalletsCreateWithoutConfigurationInput, CreditConfigurationsWalletsUncheckedCreateWithoutConfigurationInput>
  }

  export type CreditConfigurationsWalletsCreateManyConfigurationInputEnvelope = {
    data: Enumerable<CreditConfigurationsWalletsCreateManyConfigurationInput>
    skipDuplicates?: boolean
  }

  export type InstallmentCreateWithoutCreditConfigurationInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
    credit?: CreditCreateNestedOneWithoutInstallmentsInput
    creditor?: WalletCreateNestedOneWithoutCreditorInstallmentsInput
    debtor?: WalletCreateNestedOneWithoutDebtorInstallmentsInput
    order?: OrderCreateNestedOneWithoutInstallmentsInput
    user?: UserCreateNestedOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateWithoutCreditConfigurationInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentCreateOrConnectWithoutCreditConfigurationInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutCreditConfigurationInput, InstallmentUncheckedCreateWithoutCreditConfigurationInput>
  }

  export type InstallmentCreateManyCreditConfigurationInputEnvelope = {
    data: Enumerable<InstallmentCreateManyCreditConfigurationInput>
    skipDuplicates?: boolean
  }

  export type CreditRequestCreateWithoutCreditConfigurationInput = {
    id?: string
    status?: CreditRequestStatus
    wallet: string
    user?: UserCreateNestedOneWithoutCreditRequestsInput
    order?: OrderCreateNestedOneWithoutCreditRequestInput
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestUncheckedCreateWithoutCreditConfigurationInput = {
    id?: string
    status?: CreditRequestStatus
    orderId: string
    wallet: string
    userId: string
    createdAt?: Date | string
    proceedAt: Date | string
  }

  export type CreditRequestCreateOrConnectWithoutCreditConfigurationInput = {
    where: CreditRequestWhereUniqueInput
    create: XOR<CreditRequestCreateWithoutCreditConfigurationInput, CreditRequestUncheckedCreateWithoutCreditConfigurationInput>
  }

  export type WalletUpsertWithoutCreditConfigurationsInput = {
    update: XOR<WalletUpdateWithoutCreditConfigurationsInput, WalletUncheckedUpdateWithoutCreditConfigurationsInput>
    create: XOR<WalletCreateWithoutCreditConfigurationsInput, WalletUncheckedCreateWithoutCreditConfigurationsInput>
  }

  export type WalletUpdateWithoutCreditConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutCreditConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type CreditUpsertWithWhereUniqueWithoutCreditConfigurationInput = {
    where: CreditWhereUniqueInput
    update: XOR<CreditUpdateWithoutCreditConfigurationInput, CreditUncheckedUpdateWithoutCreditConfigurationInput>
    create: XOR<CreditCreateWithoutCreditConfigurationInput, CreditUncheckedCreateWithoutCreditConfigurationInput>
  }

  export type CreditUpdateWithWhereUniqueWithoutCreditConfigurationInput = {
    where: CreditWhereUniqueInput
    data: XOR<CreditUpdateWithoutCreditConfigurationInput, CreditUncheckedUpdateWithoutCreditConfigurationInput>
  }

  export type CreditUpdateManyWithWhereWithoutCreditConfigurationInput = {
    where: CreditScalarWhereInput
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyWithoutCreditInput>
  }

  export type CreditConfigurationsWalletsUpsertWithWhereUniqueWithoutConfigurationInput = {
    where: CreditConfigurationsWalletsWhereUniqueInput
    update: XOR<CreditConfigurationsWalletsUpdateWithoutConfigurationInput, CreditConfigurationsWalletsUncheckedUpdateWithoutConfigurationInput>
    create: XOR<CreditConfigurationsWalletsCreateWithoutConfigurationInput, CreditConfigurationsWalletsUncheckedCreateWithoutConfigurationInput>
  }

  export type CreditConfigurationsWalletsUpdateWithWhereUniqueWithoutConfigurationInput = {
    where: CreditConfigurationsWalletsWhereUniqueInput
    data: XOR<CreditConfigurationsWalletsUpdateWithoutConfigurationInput, CreditConfigurationsWalletsUncheckedUpdateWithoutConfigurationInput>
  }

  export type CreditConfigurationsWalletsUpdateManyWithWhereWithoutConfigurationInput = {
    where: CreditConfigurationsWalletsScalarWhereInput
    data: XOR<CreditConfigurationsWalletsUpdateManyMutationInput, CreditConfigurationsWalletsUncheckedUpdateManyWithoutAttachedWalletsInput>
  }

  export type CreditConfigurationsWalletsScalarWhereInput = {
    AND?: Enumerable<CreditConfigurationsWalletsScalarWhereInput>
    OR?: Enumerable<CreditConfigurationsWalletsScalarWhereInput>
    NOT?: Enumerable<CreditConfigurationsWalletsScalarWhereInput>
    configurationId?: StringFilter | string
    walletId?: StringFilter | string
    upfrontPercentage?: FloatFilter | number
    fundFeesPercentage?: FloatFilter | number
    maxOrderAmount?: FloatFilter | number
    maxOutstandingCredit?: FloatFilter | number
    shareFeesPercentage?: FloatFilter | number
    postDeliveryPercentage?: FloatFilter | number
  }

  export type InstallmentUpsertWithWhereUniqueWithoutCreditConfigurationInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutCreditConfigurationInput, InstallmentUncheckedUpdateWithoutCreditConfigurationInput>
    create: XOR<InstallmentCreateWithoutCreditConfigurationInput, InstallmentUncheckedCreateWithoutCreditConfigurationInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutCreditConfigurationInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutCreditConfigurationInput, InstallmentUncheckedUpdateWithoutCreditConfigurationInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutCreditConfigurationInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutInstallmentInput>
  }

  export type CreditRequestUpsertWithoutCreditConfigurationInput = {
    update: XOR<CreditRequestUpdateWithoutCreditConfigurationInput, CreditRequestUncheckedUpdateWithoutCreditConfigurationInput>
    create: XOR<CreditRequestCreateWithoutCreditConfigurationInput, CreditRequestUncheckedCreateWithoutCreditConfigurationInput>
  }

  export type CreditRequestUpdateWithoutCreditConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    wallet?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutCreditRequestsInput
    order?: OrderUpdateOneWithoutCreditRequestInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditRequestUncheckedUpdateWithoutCreditConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCreditRequestStatusFieldUpdateOperationsInput | CreditRequestStatus
    orderId?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proceedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditConfigurationCreateWithoutAttachedWalletsInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    wallet: WalletCreateNestedOneWithoutCreditConfigurationsInput
    credit?: CreditCreateNestedManyWithoutCreditConfigurationInput
    Installment?: InstallmentCreateNestedManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedCreateWithoutAttachedWalletsInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    fundId: string
    credit?: CreditUncheckedCreateNestedManyWithoutCreditConfigurationInput
    Installment?: InstallmentUncheckedCreateNestedManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationCreateOrConnectWithoutAttachedWalletsInput = {
    where: CreditConfigurationWhereUniqueInput
    create: XOR<CreditConfigurationCreateWithoutAttachedWalletsInput, CreditConfigurationUncheckedCreateWithoutAttachedWalletsInput>
  }

  export type CreditConfigurationUpsertWithoutAttachedWalletsInput = {
    update: XOR<CreditConfigurationUpdateWithoutAttachedWalletsInput, CreditConfigurationUncheckedUpdateWithoutAttachedWalletsInput>
    create: XOR<CreditConfigurationCreateWithoutAttachedWalletsInput, CreditConfigurationUncheckedCreateWithoutAttachedWalletsInput>
  }

  export type CreditConfigurationUpdateWithoutAttachedWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet?: WalletUpdateOneRequiredWithoutCreditConfigurationsInput
    credit?: CreditUpdateManyWithoutCreditConfigurationInput
    Installment?: InstallmentUpdateManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUpdateOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedUpdateWithoutAttachedWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    fundId?: StringFieldUpdateOperationsInput | string
    credit?: CreditUncheckedUpdateManyWithoutCreditConfigurationInput
    Installment?: InstallmentUncheckedUpdateManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutCreditConfigurationInput
  }

  export type UserCreateWithoutOtherMemberKYCInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtherMemberKYCInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtherMemberKYCInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtherMemberKYCInput, UserUncheckedCreateWithoutOtherMemberKYCInput>
  }

  export type UserUpsertWithoutOtherMemberKYCInput = {
    update: XOR<UserUpdateWithoutOtherMemberKYCInput, UserUncheckedUpdateWithoutOtherMemberKYCInput>
    create: XOR<UserCreateWithoutOtherMemberKYCInput, UserUncheckedCreateWithoutOtherMemberKYCInput>
  }

  export type UserUpdateWithoutOtherMemberKYCInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOtherMemberKYCInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type WalletCreateWithoutSettingsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutSettingsInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutSettingsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutSettingsInput, WalletUncheckedCreateWithoutSettingsInput>
  }

  export type WalletUpsertWithoutSettingsInput = {
    update: XOR<WalletUpdateWithoutSettingsInput, WalletUncheckedUpdateWithoutSettingsInput>
    create: XOR<WalletCreateWithoutSettingsInput, WalletUncheckedCreateWithoutSettingsInput>
  }

  export type WalletUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletCreateWithoutSettlementInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutSettlementInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutSettlementInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutSettlementInput, WalletUncheckedCreateWithoutSettlementInput>
  }

  export type UserCreateWithoutSettlementInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettlementInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettlementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettlementInput, UserUncheckedCreateWithoutSettlementInput>
  }

  export type WalletCreateWithoutSettlementDefaultInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerCreateNestedManyWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutSettlementDefaultInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    answers?: AnswerUncheckedCreateNestedManyWithoutWalletInput
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutSettlementDefaultInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutSettlementDefaultInput, WalletUncheckedCreateWithoutSettlementDefaultInput>
  }

  export type WalletCreateManySettlementDefaultInputEnvelope = {
    data: Enumerable<WalletCreateManySettlementDefaultInput>
    skipDuplicates?: boolean
  }

  export type WalletUpsertWithoutSettlementInput = {
    update: XOR<WalletUpdateWithoutSettlementInput, WalletUncheckedUpdateWithoutSettlementInput>
    create: XOR<WalletCreateWithoutSettlementInput, WalletUncheckedCreateWithoutSettlementInput>
  }

  export type WalletUpdateWithoutSettlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutSettlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type UserUpsertWithoutSettlementInput = {
    update: XOR<UserUpdateWithoutSettlementInput, UserUncheckedUpdateWithoutSettlementInput>
    create: XOR<UserCreateWithoutSettlementInput, UserUncheckedCreateWithoutSettlementInput>
  }

  export type UserUpdateWithoutSettlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutSettlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type WalletUpsertWithWhereUniqueWithoutSettlementDefaultInput = {
    where: WalletWhereUniqueInput
    update: XOR<WalletUpdateWithoutSettlementDefaultInput, WalletUncheckedUpdateWithoutSettlementDefaultInput>
    create: XOR<WalletCreateWithoutSettlementDefaultInput, WalletUncheckedCreateWithoutSettlementDefaultInput>
  }

  export type WalletUpdateWithWhereUniqueWithoutSettlementDefaultInput = {
    where: WalletWhereUniqueInput
    data: XOR<WalletUpdateWithoutSettlementDefaultInput, WalletUncheckedUpdateWithoutSettlementDefaultInput>
  }

  export type WalletUpdateManyWithWhereWithoutSettlementDefaultInput = {
    where: WalletScalarWhereInput
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyWithoutWalletInput>
  }

  export type AnswerCreateWithoutQuestionInput = {
    id?: string
    createdAt?: Date | string
    answer: string
    answeredByReference?: string | null
    wallet: WalletCreateNestedOneWithoutAnswersInput
    answered?: UserCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    createdAt?: Date | string
    answer: string
    answeredBy?: string | null
    answeredByReference?: string | null
    account: string
  }

  export type AnswerCreateOrConnectWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerCreateManyQuestionInputEnvelope = {
    data: Enumerable<AnswerCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type AnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAnswersInput>
  }

  export type WalletCreateWithoutAnswersInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    settlementDefault?: SettlementCreateNestedOneWithoutWalletInput
    badges?: BadgeCreateNestedManyWithoutWalletInput
    billing?: BillingCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationCreateNestedManyWithoutWalletInput
    customer?: CustomerCreateNestedManyWithoutCustomerInput
    vendor?: CustomerCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataCreateNestedOneWithoutWalletInput
    order?: OrderCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutVendorWalletInput
    product?: ProductCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsCreateNestedOneWithoutWalletInput
    settlement?: SettlementCreateNestedManyWithoutWalletInput
    shipping?: ShippingCreateNestedManyWithoutWalletInput
    supplier?: SupplierCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierCreateNestedManyWithoutVendorInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutWalletInput
    visit?: VisitCreateNestedManyWithoutWalletInput
    users?: UserCreateNestedManyWithoutWalletsInput
    trust?: TrustCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutAnswersInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    settlementDefaultId?: string | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
    badges?: BadgeUncheckedCreateNestedManyWithoutWalletInput
    billing?: BillingUncheckedCreateNestedManyWithoutWalletInput
    creditorCredit?: CreditUncheckedCreateNestedManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedCreateNestedManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedCreateNestedManyWithoutWalletInput
    customer?: CustomerUncheckedCreateNestedManyWithoutCustomerInput
    vendor?: CustomerUncheckedCreateNestedManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedCreateNestedManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedCreateNestedManyWithoutDebtorInput
    metaData?: MetaDataUncheckedCreateNestedOneWithoutWalletInput
    order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutVendorWalletInput
    product?: ProductUncheckedCreateNestedManyWithoutVendorWalletInput
    settings?: SettingsUncheckedCreateNestedOneWithoutWalletInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutWalletInput
    shipping?: ShippingUncheckedCreateNestedManyWithoutWalletInput
    supplier?: SupplierUncheckedCreateNestedManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedCreateNestedManyWithoutVendorInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutWalletInput
    visit?: VisitUncheckedCreateNestedManyWithoutWalletInput
    users?: UserUncheckedCreateNestedManyWithoutWalletsInput
    trust?: TrustUncheckedCreateNestedOneWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutAnswersInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutAnswersInput, WalletUncheckedCreateWithoutAnswersInput>
  }

  export type UserCreateWithoutAnswersInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnswersInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionCreateWithoutAnswersInput = {
    id?: string
    answersType: answerTypeEnum
    category: QuestionCategoryEnum
    question: string
    isActive?: boolean
    description?: string | null
  }

  export type QuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    answersType: answerTypeEnum
    category: QuestionCategoryEnum
    question: string
    isActive?: boolean
    description?: string | null
  }

  export type QuestionCreateOrConnectWithoutAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
  }

  export type WalletUpsertWithoutAnswersInput = {
    update: XOR<WalletUpdateWithoutAnswersInput, WalletUncheckedUpdateWithoutAnswersInput>
    create: XOR<WalletCreateWithoutAnswersInput, WalletUncheckedCreateWithoutAnswersInput>
  }

  export type WalletUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type UserUpsertWithoutAnswersInput = {
    update: XOR<UserUpdateWithoutAnswersInput, UserUncheckedUpdateWithoutAnswersInput>
    create: XOR<UserCreateWithoutAnswersInput, UserUncheckedCreateWithoutAnswersInput>
  }

  export type UserUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type QuestionUpsertWithoutAnswersInput = {
    update: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    answersType?: EnumanswerTypeEnumFieldUpdateOperationsInput | answerTypeEnum
    category?: EnumQuestionCategoryEnumFieldUpdateOperationsInput | QuestionCategoryEnum
    question?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    answersType?: EnumanswerTypeEnumFieldUpdateOperationsInput | answerTypeEnum
    category?: EnumQuestionCategoryEnumFieldUpdateOperationsInput | QuestionCategoryEnum
    question?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutCreditRequestsInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityCreateNestedManyWithoutUserInput
    answers?: AnswerCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditCreateNestedManyWithoutAffiliateInput
    credits?: CreditCreateNestedManyWithoutUserInput
    installment?: InstallmentCreateNestedManyWithoutUserInput
    login?: LoginCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderCreateNestedManyWithoutAffiliateInput
    orders?: OrderCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCCreateNestedManyWithoutCreatedByInput
    product?: ProductCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsCreateNestedManyWithoutUserInput
    verify?: VerifyCreateNestedManyWithoutUserInput
    visit?: VisitCreateNestedManyWithoutVisitedInput
    wallets?: WalletCreateNestedManyWithoutUsersInput
    Settlement?: SettlementCreateNestedManyWithoutSettlementVerifierInput
  }

  export type UserUncheckedCreateWithoutCreditRequestsInput = {
    id?: string
    name?: string | null
    userPhoto?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    documentId?: string | null
    url?: string | null
    email?: string | null
    pin?: string | null
    deviceToken?: string | null
    createdAt?: Date | string
    verified?: boolean
    expoPushToken?: string | null
    inviterId?: string | null
    faceIdImage?: string | null
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    activity?: ActivityUncheckedCreateNestedManyWithoutUserInput
    answers?: AnswerUncheckedCreateNestedManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedCreateNestedManyWithoutAffiliateInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserInput
    installment?: InstallmentUncheckedCreateNestedManyWithoutUserInput
    login?: LoginUncheckedCreateNestedManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedCreateNestedManyWithoutAffiliateInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedCreateNestedManyWithoutCreatedByInput
    product?: ProductUncheckedCreateNestedManyWithoutAffiliateInput
    settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedCreateNestedManyWithoutUserInput
    verify?: VerifyUncheckedCreateNestedManyWithoutUserInput
    visit?: VisitUncheckedCreateNestedManyWithoutVisitedInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUsersInput
    Settlement?: SettlementUncheckedCreateNestedManyWithoutSettlementVerifierInput
  }

  export type UserCreateOrConnectWithoutCreditRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditRequestsInput, UserUncheckedCreateWithoutCreditRequestsInput>
  }

  export type OrderCreateWithoutCreditRequestInput = {
    id?: string
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
    affiliate?: UserCreateNestedOneWithoutOrdersAffiliateInput
    billing?: BillingCreateNestedOneWithoutOrderInput
    customer?: WalletCreateNestedOneWithoutOrderInput
    shipping?: ShippingCreateNestedOneWithoutOrderInput
    user?: UserCreateNestedOneWithoutOrdersInput
    vendorWallet?: WalletCreateNestedOneWithoutOrdersInput
    credit?: CreditCreateNestedOneWithoutOrderInput
    installments?: InstallmentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCreditRequestInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
    credit?: CreditUncheckedCreateNestedOneWithoutOrderInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCreditRequestInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCreditRequestInput, OrderUncheckedCreateWithoutCreditRequestInput>
  }

  export type CreditConfigurationCreateWithoutCreditRequestsInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    wallet: WalletCreateNestedOneWithoutCreditConfigurationsInput
    credit?: CreditCreateNestedManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsCreateNestedManyWithoutConfigurationInput
    Installment?: InstallmentCreateNestedManyWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedCreateWithoutCreditRequestsInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
    fundId: string
    credit?: CreditUncheckedCreateNestedManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUncheckedCreateNestedManyWithoutConfigurationInput
    Installment?: InstallmentUncheckedCreateNestedManyWithoutCreditConfigurationInput
  }

  export type CreditConfigurationCreateOrConnectWithoutCreditRequestsInput = {
    where: CreditConfigurationWhereUniqueInput
    create: XOR<CreditConfigurationCreateWithoutCreditRequestsInput, CreditConfigurationUncheckedCreateWithoutCreditRequestsInput>
  }

  export type UserUpsertWithoutCreditRequestsInput = {
    update: XOR<UserUpdateWithoutCreditRequestsInput, UserUncheckedUpdateWithoutCreditRequestsInput>
    create: XOR<UserCreateWithoutCreditRequestsInput, UserUncheckedCreateWithoutCreditRequestsInput>
  }

  export type UserUpdateWithoutCreditRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    wallets?: WalletUpdateManyWithoutUsersInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
  }

  export type UserUncheckedUpdateWithoutCreditRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    wallets?: WalletUncheckedUpdateManyWithoutUsersInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
  }

  export type OrderUpsertWithoutCreditRequestInput = {
    update: XOR<OrderUpdateWithoutCreditRequestInput, OrderUncheckedUpdateWithoutCreditRequestInput>
    create: XOR<OrderCreateWithoutCreditRequestInput, OrderUncheckedCreateWithoutCreditRequestInput>
  }

  export type OrderUpdateWithoutCreditRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    billing?: BillingUpdateOneWithoutOrderInput
    customer?: WalletUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    installments?: InstallmentUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutCreditRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
  }

  export type CreditConfigurationUpsertWithoutCreditRequestsInput = {
    update: XOR<CreditConfigurationUpdateWithoutCreditRequestsInput, CreditConfigurationUncheckedUpdateWithoutCreditRequestsInput>
    create: XOR<CreditConfigurationCreateWithoutCreditRequestsInput, CreditConfigurationUncheckedCreateWithoutCreditRequestsInput>
  }

  export type CreditConfigurationUpdateWithoutCreditRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    wallet?: WalletUpdateOneRequiredWithoutCreditConfigurationsInput
    credit?: CreditUpdateManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUpdateManyWithoutConfigurationInput
    Installment?: InstallmentUpdateManyWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedUpdateWithoutCreditRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    fundId?: StringFieldUpdateOperationsInput | string
    credit?: CreditUncheckedUpdateManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUncheckedUpdateManyWithoutConfigurationInput
    Installment?: InstallmentUncheckedUpdateManyWithoutCreditConfigurationInput
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    entityId?: string | null
    entityType?: ActivityEntityType | null
    priority?: ActivityPriority | null
    phoneNumber?: string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean | null
    createdAt?: Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AnswerCreateManyAnsweredInput = {
    id?: string
    questionId: string
    createdAt?: Date | string
    answer: string
    answeredByReference?: string | null
    account: string
  }

  export type CreditCreateManyAffiliateInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
  }

  export type CreditCreateManyUserInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
  }

  export type InstallmentCreateManyUserInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type LoginCreateManyUserInput = {
    id?: string
    qrKey?: string | null
    jwt?: string | null
    createdAt?: Date | string
  }

  export type OrderCreateManyAffiliateInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
  }

  export type OrderCreateManyUserInput = {
    id?: string
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
  }

  export type OtherMemberKYCCreateManyCreatedByInput = {
    id?: string
    name: string
    documentId: string
    documentCountry?: CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: string | null
    documentLastName?: string | null
    documentImage?: string | null
    documentGender?: GenderEnum | null
    documentDateOfBirth?: Date | string | null
    documentDateOfIssue?: Date | string | null
    documentSerialNumber?: string | null
    documentCreatedAt?: Date | string | null
    profilePictureURL: string
    idCardURL: string
    createdAt?: Date | string
    userIdToKYC: string
    OTP: string
  }

  export type ProductCreateManyAffiliateInput = {
    id?: string
    vendorId?: string | null
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
  }

  export type SettlementCreateManySettlementCreatorInput = {
    id?: string
    type: TransactionMethodEnum
    account: string
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    verifiedByUser?: string | null
    createdAt?: Date | string
    createdByAgent: boolean
  }

  export type UsersWalletsCreateManyUserInput = {
    walletId: string
    role?: WalletRole
  }

  export type VerifyCreateManyUserInput = {
    id?: string
    UID?: string | null
    phoneNumber?: string | null
    countryCode?: CountryCode | null
    createdAt?: Date | string | null
    creditConfigId?: string | null
    OTP?: string | null
    email?: string | null
    orderPaymentMethod?: OrderPaymentMethodsEnum | null
  }

  export type VisitCreateManyVisitedInput = {
    id?: string
    account: string
    createdAt?: Date | string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
  }

  export type SettlementCreateManySettlementVerifierInput = {
    id?: string
    type: TransactionMethodEnum
    account: string
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    createdAt?: Date | string
    createdBy: string
    createdByAgent: boolean
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumActivityEntityTypeFieldUpdateOperationsInput | ActivityEntityType | null
    priority?: NullableEnumActivityPriorityFieldUpdateOperationsInput | ActivityPriority | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumActivityEntityTypeFieldUpdateOperationsInput | ActivityEntityType | null
    priority?: NullableEnumActivityPriorityFieldUpdateOperationsInput | ActivityPriority | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableEnumActivityEntityTypeFieldUpdateOperationsInput | ActivityEntityType | null
    priority?: NullableEnumActivityPriorityFieldUpdateOperationsInput | ActivityPriority | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableJsonNullValueInput | InputJsonValue
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entity?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AnswerUpdateWithoutAnsweredInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneRequiredWithoutAnswersInput
    question?: QuestionUpdateOneRequiredWithoutAnswersInput
  }

  export type AnswerUncheckedUpdateWithoutAnsweredInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    account?: StringFieldUpdateOperationsInput | string
  }

  export type AnswerUncheckedUpdateManyWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    account?: StringFieldUpdateOperationsInput | string
  }

  export type CreditUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutCreditInput
    creditor?: WalletUpdateOneWithoutCreditorCreditInput
    debtor?: WalletUpdateOneWithoutDebtorCreditInput
    order?: OrderUpdateOneWithoutCreditInput
    user?: UserUpdateOneWithoutCreditsInput
    installments?: InstallmentUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    installments?: InstallmentUncheckedUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateManyWithoutCreditsAffilateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    affiliate?: UserUpdateOneWithoutCreditsAffilateInput
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutCreditInput
    creditor?: WalletUpdateOneWithoutCreditorCreditInput
    debtor?: WalletUpdateOneWithoutDebtorCreditInput
    order?: OrderUpdateOneWithoutCreditInput
    installments?: InstallmentUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    installments?: InstallmentUncheckedUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateManyWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InstallmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutInstallmentInput
    credit?: CreditUpdateOneWithoutInstallmentsInput
    creditor?: WalletUpdateOneWithoutCreditorInstallmentsInput
    debtor?: WalletUpdateOneWithoutDebtorInstallmentsInput
    order?: OrderUpdateOneWithoutInstallmentsInput
  }

  export type InstallmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type InstallmentUncheckedUpdateManyWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type LoginUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrKey?: NullableStringFieldUpdateOperationsInput | string | null
    jwt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrKey?: NullableStringFieldUpdateOperationsInput | string | null
    jwt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginUncheckedUpdateManyWithoutLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrKey?: NullableStringFieldUpdateOperationsInput | string | null
    jwt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    billing?: BillingUpdateOneWithoutOrderInput
    customer?: WalletUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    installments?: InstallmentUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateManyWithoutOrdersAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    billing?: BillingUpdateOneWithoutOrderInput
    customer?: WalletUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    installments?: InstallmentUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtherMemberKYCUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureURL?: StringFieldUpdateOperationsInput | string
    idCardURL?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userIdToKYC?: StringFieldUpdateOperationsInput | string
    OTP?: StringFieldUpdateOperationsInput | string
  }

  export type OtherMemberKYCUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureURL?: StringFieldUpdateOperationsInput | string
    idCardURL?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userIdToKYC?: StringFieldUpdateOperationsInput | string
    OTP?: StringFieldUpdateOperationsInput | string
  }

  export type OtherMemberKYCUncheckedUpdateManyWithoutOtherMemberKYCInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureURL?: StringFieldUpdateOperationsInput | string
    idCardURL?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userIdToKYC?: StringFieldUpdateOperationsInput | string
    OTP?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorWallet?: WalletUpdateOneWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettlementUpdateWithoutSettlementCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
    wallet?: WalletUpdateOneRequiredWithoutSettlementInput
    settlementVerifier?: UserUpdateOneWithoutSettlementInput
    Wallet?: WalletUpdateManyWithoutSettlementDefaultInput
  }

  export type SettlementUncheckedUpdateWithoutSettlementCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    account?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedByUser?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
    Wallet?: WalletUncheckedUpdateManyWithoutSettlementDefaultInput
  }

  export type SettlementUncheckedUpdateManyWithoutSettlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    account?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verifiedByUser?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsersWalletsUpdateWithoutUserInput = {
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
    wallet?: WalletUpdateOneRequiredWithoutUsersWalletsInput
  }

  export type UsersWalletsUncheckedUpdateWithoutUserInput = {
    walletId?: StringFieldUpdateOperationsInput | string
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
  }

  export type UsersWalletsUncheckedUpdateManyWithoutUsersWalletsInput = {
    walletId?: StringFieldUpdateOperationsInput | string
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
  }

  export type VerifyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    UID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orderPaymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
  }

  export type VerifyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    UID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orderPaymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
  }

  export type VerifyUncheckedUpdateManyWithoutVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    UID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    OTP?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orderPaymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
  }

  export type VisitUpdateWithoutVisitedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallet?: WalletUpdateOneRequiredWithoutVisitInput
  }

  export type VisitUncheckedUpdateWithoutVisitedInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VisitUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    settlementDefault?: SettlementUpdateOneWithoutWalletInput
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateManyWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    settlementDefaultId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettlementUpdateWithoutSettlementVerifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
    wallet?: WalletUpdateOneRequiredWithoutSettlementInput
    settlementCreator?: UserUpdateOneRequiredWithoutSettlementInput
    Wallet?: WalletUpdateManyWithoutSettlementDefaultInput
  }

  export type SettlementUncheckedUpdateWithoutSettlementVerifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum
    account?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    paybillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByAgent?: BoolFieldUpdateOperationsInput | boolean
    Wallet?: WalletUncheckedUpdateManyWithoutSettlementDefaultInput
  }

  export type AnswerCreateManyWalletInput = {
    id?: string
    questionId: string
    createdAt?: Date | string
    answer: string
    answeredBy?: string | null
    answeredByReference?: string | null
  }

  export type BadgeCreateManyWalletInput = {
    id?: string
    active?: boolean | null
    createdAt?: Date | string | null
    type?: BadgeType | null
    count?: number | null
    level?: number | null
  }

  export type BillingCreateManyWalletInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    phoneNumber?: string | null
  }

  export type CreditCreateManyCreditorInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
  }

  export type CreditCreateManyDebtorInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    creditConfigurationId: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
  }

  export type CreditConfigurationCreateManyWalletInput = {
    id?: string
    name: string
    shouldPayDeposit?: boolean | null
    depositPercentage?: number
    duration: number
    slices: SlicesEnum
    seviFeesPercentage: number
    daysToStartAfterDelivery?: number
    lateInstallmentFeesPercentage: number
    affiliatePercentage: number
    creditLateFeesPercentage: number
    creditLateDays: number
    createdAt?: Date | string | null
    status?: CreditConfigurationStatus
    numberOfAllowedCredits?: number
    fundFeesPercentage?: number | null
  }

  export type CustomerCreateManyCustomerInput = {
    vendorId: string
  }

  export type CustomerCreateManyVendorInput = {
    customerId: string
  }

  export type InstallmentCreateManyCreditorInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentCreateManyDebtorInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    referenceNumber?: string | null
  }

  export type OrderCreateManyVendorWalletInput = {
    id?: string
    userId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
  }

  export type ProductCreateManyVendorWalletInput = {
    id?: string
    quantity?: number | null
    vendorName?: string | null
    vendorType?: string | null
    name?: string | null
    price?: number | null
    unitPrice?: number | null
    listedPublic?: boolean | null
    description?: string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    ecommercePlatform?: EcommercePlatformEnum | null
    platformId?: string | null
    affiliateId?: string | null
  }

  export type SettlementCreateManyWalletInput = {
    id?: string
    type: TransactionMethodEnum
    bankAccount?: string | null
    bankAccountName?: string | null
    bankBranch?: string | null
    bankName?: string | null
    phoneNumber?: string | null
    tillNumber?: string | null
    paybillNumber?: string | null
    verified?: boolean | null
    verifiedByUser?: string | null
    createdAt?: Date | string
    createdBy: string
    createdByAgent: boolean
  }

  export type ShippingCreateManyWalletInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    company?: string | null
    address1?: string | null
    address2?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    email?: string | null
    longitude?: string | null
    shippingType?: ShippingTypeEnum | null
    shippingFee?: number | null
    latitude?: string | null
    phoneNumber?: string | null
    isDefault?: boolean | null
    seviVerified?: boolean | null
    createdAt?: Date | string | null
  }

  export type SupplierCreateManySupplierInput = {
    vendorId: string
  }

  export type SupplierCreateManyVendorInput = {
    supplierId: string
  }

  export type TransactionCreateManyWalletInput = {
    id?: string
    amount: number
    fee: number
    totalAmount: number
    description?: string | null
    paymentType: PaymentTypesEnum
    paymentTypeId?: string | null
    currency?: CurrencyEnum
    transactionType?: TransactionTypeEnum | null
    method?: TransactionMethodEnum | null
    createdAt?: Date | string
    name?: string | null
    balanceAfter?: number | null
    balanceBefore?: number | null
  }

  export type UsersWalletsCreateManyWalletInput = {
    userId: string
    role?: WalletRole
  }

  export type VisitCreateManyWalletInput = {
    id?: string
    createdAt?: Date | string | null
    visitedBy?: string | null
    visitedByReference?: string | null
    whenVisitTookPlace?: Date | string | null
  }

  export type AnswerUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    answered?: UserUpdateOneWithoutAnswersInput
    question?: QuestionUpdateOneRequiredWithoutAnswersInput
  }

  export type AnswerUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BadgeUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumBadgeTypeFieldUpdateOperationsInput | BadgeType | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BadgeUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumBadgeTypeFieldUpdateOperationsInput | BadgeType | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BadgeUncheckedUpdateManyWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableEnumBadgeTypeFieldUpdateOperationsInput | BadgeType | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BillingUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateManyWithoutBillingInput
  }

  export type BillingUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUncheckedUpdateManyWithoutBillingInput
  }

  export type BillingUncheckedUpdateManyWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditUpdateWithoutCreditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    affiliate?: UserUpdateOneWithoutCreditsAffilateInput
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutCreditInput
    debtor?: WalletUpdateOneWithoutDebtorCreditInput
    order?: OrderUpdateOneWithoutCreditInput
    user?: UserUpdateOneWithoutCreditsInput
    installments?: InstallmentUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateWithoutCreditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    installments?: InstallmentUncheckedUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateManyWithoutCreditorCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    affiliate?: UserUpdateOneWithoutCreditsAffilateInput
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutCreditInput
    creditor?: WalletUpdateOneWithoutCreditorCreditInput
    order?: OrderUpdateOneWithoutCreditInput
    user?: UserUpdateOneWithoutCreditsInput
    installments?: InstallmentUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    installments?: InstallmentUncheckedUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateManyWithoutDebtorCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditConfigurationUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: CreditUpdateManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUpdateManyWithoutConfigurationInput
    Installment?: InstallmentUpdateManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUpdateOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    credit?: CreditUncheckedUpdateManyWithoutCreditConfigurationInput
    attachedWallets?: CreditConfigurationsWalletsUncheckedUpdateManyWithoutConfigurationInput
    Installment?: InstallmentUncheckedUpdateManyWithoutCreditConfigurationInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutCreditConfigurationInput
  }

  export type CreditConfigurationUncheckedUpdateManyWithoutCreditConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shouldPayDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositPercentage?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    slices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    seviFeesPercentage?: FloatFieldUpdateOperationsInput | number
    daysToStartAfterDelivery?: IntFieldUpdateOperationsInput | number
    lateInstallmentFeesPercentage?: FloatFieldUpdateOperationsInput | number
    affiliatePercentage?: FloatFieldUpdateOperationsInput | number
    creditLateFeesPercentage?: FloatFieldUpdateOperationsInput | number
    creditLateDays?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumCreditConfigurationStatusFieldUpdateOperationsInput | CreditConfigurationStatus
    numberOfAllowedCredits?: IntFieldUpdateOperationsInput | number
    fundFeesPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CustomerUpdateWithoutCustomerInput = {
    vendor?: WalletUpdateOneRequiredWithoutVendorInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerInput = {
    vendorId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerUpdateWithoutVendorInput = {
    customer?: WalletUpdateOneRequiredWithoutCustomerInput
  }

  export type CustomerUncheckedUpdateWithoutVendorInput = {
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type InstallmentUpdateWithoutCreditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutInstallmentInput
    credit?: CreditUpdateOneWithoutInstallmentsInput
    debtor?: WalletUpdateOneWithoutDebtorInstallmentsInput
    order?: OrderUpdateOneWithoutInstallmentsInput
    user?: UserUpdateOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedUpdateWithoutCreditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type InstallmentUncheckedUpdateManyWithoutCreditorInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type InstallmentUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutInstallmentInput
    credit?: CreditUpdateOneWithoutInstallmentsInput
    creditor?: WalletUpdateOneWithoutCreditorInstallmentsInput
    order?: OrderUpdateOneWithoutInstallmentsInput
    user?: UserUpdateOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type InstallmentUncheckedUpdateManyWithoutDebtorInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    billing?: BillingUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    installments?: InstallmentUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutVendorWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    billing?: BillingUpdateOneWithoutOrderInput
    customer?: WalletUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    installments?: InstallmentUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutVendorWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type ProductUpdateWithoutVendorWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutVendorWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    vendorName?: NullableStringFieldUpdateOperationsInput | string | null
    vendorType?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    listedPublic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableJsonNullValueInput | InputJsonValue
    categories?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShippingUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: OrderUpdateManyWithoutShippingInput
  }

  export type ShippingUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Order?: OrderUncheckedUpdateManyWithoutShippingInput
  }

  export type ShippingUncheckedUpdateManyWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    address1?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    shippingType?: NullableEnumShippingTypeEnumFieldUpdateOperationsInput | ShippingTypeEnum | null
    shippingFee?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    seviVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierUpdateWithoutSupplierInput = {
    vendor?: WalletUpdateOneRequiredWithoutVendorSupplierInput
  }

  export type SupplierUncheckedUpdateWithoutSupplierInput = {
    vendorId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierUpdateWithoutVendorInput = {
    supplier?: WalletUpdateOneRequiredWithoutSupplierInput
  }

  export type SupplierUncheckedUpdateWithoutVendorInput = {
    supplierId?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierUncheckedUpdateManyWithoutVendorSupplierInput = {
    supplierId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: EnumPaymentTypesEnumFieldUpdateOperationsInput | PaymentTypesEnum
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum
    transactionType?: NullableEnumTransactionTypeEnumFieldUpdateOperationsInput | TransactionTypeEnum | null
    method?: NullableEnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    balanceBefore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: EnumPaymentTypesEnumFieldUpdateOperationsInput | PaymentTypesEnum
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum
    transactionType?: NullableEnumTransactionTypeEnumFieldUpdateOperationsInput | TransactionTypeEnum | null
    method?: NullableEnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    balanceBefore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    fee?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentType?: EnumPaymentTypesEnumFieldUpdateOperationsInput | PaymentTypesEnum
    paymentTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum
    transactionType?: NullableEnumTransactionTypeEnumFieldUpdateOperationsInput | TransactionTypeEnum | null
    method?: NullableEnumTransactionMethodEnumFieldUpdateOperationsInput | TransactionMethodEnum | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    balanceAfter?: NullableFloatFieldUpdateOperationsInput | number | null
    balanceBefore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UsersWalletsUpdateWithoutWalletInput = {
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
    user?: UserUpdateOneRequiredWithoutUsersWalletsInput
  }

  export type UsersWalletsUncheckedUpdateWithoutWalletInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumWalletRoleFieldUpdateOperationsInput | WalletRole
  }

  export type VisitUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visited?: UserUpdateOneWithoutVisitInput
  }

  export type VisitUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    visitedByReference?: NullableStringFieldUpdateOperationsInput | string | null
    whenVisitTookPlace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUpdateManyWithoutUserInput
    answers?: AnswerUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUpdateManyWithoutAffiliateInput
    credits?: CreditUpdateManyWithoutUserInput
    installment?: InstallmentUpdateManyWithoutUserInput
    login?: LoginUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUpdateManyWithoutAffiliateInput
    orders?: OrderUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUpdateManyWithoutCreatedByInput
    product?: ProductUpdateManyWithoutAffiliateInput
    settlement?: SettlementUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUpdateManyWithoutUserInput
    verify?: VerifyUpdateManyWithoutUserInput
    visit?: VisitUpdateManyWithoutVisitedInput
    Settlement?: SettlementUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activity?: ActivityUncheckedUpdateManyWithoutUserInput
    answers?: AnswerUncheckedUpdateManyWithoutAnsweredInput
    creditsAffilate?: CreditUncheckedUpdateManyWithoutAffiliateInput
    credits?: CreditUncheckedUpdateManyWithoutUserInput
    installment?: InstallmentUncheckedUpdateManyWithoutUserInput
    login?: LoginUncheckedUpdateManyWithoutUserInput
    ordersAffiliate?: OrderUncheckedUpdateManyWithoutAffiliateInput
    orders?: OrderUncheckedUpdateManyWithoutUserInput
    otherMemberKYC?: OtherMemberKYCUncheckedUpdateManyWithoutCreatedByInput
    product?: ProductUncheckedUpdateManyWithoutAffiliateInput
    settlement?: SettlementUncheckedUpdateManyWithoutSettlementCreatorInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutUserInput
    verify?: VerifyUncheckedUpdateManyWithoutUserInput
    visit?: VisitUncheckedUpdateManyWithoutVisitedInput
    Settlement?: SettlementUncheckedUpdateManyWithoutSettlementVerifierInput
    creditRequests?: CreditRequestUncheckedUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    expoPushToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    faceIdImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentCountry?: NullableEnumCountryCodeFieldUpdateOperationsInput | CountryCode | null
    documentData?: NullableJsonNullValueInput | InputJsonValue
    documentFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    documentLastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentImage?: NullableStringFieldUpdateOperationsInput | string | null
    documentGender?: NullableEnumGenderEnumFieldUpdateOperationsInput | GenderEnum | null
    documentDateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentDateOfIssue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentSerialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstallmentCreateManyOrderInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutInstallmentInput
    credit?: CreditUpdateOneWithoutInstallmentsInput
    creditor?: WalletUpdateOneWithoutCreditorInstallmentsInput
    debtor?: WalletUpdateOneWithoutDebtorInstallmentsInput
    user?: UserUpdateOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type InstallmentUncheckedUpdateManyWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type OrderCreateManyBillingInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    shippingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
  }

  export type OrderUpdateWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    customer?: WalletUpdateOneWithoutOrderInput
    shipping?: ShippingUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    installments?: InstallmentUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type OrderCreateManyShippingInput = {
    id?: string
    userId?: string | null
    vendorId?: string | null
    status?: OrderStatusEnum | null
    notes?: string | null
    name?: string | null
    phoneNumber?: string | null
    affiliateId?: string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: string | null
    createdAt?: Date | string
    paymentStatus?: PaymentStatusEnum
    amount: number
    paymentMethod?: OrderPaymentMethodsEnum | null
    billingId?: string | null
    ecommercePlatform?: EcommercePlatformEnum | null
    currency?: CurrencyEnum | null
    platformId?: string | null
    customerId?: string | null
    referenceNumber?: string | null
  }

  export type OrderUpdateWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: UserUpdateOneWithoutOrdersAffiliateInput
    billing?: BillingUpdateOneWithoutOrderInput
    customer?: WalletUpdateOneWithoutOrderInput
    user?: UserUpdateOneWithoutOrdersInput
    vendorWallet?: WalletUpdateOneWithoutOrdersInput
    credit?: CreditUpdateOneWithoutOrderInput
    installments?: InstallmentUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUpdateOneWithoutOrderInput
  }

  export type OrderUncheckedUpdateWithoutShippingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumOrderStatusEnumFieldUpdateOperationsInput | OrderStatusEnum | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    products?: NullableJsonNullValueInput | InputJsonValue
    items?: NullableJsonNullValueInput | InputJsonValue
    deliveryCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: EnumPaymentStatusEnumFieldUpdateOperationsInput | PaymentStatusEnum
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumOrderPaymentMethodsEnumFieldUpdateOperationsInput | OrderPaymentMethodsEnum | null
    billingId?: NullableStringFieldUpdateOperationsInput | string | null
    ecommercePlatform?: NullableEnumEcommercePlatformEnumFieldUpdateOperationsInput | EcommercePlatformEnum | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    platformId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: CreditUncheckedUpdateOneWithoutOrderInput
    installments?: InstallmentUncheckedUpdateManyWithoutOrderInput
    creditRequest?: CreditRequestUncheckedUpdateOneWithoutOrderInput
  }

  export type InstallmentCreateManyCreditInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    creditConfigurationId: string
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type InstallmentUpdateWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    creditConfiguration?: CreditConfigurationUpdateOneRequiredWithoutInstallmentInput
    creditor?: WalletUpdateOneWithoutCreditorInstallmentsInput
    debtor?: WalletUpdateOneWithoutDebtorInstallmentsInput
    order?: OrderUpdateOneWithoutInstallmentsInput
    user?: UserUpdateOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedUpdateWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditConfigurationId?: StringFieldUpdateOperationsInput | string
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type CreditCreateManyCreditConfigurationInput = {
    id?: string
    typeId?: string | null
    currency?: CurrencyEnum | null
    orderId?: string | null
    type?: creditRefType | null
    amount?: number | null
    debtorId?: string | null
    creditorId?: string | null
    installmentsCount?: number | null
    installmentsCountPaid?: number | null
    status?: creditStatusEnum | null
    description?: string | null
    totalPaid?: number | null
    totalToPay?: number | null
    agreedDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    referenceNumber: string
    endDate?: Date | string | null
    paidAt?: Date | string | null
    duration?: number | null
    durationSlices: SlicesEnum
    affiliateId?: string | null
    defaultAt?: Date | string | null
    fundUpfrontAmount?: number | null
    orderWalletId?: string | null
    fundFeesAmount?: number | null
    amountWithFees?: number | null
    seviFeesAmount?: number | null
    orderWalletShareFeesAmount?: number | null
    fundPostDeliveryAmount?: number | null
  }

  export type CreditConfigurationsWalletsCreateManyConfigurationInput = {
    walletId: string
    upfrontPercentage: number
    fundFeesPercentage: number
    maxOrderAmount: number
    maxOutstandingCredit: number
    shareFeesPercentage?: number
    postDeliveryPercentage?: number
  }

  export type InstallmentCreateManyCreditConfigurationInput = {
    id?: string
    installmentCount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceNumber?: string | null
    amount: number
    paidAmount?: number
    debtorId?: string | null
    creditorId?: string | null
    orderId?: string | null
    status?: installmentStatusTypeEnum | null
    firstTryFailedAt?: Date | string | null
    creditId?: string | null
    createdAt?: Date | string
    userId?: string | null
    amountWithPenalty: number
    seviFees: number
    penalty?: number
    paidAt?: Date | string | null
    affiliateFees: number
    currency?: CurrencyEnum | null
  }

  export type CreditUpdateWithoutCreditConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    affiliate?: UserUpdateOneWithoutCreditsAffilateInput
    creditor?: WalletUpdateOneWithoutCreditorCreditInput
    debtor?: WalletUpdateOneWithoutDebtorCreditInput
    order?: OrderUpdateOneWithoutCreditInput
    user?: UserUpdateOneWithoutCreditsInput
    installments?: InstallmentUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateWithoutCreditConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    installments?: InstallmentUncheckedUpdateManyWithoutCreditInput
  }

  export type CreditUncheckedUpdateManyWithoutCreditInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumcreditRefTypeFieldUpdateOperationsInput | creditRefType | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    installmentsCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentsCountPaid?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumcreditStatusEnumFieldUpdateOperationsInput | creditStatusEnum | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    totalToPay?: NullableFloatFieldUpdateOperationsInput | number | null
    agreedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    durationSlices?: EnumSlicesEnumFieldUpdateOperationsInput | SlicesEnum
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundUpfrontAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletId?: NullableStringFieldUpdateOperationsInput | string | null
    fundFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountWithFees?: NullableFloatFieldUpdateOperationsInput | number | null
    seviFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    orderWalletShareFeesAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    fundPostDeliveryAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CreditConfigurationsWalletsUpdateWithoutConfigurationInput = {
    walletId?: StringFieldUpdateOperationsInput | string
    upfrontPercentage?: FloatFieldUpdateOperationsInput | number
    fundFeesPercentage?: FloatFieldUpdateOperationsInput | number
    maxOrderAmount?: FloatFieldUpdateOperationsInput | number
    maxOutstandingCredit?: FloatFieldUpdateOperationsInput | number
    shareFeesPercentage?: FloatFieldUpdateOperationsInput | number
    postDeliveryPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type CreditConfigurationsWalletsUncheckedUpdateWithoutConfigurationInput = {
    walletId?: StringFieldUpdateOperationsInput | string
    upfrontPercentage?: FloatFieldUpdateOperationsInput | number
    fundFeesPercentage?: FloatFieldUpdateOperationsInput | number
    maxOrderAmount?: FloatFieldUpdateOperationsInput | number
    maxOutstandingCredit?: FloatFieldUpdateOperationsInput | number
    shareFeesPercentage?: FloatFieldUpdateOperationsInput | number
    postDeliveryPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type CreditConfigurationsWalletsUncheckedUpdateManyWithoutAttachedWalletsInput = {
    walletId?: StringFieldUpdateOperationsInput | string
    upfrontPercentage?: FloatFieldUpdateOperationsInput | number
    fundFeesPercentage?: FloatFieldUpdateOperationsInput | number
    maxOrderAmount?: FloatFieldUpdateOperationsInput | number
    maxOutstandingCredit?: FloatFieldUpdateOperationsInput | number
    shareFeesPercentage?: FloatFieldUpdateOperationsInput | number
    postDeliveryPercentage?: FloatFieldUpdateOperationsInput | number
  }

  export type InstallmentUpdateWithoutCreditConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    credit?: CreditUpdateOneWithoutInstallmentsInput
    creditor?: WalletUpdateOneWithoutCreditorInstallmentsInput
    debtor?: WalletUpdateOneWithoutDebtorInstallmentsInput
    order?: OrderUpdateOneWithoutInstallmentsInput
    user?: UserUpdateOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedUpdateWithoutCreditConfigurationInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    creditorId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnuminstallmentStatusTypeEnumFieldUpdateOperationsInput | installmentStatusTypeEnum | null
    firstTryFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creditId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amountWithPenalty?: FloatFieldUpdateOperationsInput | number
    seviFees?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateFees?: FloatFieldUpdateOperationsInput | number
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
  }

  export type WalletCreateManySettlementDefaultInput = {
    id?: string
    name?: string | null
    category?: string | null
    type: WalletTypesEnum
    balance?: number
    account: string
    createdAt?: Date | string
    currency?: CurrencyEnum | null
    settlementAutomatic?: boolean | null
    verificationStartedAt?: Date | string | null
    shippingId?: string | null
    picture?: string | null
  }

  export type WalletUpdateWithoutSettlementDefaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUpdateManyWithoutWalletInput
    badges?: BadgeUpdateManyWithoutWalletInput
    billing?: BillingUpdateManyWithoutWalletInput
    creditorCredit?: CreditUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUpdateManyWithoutWalletInput
    customer?: CustomerUpdateManyWithoutCustomerInput
    vendor?: CustomerUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUpdateManyWithoutDebtorInput
    metaData?: MetaDataUpdateOneWithoutWalletInput
    order?: OrderUpdateManyWithoutCustomerInput
    orders?: OrderUpdateManyWithoutVendorWalletInput
    product?: ProductUpdateManyWithoutVendorWalletInput
    settings?: SettingsUpdateOneWithoutWalletInput
    settlement?: SettlementUpdateManyWithoutWalletInput
    shipping?: ShippingUpdateManyWithoutWalletInput
    supplier?: SupplierUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUpdateManyWithoutVendorInput
    transaction?: TransactionUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUpdateManyWithoutWalletInput
    visit?: VisitUpdateManyWithoutWalletInput
    users?: UserUpdateManyWithoutWalletsInput
    trust?: TrustUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateWithoutSettlementDefaultInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswerUncheckedUpdateManyWithoutWalletInput
    badges?: BadgeUncheckedUpdateManyWithoutWalletInput
    billing?: BillingUncheckedUpdateManyWithoutWalletInput
    creditorCredit?: CreditUncheckedUpdateManyWithoutCreditorInput
    debtorCredit?: CreditUncheckedUpdateManyWithoutDebtorInput
    creditConfigurations?: CreditConfigurationUncheckedUpdateManyWithoutWalletInput
    customer?: CustomerUncheckedUpdateManyWithoutCustomerInput
    vendor?: CustomerUncheckedUpdateManyWithoutVendorInput
    creditorInstallments?: InstallmentUncheckedUpdateManyWithoutCreditorInput
    debtorInstallments?: InstallmentUncheckedUpdateManyWithoutDebtorInput
    metaData?: MetaDataUncheckedUpdateOneWithoutWalletInput
    order?: OrderUncheckedUpdateManyWithoutCustomerInput
    orders?: OrderUncheckedUpdateManyWithoutVendorWalletInput
    product?: ProductUncheckedUpdateManyWithoutVendorWalletInput
    settings?: SettingsUncheckedUpdateOneWithoutWalletInput
    settlement?: SettlementUncheckedUpdateManyWithoutWalletInput
    shipping?: ShippingUncheckedUpdateManyWithoutWalletInput
    supplier?: SupplierUncheckedUpdateManyWithoutSupplierInput
    vendorSupplier?: SupplierUncheckedUpdateManyWithoutVendorInput
    transaction?: TransactionUncheckedUpdateManyWithoutWalletInput
    usersWallets?: UsersWalletsUncheckedUpdateManyWithoutWalletInput
    visit?: VisitUncheckedUpdateManyWithoutWalletInput
    users?: UserUncheckedUpdateManyWithoutWalletsInput
    trust?: TrustUncheckedUpdateOneWithoutWalletInput
  }

  export type WalletUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWalletTypesEnumFieldUpdateOperationsInput | WalletTypesEnum
    balance?: FloatFieldUpdateOperationsInput | number
    account?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableEnumCurrencyEnumFieldUpdateOperationsInput | CurrencyEnum | null
    settlementAutomatic?: NullableBoolFieldUpdateOperationsInput | boolean | null
    verificationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingId?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerCreateManyQuestionInput = {
    id?: string
    createdAt?: Date | string
    answer: string
    answeredBy?: string | null
    answeredByReference?: string | null
    account: string
  }

  export type AnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneRequiredWithoutAnswersInput
    answered?: UserUpdateOneWithoutAnswersInput
  }

  export type AnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: StringFieldUpdateOperationsInput | string
    answeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    answeredByReference?: NullableStringFieldUpdateOperationsInput | string | null
    account?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}